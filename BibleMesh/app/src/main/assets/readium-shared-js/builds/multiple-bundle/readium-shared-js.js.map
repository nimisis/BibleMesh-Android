{
  "version": 3,
  "sources": [
    "../../js/globals.js",
    "es6-collections.js",
    "readium_js_plugins.js",
    "../../js/globalsSetup.js",
    "../../js/models/bookmark_data.js",
    "../../js/models/current_pages_info.js",
    "../../js/models/fixed_page_spread.js",
    "../../js/models/spine_item.js",
    "../../js/helpers.js",
    "../../js/views/cfi_navigation_logic.js",
    "../../js/models/viewer_settings.js",
    "ResizeSensor.js",
    "../../js/views/one_page_view.js",
    "../../js/models/page_open_request.js",
    "../../js/views/fixed_view.js",
    "../../js/views/iframe_loader.js",
    "../../js/views/internal_links_support.js",
    "../../js/models/smil_iterator.js",
    "../../js/views/media_overlay_data_injector.js",
    "../../js/views/audio_player.js",
    "../../js/views/media_overlay_element_highlighter.js",
    "../../js/views/scroll_view.js",
    "../../js/views/media_overlay_player.js",
    "../../js/models/spine.js",
    "../../js/models/smil_model.js",
    "../../js/models/media_overlay.js",
    "../../js/models/package_data.js",
    "../../js/models/package.js",
    "../../js/views/reflowable_view.js",
    "../../js/models/style.js",
    "../../js/models/style_collection.js",
    "../../js/models/switches.js",
    "../../js/models/trigger.js",
    "../../js/models/node_range_info.js",
    "../../js/views/reader_view.js",
    "../../../../../../../../../module-create.js",
    "../../../../../../../../../module-insertRequire.js"
  ],
  "names": [],
  "mappings": "AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACxLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACvOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC3LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACpFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACvEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC9LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACrSA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC9iBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACx2BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC1nDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACvQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC3NA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AChjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC7IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACp2BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC/IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACpOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACtQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACpjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC/tBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACpjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACz6CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC5mEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC7VA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACzqCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC3aA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACnFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACnPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC1mCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACxEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACvJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACnGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACrJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AChGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AClpDA;AACA;AACA,ACFA;AACA;AACA",
  "file": "readium-shared-js.js",
  "sourcesContent": [
    "//  LauncherOSX\r\n//\r\n//  Created by Boris Schneiderman.\r\n//  Copyright (c) 2014 Readium Foundation and/or its licensees. All rights reserved.\r\n//  \r\n//  Redistribution and use in source and binary forms, with or without modification, \r\n//  are permitted provided that the following conditions are met:\r\n//  1. Redistributions of source code must retain the above copyright notice, this \r\n//  list of conditions and the following disclaimer.\r\n//  2. Redistributions in binary form must reproduce the above copyright notice, \r\n//  this list of conditions and the following disclaimer in the documentation and/or \r\n//  other materials provided with the distribution.\r\n//  3. Neither the name of the organization nor the names of its contributors may be \r\n//  used to endorse or promote products derived from this software without specific \r\n//  prior written permission.\r\n//  \r\n//  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND \r\n//  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED \r\n//  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. \r\n//  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, \r\n//  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, \r\n//  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, \r\n//  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF \r\n//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE \r\n//  OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED \r\n//  OF THE POSSIBILITY OF SUCH DAMAGE.\r\n\r\ndefine('readium_shared_js/globals',['jquery','eventEmitter'], function($, EventEmitter) {\r\n    \r\n    var DEBUG = false;\r\n    \r\n/**\r\n * Top level ReadiumSDK namespace\r\n * @namespace\r\n */\r\nvar Globals = {\r\n\r\n    /**\r\n     * Current version of the JS SDK\r\n     * @static\r\n     * @return {string} version\r\n     */\r\n    version: function () {\r\n        return \"0.8.0\";\r\n    },\r\n    /**\r\n     * @namespace\r\n     */\r\n    Views: {\r\n        /**\r\n         * Landscape Orientation\r\n         */\r\n        ORIENTATION_LANDSCAPE: \"orientation_landscape\",\r\n        /**\r\n         * Portrait Orientation\r\n         */\r\n        ORIENTATION_PORTRAIT: \"orientation_portrait\"\r\n    },\r\n    /**\r\n     * @namespace\r\n     */\r\n    Events: {\r\n        /**\r\n         * @event\r\n         */\r\n        READER_INITIALIZED: \"ReaderInitialized\",\r\n        /**\r\n         * This gets triggered on every page turnover. It includes spine information and such.\r\n         * @event\r\n         */\r\n        PAGINATION_CHANGED: \"PaginationChanged\",\r\n        /**\r\n         * @event\r\n         */\r\n        SETTINGS_APPLIED: \"SettingsApplied\",\r\n        /**\r\n         * @event\r\n         */\r\n        FXL_VIEW_RESIZED: \"FXLViewResized\",\r\n        /**\r\n         * @event\r\n         */\r\n        READER_VIEW_CREATED: \"ReaderViewCreated\",\r\n        /**\r\n         * @event\r\n         */\r\n        READER_VIEW_DESTROYED: \"ReaderViewDestroyed\",\r\n        /**\r\n         * @event\r\n         */\r\n        CONTENT_DOCUMENT_LOAD_START: \"ContentDocumentLoadStart\",\r\n        /**\r\n         * @event\r\n         */\r\n        CONTENT_DOCUMENT_LOADED: \"ContentDocumentLoaded\",\r\n        /**\r\n         * @event\r\n         */\r\n        CONTENT_DOCUMENT_UNLOADED: \"ContentDocumentUnloaded\",\r\n        /**\r\n         * @event\r\n         */\r\n        MEDIA_OVERLAY_STATUS_CHANGED: \"MediaOverlayStatusChanged\",\r\n        /**\r\n         * @event\r\n         */\r\n        MEDIA_OVERLAY_TTS_SPEAK: \"MediaOverlayTTSSpeak\",\r\n        /**\r\n         * @event\r\n         */\r\n        MEDIA_OVERLAY_TTS_STOP: \"MediaOverlayTTSStop\",\r\n        /**\r\n         * @event\r\n         */\r\n        PLUGINS_LOADED: \"PluginsLoaded\"\r\n    },\r\n    /**\r\n     * Internal Events\r\n     *\r\n     * @desc Should not be triggered outside of {@link Views.ReaderView}.\r\n     * @namespace\r\n     */\r\n    InternalEvents: {\r\n        /**\r\n         * @event\r\n         */\r\n        CURRENT_VIEW_PAGINATION_CHANGED: \"CurrentViewPaginationChanged\",\r\n    },\r\n    \r\n    logEvent: function(eventName, eventType, eventSource) {\r\n        if (DEBUG) {\r\n            console.debug(\"#### ReadiumSDK.Events.\" + eventName + \" - \"+eventType+\" - \" + eventSource);\r\n        }\r\n    }\r\n};\r\n$.extend(Globals, new EventEmitter());\r\n\r\nreturn Globals;\r\n\r\n});\r\n\r\n//This is default implementation of reading system object that will be available for the publication's javascript to analyze at runtime\r\n//To extend/modify/replace this object reading system should subscribe Globals.Events.READER_INITIALIZED and apply changes in reaction to this event\r\nnavigator.epubReadingSystem = {\r\n    name: \"\",\r\n    version: \"0.0.0\",\r\n    layoutStyle: \"paginated\",\r\n\r\n    hasFeature: function (feature, version) {\r\n\r\n        // for now all features must be version 1.0 so fail fast if the user has asked for something else\r\n        if (version && version !== \"1.0\") {\r\n            return false;\r\n        }\r\n\r\n        if (feature === \"dom-manipulation\") {\r\n            // Scripts may make structural changes to the document???s DOM (applies to spine-level scripting only).\r\n            return true;\r\n        }\r\n        if (feature === \"layout-changes\") {\r\n            // Scripts may modify attributes and CSS styles that affect content layout (applies to spine-level scripting only).\r\n            return true;\r\n        }\r\n        if (feature === \"touch-events\") {\r\n            // The device supports touch events and the Reading System passes touch events to the content.\r\n            return false;\r\n        }\r\n        if (feature === \"mouse-events\") {\r\n            // The device supports mouse events and the Reading System passes mouse events to the content.\r\n            return true;\r\n        }\r\n        if (feature === \"keyboard-events\") {\r\n            // The device supports keyboard events and the Reading System passes keyboard events to the content.\r\n            return true;\r\n        }\r\n\r\n        if (feature === \"spine-scripting\") {\r\n            //Spine-level scripting is supported.\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n};\n",
    "(function (exports) {'use strict';\n  //shared pointer\n  var i;\n  //shortcuts\n  var defineProperty = Object.defineProperty, is = function(a,b) { return (a === b) || (a !== a && b !== b) };\n\n\n  //Polyfill global objects\n  if (typeof WeakMap == 'undefined') {\n    exports.WeakMap = createCollection({\n      // WeakMap#delete(key:void*):boolean\n      'delete': sharedDelete,\n      // WeakMap#clear():\n      clear: sharedClear,\n      // WeakMap#get(key:void*):void*\n      get: sharedGet,\n      // WeakMap#has(key:void*):boolean\n      has: mapHas,\n      // WeakMap#set(key:void*, value:void*):void\n      set: sharedSet\n    }, true);\n  }\n\n  if (typeof Map == 'undefined' || typeof ((new Map).values) !== 'function' || !(new Map).values().next) {\n    exports.Map = createCollection({\n      // WeakMap#delete(key:void*):boolean\n      'delete': sharedDelete,\n      //:was Map#get(key:void*[, d3fault:void*]):void*\n      // Map#has(key:void*):boolean\n      has: mapHas,\n      // Map#get(key:void*):boolean\n      get: sharedGet,\n      // Map#set(key:void*, value:void*):void\n      set: sharedSet,\n      // Map#keys(void):Iterator\n      keys: sharedKeys,\n      // Map#values(void):Iterator\n      values: sharedValues,\n      // Map#entries(void):Iterator\n      entries: mapEntries,\n      // Map#forEach(callback:Function, context:void*):void ==> callback.call(context, key, value, mapObject) === not in specs`\n      forEach: sharedForEach,\n      // Map#clear():\n      clear: sharedClear\n    });\n  }\n\n  if (typeof Set == 'undefined' || typeof ((new Set).values) !== 'function' || !(new Set).values().next) {\n    exports.Set = createCollection({\n      // Set#has(value:void*):boolean\n      has: setHas,\n      // Set#add(value:void*):boolean\n      add: sharedAdd,\n      // Set#delete(key:void*):boolean\n      'delete': sharedDelete,\n      // Set#clear():\n      clear: sharedClear,\n      // Set#keys(void):Iterator\n      keys: sharedValues, // specs actually say \"the same function object as the initial value of the values property\"\n      // Set#values(void):Iterator\n      values: sharedValues,\n      // Set#entries(void):Iterator\n      entries: setEntries,\n      // Set#forEach(callback:Function, context:void*):void ==> callback.call(context, value, index) === not in specs\n      forEach: sharedForEach\n    });\n  }\n\n  if (typeof WeakSet == 'undefined') {\n    exports.WeakSet = createCollection({\n      // WeakSet#delete(key:void*):boolean\n      'delete': sharedDelete,\n      // WeakSet#add(value:void*):boolean\n      add: sharedAdd,\n      // WeakSet#clear():\n      clear: sharedClear,\n      // WeakSet#has(value:void*):boolean\n      has: setHas\n    }, true);\n  }\n\n\n  /**\n   * ES6 collection constructor\n   * @return {Function} a collection class\n   */\n  function createCollection(proto, objectOnly){\n    function Collection(a){\n      if (!this || this.constructor !== Collection) return new Collection(a);\n      this._keys = [];\n      this._values = [];\n      this._itp = []; // iteration pointers\n      this.objectOnly = objectOnly;\n\n      //parse initial iterable argument passed\n      if (a) init.call(this, a);\n    }\n\n    //define size for non object-only collections\n    if (!objectOnly) {\n      defineProperty(proto, 'size', {\n        get: sharedSize\n      });\n    }\n\n    //set prototype\n    proto.constructor = Collection;\n    Collection.prototype = proto;\n\n    return Collection;\n  }\n\n\n  /** parse initial iterable argument passed */\n  function init(a){\n    var i;\n    //init Set argument, like `[1,2,3,{}]`\n    if (this.add)\n      a.forEach(this.add, this);\n    //init Map argument like `[[1,2], [{}, 4]]`\n    else\n      a.forEach(function(a){this.set(a[0],a[1])}, this);\n  }\n\n\n  /** delete */\n  function sharedDelete(key) {\n    if (this.has(key)) {\n      this._keys.splice(i, 1);\n      this._values.splice(i, 1);\n      // update iteration pointers\n      this._itp.forEach(function(p) { if (i < p[0]) p[0]--; });\n    }\n    // Aurora here does it while Canary doesn't\n    return -1 < i;\n  };\n\n  function sharedGet(key) {\n    return this.has(key) ? this._values[i] : undefined;\n  }\n\n  function has(list, key) {\n    if (this.objectOnly && key !== Object(key))\n      throw new TypeError(\"Invalid value used as weak collection key\");\n    //NaN or 0 passed\n    if (key != key || key === 0) for (i = list.length; i-- && !is(list[i], key);){}\n    else i = list.indexOf(key);\n    return -1 < i;\n  }\n\n  function setHas(value) {\n    return has.call(this, this._values, value);\n  }\n\n  function mapHas(value) {\n    return has.call(this, this._keys, value);\n  }\n\n  /** @chainable */\n  function sharedSet(key, value) {\n    this.has(key) ?\n      this._values[i] = value\n      :\n      this._values[this._keys.push(key) - 1] = value\n    ;\n    return this;\n  }\n\n  /** @chainable */\n  function sharedAdd(value) {\n    if (!this.has(value)) this._values.push(value);\n    return this;\n  }\n\n  function sharedClear() {\n    (this._keys || 0).length =\n    this._values.length = 0;\n  }\n\n  /** keys, values, and iterate related methods */\n  function sharedKeys() {\n    return sharedIterator(this._itp, this._keys);\n  }\n\n  function sharedValues() {\n    return sharedIterator(this._itp, this._values);\n  }\n\n  function mapEntries() {\n    return sharedIterator(this._itp, this._keys, this._values);\n  }\n\n  function setEntries() {\n    return sharedIterator(this._itp, this._values, this._values);\n  }\n\n  function sharedIterator(itp, array, array2) {\n    var p = [0], done = false;\n    itp.push(p);\n    return {\n      next: function() {\n        var v, k = p[0];\n        if (!done && k < array.length) {\n          v = array2 ? [array[k], array2[k]]: array[k];\n          p[0]++;\n        } else {\n          done = true;\n          itp.splice(itp.indexOf(p), 1);\n        }\n        return { done: done, value: v };\n      }\n    };\n  }\n\n  function sharedSize() {\n    return this._values.length;\n  }\n\n  function sharedForEach(callback, context) {\n    var it = this.entries();\n    for (;;) {\n      var r = it.next();\n      if (r.done) break;\n      callback.call(context, r.value[1], r.value[0], this);\n    }\n  }\n\n})(typeof exports != 'undefined' && typeof global != 'undefined' ? global : window );\n\ndefine(\"es6-collections\", function(){});\n\n",
    "//\r\n//  Created by Juan Corona\r\n//  Based on original proposal by Mickaël Menu\r\n//  Portions adapted from Rangy's Module system: Copyright (c) 2014 Tim Down\r\n//\r\n//  Copyright (c) 2014 Readium Foundation and/or its licensees. All rights reserved.\r\n//\r\n//  Redistribution and use in source and binary forms, with or without modification,\r\n//  are permitted provided that the following conditions are met:\r\n//  1. Redistributions of source code must retain the above copyright notice, this\r\n//  list of conditions and the following disclaimer.\r\n//  2. Redistributions in binary form must reproduce the above copyright notice,\r\n//  this list of conditions and the following disclaimer in the documentation and/or\r\n//  other materials provided with the distribution.\r\n//  3. Neither the name of the organization nor the names of its contributors may be\r\n//  used to endorse or promote products derived from this software without specific\r\n//  prior written permission.\r\n//\r\n//  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\r\n//  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n//  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\r\n//  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\r\n//  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\r\n//  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\r\n//  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\r\n//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE\r\n//  OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\r\n//  OF THE POSSIBILITY OF SUCH DAMAGE.\r\n\r\ndefine('readium_js_plugins',[\"jquery\", \"underscore\", \"eventEmitter\"], function ($, _, EventEmitter) {\r\n\r\n    var _registeredPlugins = {};\r\n\r\n    /**\r\n     * A  plugins controller used to easily add plugins from the host app, eg.\r\n     * ReadiumSDK.Plugins.register(\"footnotes\", function(api){ ... });\r\n     *\r\n     * @constructor\r\n     */\r\n    var PluginsController = function () {\r\n        var self = this;\r\n\r\n\r\n        this.initialize = function (reader) {\r\n            var apiFactory = new PluginApiFactory(reader);\r\n\r\n            if (!reader.plugins) {\r\n                //attach an object to the reader that will be\r\n                // used for plugin namespaces and their extensions\r\n                reader.plugins = {};\r\n            } else {\r\n                throw new Error(\"Already initialized on reader!\");\r\n            }\r\n            _.each(_registeredPlugins, function (plugin) {\r\n                plugin.init(apiFactory);\r\n            });\r\n        };\r\n\r\n        this.getLoadedPlugins = function() {\r\n            return _registeredPlugins;\r\n        };\r\n\r\n        // Creates a new instance of the given plugin constructor.\r\n        this.register = function (name, optDependencies, initFunc) {\r\n\r\n            if (_registeredPlugins[name]) {\r\n                throw new Error(\"Duplicate registration for plugin with name: \" + name);\r\n            }\r\n\r\n            var dependencies;\r\n            if (typeof optDependencies === 'function') {\r\n                initFunc = optDependencies;\r\n            } else {\r\n                dependencies = optDependencies;\r\n            }\r\n\r\n            _registeredPlugins[name] = new Plugin(name, dependencies, function(plugin, api) {\r\n                if (!plugin.initialized || !api.host.plugins[plugin.name]) {\r\n                    plugin.initialized = true;\r\n                    try {\r\n                        var pluginContext = {};\r\n                        $.extend(pluginContext, new EventEmitter());\r\n\r\n                        initFunc.call(pluginContext, api.instance);\r\n                        plugin.supported = true;\r\n\r\n                        api.host.plugins[plugin.name] = pluginContext;\r\n                    } catch (ex) {\r\n                        plugin.fail(ex);\r\n                    }\r\n                }\r\n            });\r\n        };\r\n    };\r\n\r\n    function PluginApi(reader, plugin) {\r\n        this.reader = reader;\r\n        this.plugin = plugin;\r\n    }\r\n\r\n    function PluginApiFactory(reader) {\r\n        this.create = function (plugin) {\r\n            return {\r\n                host: reader,\r\n                instance: new PluginApi(reader, plugin)\r\n            };\r\n        };\r\n    }\r\n\r\n//\r\n//  The following is adapted from Rangy's Module class:\r\n//\r\n//  Copyright (c) 2014 Tim Down\r\n//\r\n//  The MIT License (MIT)\r\n//  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n//  of this software and associated documentation files (the \"Software\"), to deal\r\n//  in the Software without restriction, including without limitation the rights\r\n//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n//  copies of the Software, and to permit persons to whom the Software is\r\n//  furnished to do so, subject to the following conditions:\r\n//\r\n//  The above copyright notice and this permission notice shall be included in all\r\n//  copies or substantial portions of the Software.\r\n//\r\n//  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n//  SOFTWARE.\r\n\r\n    function Plugin(name, dependencies, initializer) {\r\n        this.name = name;\r\n        this.dependencies = dependencies;\r\n        this.initialized = false;\r\n        this.supported = false;\r\n        this.initializer = initializer;\r\n    }\r\n\r\n    Plugin.prototype = {\r\n        init: function (apiFactory) {\r\n            var requiredPluginNames = this.dependencies || [];\r\n            for (var i = 0, len = requiredPluginNames.length, requiredPlugin, PluginName; i < len; ++i) {\r\n                PluginName = requiredPluginNames[i];\r\n\r\n                requiredPlugin = _registeredPlugins[PluginName];\r\n                if (!requiredPlugin || !(requiredPlugin instanceof Plugin)) {\r\n                    throw new Error(\"required Plugin '\" + PluginName + \"' not found\");\r\n                }\r\n\r\n                requiredPlugin.init(apiFactory);\r\n\r\n                if (!requiredPlugin.supported) {\r\n                    throw new Error(\"required Plugin '\" + PluginName + \"' not supported\");\r\n                }\r\n            }\r\n\r\n            // Now run initializer\r\n            this.initializer(this, apiFactory.create(this));\r\n        },\r\n\r\n        fail: function (reason) {\r\n            this.initialized = true;\r\n            this.supported = false;\r\n            throw new Error(\"Plugin '\" + this.name + \"' failed to load: \" + reason);\r\n        },\r\n\r\n        warn: function (msg) {\r\n            console.warn(\"Plugin \" + this.name + \": \" + msg);\r\n        },\r\n\r\n        deprecationNotice: function (deprecated, replacement) {\r\n            console.warn(\"DEPRECATED: \" + deprecated + \" in Plugin \" + this.name + \"is deprecated. Please use \"\r\n            + replacement + \" instead\");\r\n        },\r\n\r\n        createError: function (msg) {\r\n            return new Error(\"Error in \" + this.name + \" Plugin: \" + msg);\r\n        }\r\n    };\r\n\r\n    var instance = new PluginsController();\r\n    return instance;\r\n});\r\n\n",
    "//  Copyright (c) 2014 Readium Foundation and/or its licensees. All rights reserved.\r\n//\r\n//  Redistribution and use in source and binary forms, with or without modification,\r\n//  are permitted provided that the following conditions are met:\r\n//  1. Redistributions of source code must retain the above copyright notice, this\r\n//  list of conditions and the following disclaimer.\r\n//  2. Redistributions in binary form must reproduce the above copyright notice,\r\n//  this list of conditions and the following disclaimer in the documentation and/or\r\n//  other materials provided with the distribution.\r\n//  3. Neither the name of the organization nor the names of its contributors may be\r\n//  used to endorse or promote products derived from this software without specific\r\n//  prior written permission.\r\n\r\n//'text!empty:'\r\ndefine('readium_shared_js/globalsSetup',['./globals', 'jquery', 'console_shim', 'es6-collections', 'eventEmitter', 'URIjs', 'readium_cfi_js', 'readium_js_plugins'], function (Globals, $, console_shim, es6collections, EventEmitter, URI, epubCfi, PluginsController) {\r\n\r\n    console.log(\"Globals...\");\r\n\r\n    if (window[\"ReadiumSDK\"]) {\r\n        console.log(\"ReadiumSDK extend.\");\r\n        $.extend(Globals, window.ReadiumSDK);\r\n    } else {\r\n        console.log(\"ReadiumSDK set.\");\r\n    }\r\n\r\n    window.ReadiumSDK = Globals;\r\n\r\n    // TODO: refactor client code to use emit instead of trigger?\r\n    EventEmitter.prototype.trigger = EventEmitter.prototype.emit;\r\n\r\n    // TODO pass as dependency injection define() function parameter, not window global!\r\n    window.EventEmitter = EventEmitter;\r\n\r\n    // TODO pass as dependency injection define() function parameter, not window global!\r\n    window.URI = URI;\r\n\r\n    // window.URL accessor to window.webkitURL (Safari 6 support)\r\n    if ('URL' in window === false) {\r\n        if ('webkitURL' in window === false) {\r\n            throw Error('Browser does not support window.URL');\r\n        }\r\n\r\n        window.URL = window.webkitURL;\r\n    }\r\n    // Plugins bootstrapping begins\r\n    Globals.Plugins = PluginsController;\r\n    Globals.on(Globals.Events.READER_INITIALIZED, function(reader) {\r\n        \r\n        Globals.logEvent(\"READER_INITIALIZED\", \"ON\", \"globalsSetup.js\");\r\n        \r\n        try {\r\n            PluginsController.initialize(reader);\r\n        } catch (ex) {\r\n            console.error(\"Plugins failed to initialize:\", ex);\r\n        }\r\n\r\n        _.defer(function() {\r\n            Globals.logEvent(\"PLUGINS_LOADED\", \"EMIT\", \"globalsSetup.js\");\r\n            Globals.emit(Globals.Events.PLUGINS_LOADED, reader);\r\n        });\r\n    });\r\n\r\n    if (window._RJS_isBrowser) {\r\n        // If under a browser env and using RequireJS, dynamically require all plugins\r\n        var pluginsList = window._RJS_pluginsList;\r\n        console.log(\"Plugins included: \", pluginsList.map(function(v) {\r\n            // To stay consistent with bundled output\r\n            return v.replace('readium_plugin_', '');\r\n        }));\r\n\r\n        require(pluginsList);\r\n    } else {\r\n        // Else list which plugins were included when using almond and bundle(s)\r\n        setTimeout(function() {\r\n            // Assume that in the next callback all the plugins have been registered\r\n            var pluginsList = Object.keys(PluginsController.getLoadedPlugins());\r\n            console.log(\"Plugins included: \", pluginsList);\r\n        }, 0);\r\n    }\r\n    // Plugins bootstrapping ends\r\n});\r\n\ndefine('readium_shared_js', ['readium_shared_js/globalsSetup'], function (main) { return main; });\n\n",
    "//  Created by Boris Schneiderman.\r\n//  Copyright (c) 2014 Readium Foundation and/or its licensees. All rights reserved.\r\n//  \r\n//  Redistribution and use in source and binary forms, with or without modification, \r\n//  are permitted provided that the following conditions are met:\r\n//  1. Redistributions of source code must retain the above copyright notice, this \r\n//  list of conditions and the following disclaimer.\r\n//  2. Redistributions in binary form must reproduce the above copyright notice, \r\n//  this list of conditions and the following disclaimer in the documentation and/or \r\n//  other materials provided with the distribution.\r\n//  3. Neither the name of the organization nor the names of its contributors may be \r\n//  used to endorse or promote products derived from this software without specific \r\n//  prior written permission.\r\n//  \r\n//  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND \r\n//  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED \r\n//  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. \r\n//  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, \r\n//  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, \r\n//  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, \r\n//  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF \r\n//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE \r\n//  OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED \r\n//  OF THE POSSIBILITY OF SUCH DAMAGE.\r\n\r\ndefine('readium_shared_js/models/bookmark_data',[],function() {\r\n/**\r\n * @class Models.BookmarkData\r\n */\r\nvar BookmarkData = function(idref, contentCFI) {\r\n\r\n    var self = this;\r\n\r\n    /**\r\n     * spine item idref\r\n     * @property idref\r\n     * @type {string}\r\n     */\r\n\r\n    this.idref = idref;\r\n\r\n    /**\r\n     * cfi of the first visible element\r\n     * @property contentCFI\r\n     * @type {string}\r\n     */\r\n    \r\n    this.contentCFI = contentCFI;\r\n\r\n    /**\r\n     * serialize to string\r\n     * @return JSON string representation\r\n     */\r\n    \r\n    this.toString = function(){\r\n        return JSON.stringify(self);\r\n    }\r\n\r\n};\r\n\r\n/**\r\n * Deserialize from string\r\n * @param str\r\n * @returns {ReadiumSDK.Models.BookmarkData}\r\n */\r\nBookmarkData.fromString = function(str) {\r\n    var obj = JSON.parse(str);\r\n    return new BookmarkData(obj.idref,obj.contentCFI);\r\n};\r\nreturn BookmarkData;\r\n});\n",
    "//  Created by Boris Schneiderman.\r\n//  Copyright (c) 2014 Readium Foundation and/or its licensees. All rights reserved.\r\n//  \r\n//  Redistribution and use in source and binary forms, with or without modification, \r\n//  are permitted provided that the following conditions are met:\r\n//  1. Redistributions of source code must retain the above copyright notice, this \r\n//  list of conditions and the following disclaimer.\r\n//  2. Redistributions in binary form must reproduce the above copyright notice, \r\n//  this list of conditions and the following disclaimer in the documentation and/or \r\n//  other materials provided with the distribution.\r\n//  3. Neither the name of the organization nor the names of its contributors may be \r\n//  used to endorse or promote products derived from this software without specific \r\n//  prior written permission.\r\n//  \r\n//  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND \r\n//  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED \r\n//  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. \r\n//  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, \r\n//  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, \r\n//  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, \r\n//  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF \r\n//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE \r\n//  OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED \r\n//  OF THE POSSIBILITY OF SUCH DAMAGE.\r\n\r\ndefine('readium_shared_js/models/current_pages_info',[],function() {\r\n\r\n/**\r\n * Used to report pagination state back to the host application\r\n *\r\n * @class Models.CurrentPagesInfo\r\n *\r\n * @constructor\r\n *\r\n * @param {Models.Spine} spine\r\n * @param {boolean} isFixedLayout is fixed or reflowable spine item\r\n * @return CurrentPagesInfo\r\n*/\r\n\r\nvar CurrentPagesInfo = function(spine, isFixedLayout) {\r\n\r\n\r\n    /**\r\n     * The reading direction\r\n     *\r\n     * @property isRightToLeft\r\n     * @type bool\r\n     */\r\n\r\n    this.isRightToLeft = spine.isRightToLeft();\r\n    \r\n    /**\r\n     * Is the ebook fixed layout or not?\r\n     *\r\n     * @property isFixedLayout\r\n     * @type bool\r\n     */\r\n\r\n    this.isFixedLayout = isFixedLayout;\r\n    \r\n    /**\r\n     * Counts the number of spine items\r\n     *\r\n     * @property spineItemCount\r\n     * @type number\r\n     */    \r\n\r\n    this.spineItemCount = spine.items.length\r\n    \r\n    /**\r\n     * returns an array of open pages, each array item is a data structure (plain JavaScript object) with the following fields: spineItemPageIndex, spineItemPageCount, idref, spineItemIndex (as per the parameters of the addOpenPage() function below)\r\n     *\r\n     * @property openPages\r\n     * @type array\r\n     */\r\n\r\n    this.openPages = [];\r\n\r\n    /**\r\n     * Adds an page item to the openPages array\r\n     *\r\n     * @method     addOpenPage\r\n     * @param      {number} spineItemPageIndex\r\n     * @param      {number} spineItemPageCount\r\n     * @param      {string} idref\r\n     * @param      {number} spineItemIndex   \r\n     */\r\n\r\n    this.addOpenPage = function(spineItemPageIndex, spineItemPageCount, idref, spineItemIndex) {\r\n        this.openPages.push({spineItemPageIndex: spineItemPageIndex, spineItemPageCount: spineItemPageCount, idref: idref, spineItemIndex: spineItemIndex});\r\n\r\n        this.sort();\r\n    };\r\n\r\n    /**\r\n     * Checks if navigation to the page on the left is possible (depending on page-progression-direction: previous page in LTR mode, next page in RTL mode)\r\n     *\r\n     * @method     canGoLeft\r\n     * @return bool true if turning to the left page is possible \r\n     */\r\n\r\n    this.canGoLeft = function () {\r\n        return this.isRightToLeft ? this.canGoNext() : this.canGoPrev();\r\n    };\r\n\r\n    /**\r\n     * Checks if navigation to the page on the right is possible (depending on page-progression-direction: next page in LTR mode, previous page in RTL mode)\r\n     *\r\n     * @method     canGoRight\r\n     * @return bool true if turning to the right page is possible \r\n     */\r\n\r\n    this.canGoRight = function () {\r\n        return this.isRightToLeft ? this.canGoPrev() : this.canGoNext();\r\n    };\r\n\r\n    /**\r\n     * Checks if navigation to the next page is possible (depending on page-progression-direction: right page in LTR mode, left page in RTL mode)\r\n     *\r\n     * @method     canGoNext\r\n     * @return bool true if turning to the next page is possible \r\n     */\r\n\r\n    this.canGoNext = function() {\r\n\r\n        if(this.openPages.length == 0)\r\n            return false;\r\n\r\n        var lastOpenPage = this.openPages[this.openPages.length - 1];\r\n\r\n        // TODO: handling of non-linear spine items (\"ancillary\" documents), allowing page turn within the reflowable XHTML, but preventing previous/next access to sibling spine items. Also needs \"go back\" feature to navigate to source hyperlink location that led to the non-linear document.\r\n        // See https://github.com/readium/readium-shared-js/issues/26\r\n\r\n        // Removed, needs to be implemented properly as per above.\r\n        // See https://github.com/readium/readium-shared-js/issues/108\r\n        // if(!spine.isValidLinearItem(lastOpenPage.spineItemIndex))\r\n        //     return false;\r\n\r\n        return lastOpenPage.spineItemIndex < spine.last().index || lastOpenPage.spineItemPageIndex < lastOpenPage.spineItemPageCount - 1;\r\n    };\r\n\r\n    /**\r\n     * Checks if navigation to the previous page is possible (depending on page-progression-direction: left page in LTR mode, right page in RTL mode)\r\n     *\r\n     * @method     canGoPrev\r\n     * @return bool true if turning to the previous page is possible \r\n     */\r\n\r\n    this.canGoPrev = function() {\r\n\r\n        if(this.openPages.length == 0)\r\n            return false;\r\n\r\n        var firstOpenPage = this.openPages[0];\r\n\r\n        // TODO: handling of non-linear spine items (\"ancillary\" documents), allowing page turn within the reflowable XHTML, but preventing previous/next access to sibling spine items. Also needs \"go back\" feature to navigate to source hyperlink location that led to the non-linear document.\r\n        // See https://github.com/readium/readium-shared-js/issues/26\r\n\r\n        // Removed, needs to be implemented properly as per above.\r\n        // //https://github.com/readium/readium-shared-js/issues/108\r\n        // if(!spine.isValidLinearItem(firstOpenPage.spineItemIndex))\r\n        //     return false;\r\n\r\n        return spine.first().index < firstOpenPage.spineItemIndex || 0 < firstOpenPage.spineItemPageIndex;\r\n    };\r\n\r\n    /**\r\n     * Sorts the openPages array based on spineItemIndex and spineItemPageIndex\r\n     *\r\n     * @method     sort\r\n     */\r\n\r\n    this.sort = function() {\r\n\r\n        this.openPages.sort(function(a, b) {\r\n\r\n            if(a.spineItemIndex != b.spineItemIndex) {\r\n                return a.spineItemIndex - b.spineItemIndex;\r\n            }\r\n\r\n            return a.spineItemPageIndex - b.spineItemPageIndex;\r\n\r\n        });\r\n\r\n    };\r\n\r\n};\r\n\r\nreturn CurrentPagesInfo;\r\n});\n",
    "  //  Created by Boris Schneiderman.\r\n//  Copyright (c) 2014 Readium Foundation and/or its licensees. All rights reserved.\r\n//  \r\n//  Redistribution and use in source and binary forms, with or without modification, \r\n//  are permitted provided that the following conditions are met:\r\n//  1. Redistributions of source code must retain the above copyright notice, this \r\n//  list of conditions and the following disclaimer.\r\n//  2. Redistributions in binary form must reproduce the above copyright notice, \r\n//  this list of conditions and the following disclaimer in the documentation and/or \r\n//  other materials provided with the distribution.\r\n//  3. Neither the name of the organization nor the names of its contributors may be \r\n//  used to endorse or promote products derived from this software without specific \r\n//  prior written permission.\r\n//  \r\n//  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND \r\n//  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED \r\n//  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. \r\n//  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, \r\n//  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, \r\n//  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, \r\n//  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF \r\n//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE \r\n//  OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED \r\n//  OF THE POSSIBILITY OF SUCH DAMAGE.\r\n\r\ndefine('readium_shared_js/models/fixed_page_spread',[],function() {\r\n/**\r\n * Spread the page \r\n *\r\n * @class  Models.Spread\r\n * @constructor\r\n * @param spine \r\n * @param {Boolean} isSyntheticSpread \r\n *\r\n */\r\nvar Spread = function(spine, isSyntheticSpread) {\r\n\r\n    var self = this;\r\n\r\n    this.spine = spine;\r\n    \r\n    this.leftItem = undefined;\r\n    this.rightItem = undefined;\r\n    this.centerItem = undefined;\r\n\r\n    var _isSyntheticSpread = isSyntheticSpread;\r\n\r\n    /**\r\n     * Sets whether or not this is a synthetic spread\r\n     *\r\n     * @method     setSyntheticSpread\r\n     * @param      {Bool} isSyntheticSpread\r\n     */\r\n\r\n    this.setSyntheticSpread = function(isSyntheticSpread) {\r\n        _isSyntheticSpread = isSyntheticSpread;\r\n    };\r\n\r\n    /**\r\n     * Checks out if the spread is synthetic\r\n     *\r\n     * @method     isSyntheticSpread\r\n     * @return     {Bool} true if this is a 2-page synthetic spread\r\n     */\r\n\r\n    this.isSyntheticSpread = function() {\r\n        return _isSyntheticSpread;\r\n    };\r\n\r\n    /**\r\n     * Opens the first spine item (FXL page)\r\n     *\r\n     * @method     openFirst\r\n     */\r\n\r\n    this.openFirst = function() {\r\n\r\n        if( this.spine.items.length == 0 ) {\r\n            resetItems();\r\n        }\r\n        else {\r\n            this.openItem(this.spine.first());\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Opens the last spine item (FXL page)\r\n     *\r\n     * @method     openLast\r\n     */\r\n\r\n    this.openLast = function() {\r\n\r\n        if( this.spine.items.length == 0 ) {\r\n            resetItems();\r\n        }\r\n        else {\r\n            this.openItem(this.spine.last());\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Opens a spine item (FXL page)\r\n     *\r\n     * @method     openItem\r\n     * @param      {Models.SpineItem} item\r\n     */\r\n\r\n    this.openItem = function(item) {\r\n\r\n        resetItems();\r\n\r\n        var position = getItemPosition(item);\r\n        setItemToPosition(item, position);\r\n\r\n        if(position != Spread.POSITION_CENTER && this.spine.isValidLinearItem(item.index)) { // && item.isRenditionSpreadAllowed() not necessary, see getItemPosition() below\r\n            var neighbour = getNeighbourItem(item);\r\n            if(neighbour) {\r\n                var neighbourPos = getItemPosition(neighbour);\r\n                if(neighbourPos != position\r\n                    && neighbourPos != Spread.POSITION_CENTER\r\n                    && !neighbour.isReflowable()\r\n                    && neighbour.isRenditionSpreadAllowed())  {\r\n                    setItemToPosition(neighbour, neighbourPos);\r\n                }\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Resets the spine items (FXL pages, left + right + center) to undefined\r\n     *\r\n     * @method     resetItems\r\n     */\r\n\r\n    function resetItems() {\r\n\r\n        self.leftItem = undefined;\r\n        self.rightItem = undefined;\r\n        self.centerItem = undefined;\r\n    }\r\n\r\n    /**\r\n     * Sets the spine item (FXL page) to a position (left, right or center)\r\n     *\r\n     * @method     setItemToPosition\r\n     * @param      {Models.SpineItem} item\r\n     * @param      {Spread.POSITION_CENTER | Spread.POSITION_LEFT | Spread.POSITION_RIGHT} position\r\n     */\r\n\r\n    function setItemToPosition(item, position) {\r\n\r\n        if(position == Spread.POSITION_LEFT) {\r\n            self.leftItem = item;\r\n        }\r\n        else if (position == Spread.POSITION_RIGHT) {\r\n            self.rightItem = item;\r\n        }\r\n        else {\r\n\r\n            if(position != Spread.POSITION_CENTER) {\r\n                console.error(\"Unrecognized position value\");\r\n            }\r\n\r\n            self.centerItem = item;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the position of a spine item / FXL page (left, center or right)\r\n     *\r\n     * @method     getItemPosition\r\n     * @param      {Models.SpineItem} item\r\n     * @return     {Spread.POSITION_CENTER | Spread.POSITION_LEFT | Spread.POSITION_RIGHT}\r\n     */\r\n\r\n    function getItemPosition(item) {\r\n        \r\n        // includes !item.isRenditionSpreadAllowed() (\"rendition:spread-none\") ==> force center position\r\n        if(!_isSyntheticSpread) {\r\n            return Spread.POSITION_CENTER;\r\n        }\r\n\r\n        if(item.isLeftPage()) {\r\n            return Spread.POSITION_LEFT;\r\n        }\r\n\r\n        if (item.isRightPage()) {\r\n            return Spread.POSITION_RIGHT;\r\n        }\r\n\r\n        return Spread.POSITION_CENTER;\r\n    }\r\n\r\n    /**\r\n     * Opens the next item\r\n     *\r\n     * @method     openNext\r\n     */ \r\n\r\n    this.openNext = function() {\r\n\r\n        var items = this.validItems();\r\n\r\n        if(items.length == 0) {\r\n\r\n            this.openFirst();\r\n        }\r\n        else {\r\n\r\n            var nextItem = this.spine.nextItem(items[items.length - 1]);\r\n            if(nextItem) {\r\n\r\n                this.openItem(nextItem);\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Opens the previous item\r\n     *\r\n     * @method     openPrev\r\n     */ \r\n\r\n    this.openPrev = function() {\r\n\r\n        var items = this.validItems();\r\n\r\n        if(items.length == 0) {\r\n            this.openLast();\r\n        }\r\n        else {\r\n\r\n            var prevItem = this.spine.prevItem(items[0]);\r\n            if(prevItem) {\r\n\r\n                this.openItem(prevItem);\r\n\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Returns an sorrted array of spine items (as per their order in the spine) that are currently in the FXL page layout\r\n     *\r\n     * @method     validItems\r\n     * @return     {array} \r\n     */ \r\n\r\n    this.validItems = function() {\r\n\r\n        var arr = [];\r\n\r\n        if(this.leftItem) arr.push(this.leftItem);\r\n        if(this.rightItem) arr.push(this.rightItem);\r\n        if(this.centerItem) arr.push(this.centerItem);\r\n\r\n        arr.sort(function(a, b) {\r\n            return a.index - b.index;\r\n        });\r\n\r\n        return arr;\r\n    };\r\n\r\n    /**\r\n     * Gets the neighbour spine item in the FXL page layout (on left or right of the current item)\r\n     *\r\n     * @method     getNeighbourItem\r\n     * @param      {Models.SpineItem} item\r\n     * @return     {Models.SpineItem} item\r\n     */ \r\n\r\n    function getNeighbourItem(item) {\r\n\r\n        if(item.isLeftPage()) {\r\n            return self.spine.isRightToLeft() ? self.spine.prevItem(item) : self.spine.nextItem(item);\r\n        }\r\n\r\n        if(item.isRightPage()) {\r\n            return self.spine.isRightToLeft() ? self.spine.nextItem(item) : self.spine.prevItem(item);\r\n        }\r\n\r\n        return undefined;\r\n    }\r\n\r\n};\r\n\r\nSpread.POSITION_LEFT = \"left\";\r\nSpread.POSITION_RIGHT = \"right\";\r\nSpread.POSITION_CENTER = \"center\";\r\n\r\nreturn Spread;\r\n});\n",
    "//  Created by Boris Schneiderman.\r\n//  Copyright (c) 2016 Readium Foundation and/or its licensees. All rights reserved.\r\n//  \r\n//  Redistribution and use in source and binary forms, with or without modification, \r\n//  are permitted provided that the following conditions are met:\r\n//  1. Redistributions of source code must retain the above copyright notice, this \r\n//  list of conditions and the following disclaimer.\r\n//  2. Redistributions in binary form must reproduce the above copyright notice, \r\n//  this list of conditions and the following disclaimer in the documentation and/or \r\n//  other materials provided with the distribution.\r\n//  3. Neither the name of the organization nor the names of its contributors may be \r\n//  used to endorse or promote products derived from this software without specific \r\n//  prior written permission.\r\n//  \r\n//  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND \r\n//  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED \r\n//  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. \r\n//  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, \r\n//  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, \r\n//  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, \r\n//  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF \r\n//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE \r\n//  OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED \r\n//  OF THE POSSIBILITY OF SUCH DAMAGE.\r\n\r\ndefine('readium_shared_js/models/spine_item',[], function() {\r\n\r\n/**\r\n * Wrapper of the SpineItem object received from the host application\r\n *\r\n * @class  Models.SpineItem\r\n * @constructor\r\n * @param itemData container for spine item properties\r\n * @param {Number} index index of this spine item in the parent spine \r\n * @param {Models.Spine} spine parent spine\r\n *\r\n */\r\nvar SpineItem = function(itemData, index, spine){\r\n\r\n    var self = this;\r\n\r\n    /**\r\n     * The idref of the spine item, i.e. the ID-based pointer to the actual \r\n     * manifest item that the spine item references\r\n     *\r\n     * @property idref\r\n     * @type String\r\n     * @default  None\r\n     */\r\n    this.idref = itemData.idref;\r\n\r\n    /**\r\n     * The href of the spine item, i.e. the URI to the resource in the EPUB\r\n     * which the spineitem will render\r\n     *\r\n     * @property href\r\n     * @type String\r\n     * @default  None\r\n     */\r\n    this.href = itemData.href;\r\n\r\n    /**\r\n     * A flag indicating whether the spineItem has the attribute linear, which \r\n     * is either yes or no.  Default is yes.\r\n     *\r\n     * @property linear\r\n     * @type String\r\n     * @default  yes\r\n     */\r\n    this.linear = itemData.linear ? itemData.linear.toLowerCase() : itemData.linear;\r\n\r\n    /**\r\n     * A variable indicating the type of synthetic spread for this specific\r\n     * spine item, where page:spread-* can be left, right or center or auto\r\n     *\r\n     * @property page_spread\r\n     * @type String\r\n     * @default  auto\r\n     */\r\n    this.page_spread = itemData.page_spread;\r\n    \r\n    /**\r\n     * A string specifying the height and width from the rendition:viewport tag.\r\n     * Note: This is deprecated in EPUB 3.1\r\n     *\r\n     * @property rendition_viewport\r\n     * @type     String\r\n     * @default  None\r\n     */\r\n    this.rendition_viewport = itemData.rendition_viewport;\r\n    \r\n    /**\r\n     * A string specifying the type of synthetic spread for ALL spine items, where\r\n     * where rendtion:spread-* can be left, right or center or auto\r\n     *\r\n     * @property rendition_spread\r\n     * @type     String\r\n     * @default  auto\r\n     */\r\n    this.rendition_spread = itemData.rendition_spread;\r\n\r\n    /**\r\n     * A string specifying desired orientation for ALL spine items. Possible values are\r\n     * rendition-orientation-*, which can be none, landscape, portrait, both or auto\r\n     *\r\n     * Note: Not yet implemented.\r\n     *\r\n     * @property rendition_orientation\r\n     * @type     String\r\n     * @default  auto\r\n     */\r\n    this.rendition_orientation = itemData.rendition_orientation;\r\n\r\n    /**\r\n     * A string indicating the type of document layout, either prepaginated or reflowable\r\n     *\r\n     * @property rendition_layout\r\n     * @type     String\r\n     * @default  reflowable\r\n     */\r\n    this.rendition_layout = itemData.rendition_layout;\r\n    \r\n    /**\r\n     * A string specifying how \"overflow\" content that exceeds the current viewport should\r\n     * be laid out.  Possible values are paginated, scrolled-continuous, scrolled-doc or auto\r\n     *\r\n     * @property rendition_flow\r\n     * @type     String\r\n     * @default  auto\r\n     */\r\n    this.rendition_flow = itemData.rendition_flow;\r\n    \r\n    /**\r\n     * The ID, if any, of the root SMIL element of the media overlay for the document.\r\n     *\r\n     * @property media_overlay_id\r\n     * @type     String\r\n     * @default  None\r\n     */\r\n    this.media_overlay_id = itemData.media_overlay_id;\r\n\r\n    /**\r\n     * The mimetype of this specific spine item.\r\n     *\r\n     * @property media_type\r\n     * @type     String\r\n     * @default  None\r\n     */\r\n    this.media_type = itemData.media_type;\r\n\r\n    /**\r\n     * The index of this spine item in the parent spine .\r\n     * \r\n     * @property index\r\n     * @type     String\r\n     * @default  None\r\n     */\r\n    this.index = index;\r\n\r\n    /**\r\n     * The object which is the actual spine of which this spineItem is a child.\r\n     *\r\n     * @property spine\r\n     * @type     Models.Spine\r\n     * @default  None\r\n     */\r\n    this.spine = spine;\r\n\r\n    validateSpread();\r\n\r\n    /**\r\n     * Sets a new page spread and checks its validity\r\n     *\r\n     * @method     setSpread\r\n     * @param      {String} spread  the new page spread \r\n     */\r\n    this.setSpread = function(spread) {\r\n        this.page_spread = spread;\r\n\r\n        validateSpread();\r\n    };\r\n\r\n    /* private method (validateSpread) */\r\n    function validateSpread() {\r\n\r\n        if(!self.page_spread) {\r\n            return;\r\n        }\r\n\r\n        if( self.page_spread != SpineItem.SPREAD_LEFT &&\r\n            self.page_spread != SpineItem.SPREAD_RIGHT &&\r\n            self.page_spread != SpineItem.SPREAD_CENTER ) {\r\n\r\n            console.error(self.page_spread + \" is not a recognized spread type\");\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Checks to see if the manifest has specified a spread property of \"none\"\r\n     *\r\n     * @method     isRenditionSpreadAllowed\r\n     * @return     {Boolean} TRUE if spread=none has NOT been specified, else FALSE\r\n     */\r\n    this.isRenditionSpreadAllowed = function() {\r\n        \r\n        var rendition_spread = self.getRenditionSpread();\r\n        return !rendition_spread || rendition_spread != SpineItem.RENDITION_SPREAD_NONE;\r\n    };\r\n\r\n    /**\r\n     * Checks to see if this spineItem explicitly specifies SPREAD_LEFT\r\n     *\r\n     * @method     isLeftPage\r\n     * @return     {Boolean} \r\n     */\r\n    this.isLeftPage = function() {\r\n        return self.page_spread == SpineItem.SPREAD_LEFT;\r\n    };\r\n\r\n    /**\r\n     * Checks to see if this spineItem explicitly specifies SPREAD_RIGHT\r\n     *\r\n     * @method     isRightPage\r\n     * @return     {Boolean} \r\n     */\r\n    this.isRightPage = function() {\r\n        return self.page_spread == SpineItem.SPREAD_RIGHT;\r\n    };\r\n\r\n    /**\r\n     * Checks to see if this spineItem explicitly specifies SPREAD_CENTER\r\n     *\r\n     * @method     isCenterPage\r\n     * @return     {Boolean} \r\n     */\r\n    this.isCenterPage = function() {\r\n        return self.page_spread == SpineItem.SPREAD_CENTER;\r\n    };\r\n\r\n    /**\r\n     * Checks to see if the parent package of this spineIem is\r\n     * reflowable\r\n     *\r\n     * @method     isReflowable\r\n     * @return     {Boolean} \r\n     */\r\n    this.isReflowable = function() {\r\n        return !self.isFixedLayout();\r\n    };\r\n\r\n    /**\r\n     * Checks to see if the parent package of to this spineIem is\r\n     * fixed layout\r\n     *\r\n     * @method     isFixedLayout\r\n     * @return     {Boolean} \r\n     */\r\n    this.isFixedLayout = function() {\r\n        \r\n        // cannot use isPropertyValueSetForItemOrPackage() here!\r\n\r\n        var isLayoutExplicitlyDefined = self.getRenditionLayout();\r\n\r\n        if(isLayoutExplicitlyDefined) {\r\n\r\n            if (self.rendition_layout)\r\n            {\r\n                if (self.rendition_layout === SpineItem.RENDITION_LAYOUT_PREPAGINATED) return true;\r\n                if (self.rendition_layout === SpineItem.RENDITION_LAYOUT_REFLOWABLE) return false;\r\n            }\r\n\r\n            return self.spine.package.isFixedLayout();\r\n        }\r\n\r\n        // if image or svg use fixed layout\r\n        return self.media_type.indexOf(\"image/\") >= 0;\r\n    };\r\n\r\n    /**\r\n     * Returns a string indicating the type of layout for viewport overflow, \r\n     * i.e. scrolldoc, scroll-continuous, paginated or auto.  Note that if the spineItem \r\n     * has an override (local value) that is returned, else the package's \r\n     * value is returned\r\n     *\r\n     * @method     getRenditionFlow\r\n     * @return     {String} \r\n     */\r\n   this.getRenditionFlow = function() {\r\n\r\n        if(self.rendition_flow) {\r\n            return self.rendition_flow;\r\n        }\r\n\r\n        return self.spine.package.rendition_flow;\r\n    };\r\n    \r\n    /**\r\n     * Returns the rendition:viewport, if any. Note that if the spineItem \r\n     * has an override (local value) that is returned, else the package's \r\n     * value is returned.\r\n     * Note that this attribute is deprecated in EPUB 3.1\r\n     *\r\n     * @method     getRenditionViewport\r\n     * @return     {Boolean} \r\n     */\r\n     this.getRenditionViewport = function() {\r\n\r\n        if(self.rendition_viewport) {\r\n            return self.rendition_viewport;\r\n        }\r\n\r\n        return self.spine.package.rendition_viewport;\r\n    };\r\n\r\n    /**\r\n     * Returns the rendition:spread, if any. Note that if the spineItem \r\n     * has an override (local value) that is returned, else the package's \r\n     * value is returned.\r\n     *\r\n     * @method     getRenditionSpread\r\n     * @return     {Boolean} \r\n     */\r\n    this.getRenditionSpread = function() {\r\n\r\n        if(self.rendition_spread) {\r\n            return self.rendition_spread;\r\n        }\r\n\r\n        return self.spine.package.rendition_spread;\r\n    };\r\n\r\n    /**\r\n     * Returns the rendition:orientation, if any. Note that if the spineItem \r\n     * has an override (local value) that is returned, else the package's \r\n     * value is returned.\r\n     *\r\n     * @method     getRenditionOrientation\r\n     * @return     {Boolean} \r\n     */\r\n    this.getRenditionOrientation = function() {\r\n\r\n        if(self.rendition_orientation) {\r\n            return self.rendition_orientation;\r\n        }\r\n\r\n        return self.spine.package.rendition_orientation;\r\n    };\r\n\r\n    /**\r\n     * Returns the rendition:layout, if any. Note that if the spineItem \r\n     * has an override (local value) that is returned, else the package's \r\n     * value is returned.\r\n     *\r\n     * @method     getRenditionLayout\r\n     * @return     {String} \r\n     */\r\n    this.getRenditionLayout = function() {\r\n\r\n        if(self.rendition_layout) {\r\n            return self.rendition_layout;\r\n        }\r\n\r\n        return self.spine.package.rendition_layout;\r\n    };\r\n\r\n    /**\r\n     * Checks to see if the specified property is set in this spineItem and\r\n     * matches the supplied value.  If the property is NOT set in the spineItem\r\n     * then the the package is checked. If not set in either place then \r\n     * the function returns FALSE.\r\n     *\r\n     * @method     isPropertyValueSetForItemOrPackage\r\n     * @param      {String} propName  The name of the property to be checked\r\n     * @param      {String} propValue The value of the property to be checked\r\n     * @return     {Boolean} \r\n     */\r\n    function isPropertyValueSetForItemOrPackage(propName, propValue) {\r\n\r\n        if(self[propName]) {\r\n            return self[propName] === propValue;\r\n        }\r\n\r\n        if(self.spine.package[propName]) {\r\n            return self.spine.package[propName] === propValue;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Checks if this spineItem or its parent package has its overflow content \r\n     * layout specified as scrolled-continuous.\r\n     *\r\n     * @method     isFlowScrolledContinuous\r\n     * @return     {Boolean} \r\n     */\r\n    this.isFlowScrolledContinuous = function() {\r\n\r\n        return isPropertyValueSetForItemOrPackage(\"rendition_flow\", SpineItem.RENDITION_FLOW_SCROLLED_CONTINUOUS);\r\n    };\r\n\r\n    /**\r\n     * Checks if this spineItem or its parent package has its overflow content \r\n     * layout specified as scrolled-doc.\r\n     *\r\n     * @method     isFlowScrolledDoc\r\n     * @return     {Boolean} \r\n     */\r\n    this.isFlowScrolledDoc = function() {\r\n\r\n        return isPropertyValueSetForItemOrPackage(\"rendition_flow\", SpineItem.RENDITION_FLOW_SCROLLED_DOC);\r\n    };\r\n};\r\n\r\n/** \r\n * @property RENDITION_LAYOUT_REFLOWABLE \r\n * @type {String}\r\n * @static \r\n */\r\nSpineItem.RENDITION_LAYOUT_REFLOWABLE = \"reflowable\";\r\n\r\n/** \r\n * @property RENDITION_LAYOUT_PREPAGINATED \r\n * @type {String}\r\n * @static \r\n */\r\nSpineItem.RENDITION_LAYOUT_PREPAGINATED = \"pre-paginated\";\r\n\r\n/** \r\n * @property RENDITION_ORIENTATION_LANDSCAPE \r\n * @type {String}\r\n * @static \r\n */\r\nSpineItem.RENDITION_ORIENTATION_LANDSCAPE = \"landscape\";\r\n\r\n/** \r\n * @property RENDITION_ORIENTATION_PORTRAIT \r\n * @type {String}\r\n * @static \r\n */\r\nSpineItem.RENDITION_ORIENTATION_PORTRAIT = \"portrait\";\r\n/** \r\n * @property RENDITION_ORIENTATION_AUTO\r\n * @type {String}\r\n * @static \r\n */\r\nSpineItem.RENDITION_ORIENTATION_AUTO = \"auto\";\r\n\r\n/** \r\n * @property SPREAD_LEFT \r\n * @type {String}\r\n * @static \r\n */\r\nSpineItem.SPREAD_LEFT = \"page-spread-left\";\r\n\r\n/** \r\n * @property SPREAD_RIGHT \r\n * @type {String}\r\n * @static \r\n */\r\nSpineItem.SPREAD_RIGHT = \"page-spread-right\";\r\n\r\n/** \r\n * @property SPREAD_CENTER \r\n * @type {String}\r\n * @static \r\n */\r\nSpineItem.SPREAD_CENTER = \"page-spread-center\";\r\n\r\n/** \r\n * @property RENDITION_SPREAD_NONE \r\n * @type {String}\r\n * @static \r\n */\r\nSpineItem.RENDITION_SPREAD_NONE = \"none\";\r\n\r\n/** \r\n * @property RENDITION_SPREAD_LANDSCAPE \r\n * @type {String}\r\n * @static \r\n */\r\nSpineItem.RENDITION_SPREAD_LANDSCAPE = \"landscape\";\r\n\r\n/** \r\n * @property RENDITION_SPREAD_PORTRAIT \r\n * @type {String}\r\n * @static \r\n */\r\nSpineItem.RENDITION_SPREAD_PORTRAIT = \"portrait\";\r\n\r\n/** \r\n * @property RENDITION_SPREAD_BOTH \r\n * @type {String}\r\n * @static \r\n */\r\nSpineItem.RENDITION_SPREAD_BOTH = \"both\";\r\n\r\n/** \r\n * @property RENDITION_SPREAD_AUTO \r\n * @type {String}\r\n * @static \r\n */\r\nSpineItem.RENDITION_SPREAD_AUTO = \"auto\";\r\n\r\n/** \r\n * @property RENDITION_FLOW_PAGINATED \r\n * @type {String}\r\n * @static \r\n */\r\nSpineItem.RENDITION_FLOW_PAGINATED = \"paginated\";\r\n\r\n/** \r\n * @property RENDITION_FLOW_SCROLLED_CONTINUOUS \r\n * @type {String}\r\n * @static \r\n */\r\nSpineItem.RENDITION_FLOW_SCROLLED_CONTINUOUS = \"scrolled-continuous\";\r\n\r\n/** \r\n * @property RENDITION_FLOW_SCROLLED_DOC \r\n * @type {String}\r\n * @static \r\n */\r\nSpineItem.RENDITION_FLOW_SCROLLED_DOC = \"scrolled-doc\";\r\n\r\n/** \r\n * @property RENDITION_FLOW_AUTO \r\n * @type {String}\r\n * @static \r\n */\r\nSpineItem.RENDITION_FLOW_AUTO = \"auto\";\r\n\r\n/**\r\n * Returns the inversion of the spineItem's SPREAD property. i.e\r\n * if the page-spread is right it returns LEFT and vice versa.  If \r\n * the spread is center then it returns CENTER\r\n *\r\n * @method     alternateSpread\r\n * @return     {String} \r\n */\r\nSpineItem.alternateSpread = function(spread) {\r\n\r\n    if(spread === SpineItem.SPREAD_LEFT) {\r\n        return SpineItem.SPREAD_RIGHT;\r\n    }\r\n\r\n    if(spread === SpineItem.SPREAD_RIGHT) {\r\n        return SpineItem.SPREAD_LEFT;\r\n    }\r\n\r\n    return spread;\r\n\r\n};\r\n    return SpineItem;\r\n});\r\n\r\n\r\n\n",
    "//  LauncherOSX\r\n//\r\n//  Created by Boris Schneiderman.\r\n//  Copyright (c) 2014 Readium Foundation and/or its licensees. All rights reserved.\r\n//\r\n//  Redistribution and use in source and binary forms, with or without modification,\r\n//  are permitted provided that the following conditions are met:\r\n//  1. Redistributions of source code must retain the above copyright notice, this\r\n//  list of conditions and the following disclaimer.\r\n//  2. Redistributions in binary form must reproduce the above copyright notice,\r\n//  this list of conditions and the following disclaimer in the documentation and/or\r\n//  other materials provided with the distribution.\r\n//  3. Neither the name of the organization nor the names of its contributors may be\r\n//  used to endorse or promote products derived from this software without specific\r\n//  prior written permission.\r\n//\r\n//  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\r\n//  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n//  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\r\n//  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\r\n//  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\r\n//  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\r\n//  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\r\n//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE\r\n//  OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\r\n//  OF THE POSSIBILITY OF SUCH DAMAGE.\r\ndefine('readium_shared_js/helpers',[\"./globals\", 'underscore', \"jquery\", \"jquerySizes\", \"./models/spine_item\"], function(Globals, _, $, JQuerySizes, SpineItem) {\r\n    \r\n(function()\r\n{\r\n/* jshint strict: true */\r\n/* jshint -W034 */\r\n    \"use strict\";\r\n    \r\n    if(window.performance)\r\n    {\r\n        if (window.performance.now)\r\n        {\r\n            return;\r\n        }\r\n        \r\n        var vendors = ['webkitNow', 'mozNow', 'msNow', 'oNow'];\r\n        \r\n        for (var i = 0; i < vendors.length; i++)\r\n        {\r\n            if (vendors[i] in window.performance)\r\n            {\r\n                window.performance.now = window.performance[vendors[i]];\r\n                return;\r\n            }\r\n        }\r\n    }\r\n    else\r\n    {\r\n        window.performance = {};\r\n        \r\n    }\r\n    \r\n    if(Date.now)\r\n    {\r\n        window.performance.now = function()\r\n        {\r\n            return Date.now();\r\n        };\r\n        return;\r\n    }\r\n    \r\n    window.performance.now = function()\r\n    {\r\n        return +(new Date());\r\n    };\r\n})();\r\n\r\nvar Helpers = {};\r\n\r\n/**\r\n *\r\n * @param ebookURL URL string, or Blob (possibly File)\r\n * @returns string representing the file path / name from which the asset referenced by this URL originates\r\n */\r\nHelpers.getEbookUrlFilePath = function(ebookURL) {\r\n    if (!window.Blob || !window.File) return ebookURL;\r\n\r\n    if (ebookURL instanceof File) {\r\n        return ebookURL.name;\r\n    } else if (ebookURL instanceof Blob) {\r\n        return \"readium-ebook.epub\";\r\n    } else {\r\n        return ebookURL;\r\n    }\r\n};\r\n\r\n/**\r\n *\r\n * @returns object (map between URL query parameter names and corresponding decoded / unescaped values)\r\n */\r\nHelpers.getURLQueryParams = function() {\r\n    var params = {};\r\n\r\n    var query = window.location.search;\r\n    if (query && query.length) {\r\n        query = query.substring(1);\r\n        var keyParams = query.split('&');\r\n        for (var x = 0; x < keyParams.length; x++)\r\n        {\r\n            var keyVal = keyParams[x].split('=');\r\n            if (keyVal.length > 1) {\r\n                params[keyVal[0]] = decodeURIComponent(keyVal[1]);\r\n            }\r\n        }\r\n    }\r\n\r\n    return params;\r\n};\r\n\r\n\r\n/**\r\n * @param urlpath: string corresponding a URL without query parameters (i.e. the part before the '?' question mark in index.html?param=value). If undefined/null, the default window.location is used.\r\n * @param overrides: object that maps query parameter names with values (to be included in the resulting URL, while any other query params in the current window.location are preserved as-is) \r\n * @returns a string corresponding to a URL obtained by concatenating the given URL with the given query parameters (and those already in window.location)\r\n */\r\nHelpers.buildUrlQueryParameters = function(urlpath, overrides) {\r\n    \r\n    if (!urlpath) {\r\n        urlpath =\r\n        window.location ? (\r\n            window.location.protocol\r\n            + \"//\"\r\n            + window.location.hostname\r\n            + (window.location.port ? (':' + window.location.port) : '')\r\n            + window.location.pathname\r\n        ) : 'index.html';\r\n    }\r\n\r\n    var paramsString = \"\";\r\n    \r\n    for (var key in overrides) {\r\n        if (!overrides.hasOwnProperty(key)) continue;\r\n        \r\n        if (!overrides[key]) continue;\r\n        \r\n        var val = overrides[key].trim();\r\n        if (!val) continue;\r\n        \r\n        console.debug(\"URL QUERY PARAM OVERRIDE: \" + key + \" = \" + val);\r\n\r\n        paramsString += (key + \"=\" + encodeURIComponent(val));\r\n        paramsString += \"&\";\r\n    }\r\n    \r\n    var urlParams = Helpers.getURLQueryParams();\r\n    for (var key in urlParams) {\r\n        if (!urlParams.hasOwnProperty(key)) continue;\r\n        \r\n        if (!urlParams[key]) continue;\r\n        \r\n        if (overrides[key]) continue;\r\n\r\n        var val = urlParams[key].trim();\r\n        if (!val) continue;\r\n        \r\n        console.debug(\"URL QUERY PARAM PRESERVED: \" + key + \" = \" + val);\r\n\r\n        paramsString += (key + \"=\" + encodeURIComponent(val));\r\n        paramsString += \"&\";\r\n    }\r\n    \r\n    return urlpath + \"?\" + paramsString;\r\n};\r\n\r\n\r\n/**\r\n *\r\n * @param left\r\n * @param top\r\n * @param width\r\n * @param height\r\n * @constructor\r\n */\r\nHelpers.Rect = function (left, top, width, height) {\r\n\r\n    this.left = left;\r\n    this.top = top;\r\n    this.width = width;\r\n    this.height = height;\r\n\r\n    this.right = function () {\r\n        return this.left + this.width;\r\n    };\r\n\r\n    this.bottom = function () {\r\n        return this.top + this.height;\r\n    };\r\n\r\n    this.isOverlap = function (rect, tolerance) {\r\n\r\n        if (tolerance == undefined) {\r\n            tolerance = 0;\r\n        }\r\n\r\n        return !(rect.right() < this.left + tolerance ||\r\n        rect.left > this.right() - tolerance ||\r\n        rect.bottom() < this.top + tolerance ||\r\n        rect.top > this.bottom() - tolerance);\r\n    }\r\n};\r\n\r\n/**\r\n *\r\n * @param $element\r\n * @returns {Helpers.Rect}\r\n */\r\n//This method treats multicolumn view as one long column and finds the rectangle of the element in this \"long\" column\r\n//we are not using jQuery Offset() and width()/height() function because for multicolumn rendition_layout it produces rectangle as a bounding box of element that\r\n// reflows between columns this is inconstant and difficult to analyze .\r\nHelpers.Rect.fromElement = function ($element) {\r\n\r\n    var e;\r\n    if (_.isArray($element) || $element instanceof jQuery)\r\n        e = $element[0];\r\n    else\r\n        e = $element;\r\n    // TODODM this is somewhat hacky. Text (range?) elements don't have a position so we have to ask the parent.\r\n    if (e.nodeType === 3) {\r\n        e = $element.parent()[0];\r\n    }\r\n\r\n\r\n    var offsetLeft = e.offsetLeft;\r\n    var offsetTop = e.offsetTop;\r\n    var offsetWidth = e.offsetWidth;\r\n    var offsetHeight = e.offsetHeight;\r\n\r\n    while (e = e.offsetParent) {\r\n        offsetLeft += e.offsetLeft;\r\n        offsetTop += e.offsetTop;\r\n    }\r\n\r\n    return new Helpers.Rect(offsetLeft, offsetTop, offsetWidth, offsetHeight);\r\n};\r\n\r\nHelpers.UpdateHtmlFontSize = function ($epubHtml, fontSize) {\r\n\r\n    var perf = false;\r\n\r\n    // TODO: very slow on Firefox!\r\n    // See https://github.com/readium/readium-shared-js/issues/274\r\n    if (perf) var time1 = window.performance.now();\r\n\r\n    var factor = fontSize / 100;\r\n    var win = $epubHtml[0].ownerDocument.defaultView;\r\n    var $textblocks = $('p, div, span, h1, h2, h3, h4, h5, h6, li, blockquote, td, pre', $epubHtml);\r\n    var originalLineHeight;\r\n\r\n\r\n    // need to do two passes because it is possible to have nested text blocks.\r\n    // If you change the font size of the parent this will then create an inaccurate\r\n    // font size for any children.\r\n    for (var i = 0; i < $textblocks.length; i++) {\r\n        var ele = $textblocks[i],\r\n            fontSizeAttr = ele.getAttribute('data-original-font-size');\r\n\r\n        if (!fontSizeAttr) {\r\n            var style = win.getComputedStyle(ele);\r\n            var originalFontSize = parseInt(style.fontSize);\r\n            originalLineHeight = parseInt(style.lineHeight);\r\n\r\n            ele.setAttribute('data-original-font-size', originalFontSize);\r\n            // getComputedStyle will not calculate the line-height if the value is 'normal'. In this case parseInt will return NaN\r\n            if (originalLineHeight) {\r\n                ele.setAttribute('data-original-line-height', originalLineHeight);\r\n            }\r\n        }\r\n    }\r\n\r\n    // reset variable so the below logic works. All variables in JS are function scoped.\r\n    originalLineHeight = 0;\r\n    for (var i = 0; i < $textblocks.length; i++) {\r\n        var ele = $textblocks[i],\r\n            fontSizeAttr = ele.getAttribute('data-original-font-size'),\r\n            lineHeightAttr = ele.getAttribute('data-original-line-height'),\r\n            originalFontSize = Number(fontSizeAttr);\r\n\r\n        if (lineHeightAttr) {\r\n            originalLineHeight = Number(lineHeightAttr);\r\n        }\r\n        else {\r\n            originalLineHeight = 0;\r\n        }\r\n\r\n        $(ele).css(\"font-size\", (originalFontSize * factor) + 'px');\r\n        if (originalLineHeight) {\r\n            $(ele).css(\"line-height\", (originalLineHeight * factor) + 'px');\r\n        }\r\n\r\n    }\r\n    $epubHtml.css(\"font-size\", fontSize + \"%\");\r\n    \r\n    if (perf) {\r\n        var time2 = window.performance.now();\r\n    \r\n        // Firefox: 80+\r\n        // Chrome: 4-10\r\n        // Edge: 15-34\r\n        // IE: 10-15\r\n        // https://readium.firebase.com/?epub=..%2Fepub_content%2Faccessible_epub_3&goto=%7B%22idref%22%3A%22id-id2635343%22%2C%22elementCfi%22%3A%22%2F4%2F2%5Bbuilding_a_better_epub%5D%2F10%2F44%2F6%2C%2F1%3A334%2C%2F1%3A335%22%7D\r\n        \r\n        var diff = time2-time1;\r\n        console.log(diff);\r\n        \r\n        // setTimeout(function(){\r\n        //     alert(diff);\r\n        // }, 2000);\r\n    }\r\n};\r\n\r\n\r\n/**\r\n *\r\n * @param contentRef\r\n * @param sourceFileHref\r\n * @returns {string}\r\n * @constructor\r\n */\r\nHelpers.ResolveContentRef = function (contentRef, sourceFileHref) {\r\n\r\n    if (!sourceFileHref) {\r\n        return contentRef;\r\n    }\r\n\r\n    var sourceParts = sourceFileHref.split(\"/\");\r\n    sourceParts.pop(); //remove source file name\r\n\r\n    var pathComponents = contentRef.split(\"/\");\r\n\r\n    while (sourceParts.length > 0 && pathComponents[0] === \"..\") {\r\n\r\n        sourceParts.pop();\r\n        pathComponents.splice(0, 1);\r\n    }\r\n\r\n    var combined = sourceParts.concat(pathComponents);\r\n\r\n    return combined.join(\"/\");\r\n\r\n};\r\n\r\n/**\r\n *\r\n * @param str\r\n * @param suffix\r\n * @returns {boolean}\r\n * @static\r\n */\r\nHelpers.EndsWith = function (str, suffix) {\r\n    return str.indexOf(suffix, str.length - suffix.length) !== -1;\r\n};\r\n\r\n/**\r\n *\r\n * @param str\r\n * @param suffix\r\n * @returns {boolean}\r\n * @static\r\n */\r\nHelpers.BeginsWith = function (str, suffix) {\r\n\r\n    return str.indexOf(suffix) === 0;\r\n};\r\n\r\n/**\r\n *\r\n * @param str\r\n * @param toRemove\r\n * @returns {string}\r\n * @static\r\n */\r\nHelpers.RemoveFromString = function (str, toRemove) {\r\n\r\n    var startIx = str.indexOf(toRemove);\r\n\r\n    if (startIx == -1) {\r\n        return str;\r\n    }\r\n\r\n    return str.substring(0, startIx) + str.substring(startIx + toRemove.length);\r\n};\r\n\r\n/**\r\n *\r\n * @param margin\r\n * @param border\r\n * @param padding\r\n * @constructor\r\n */\r\nHelpers.Margins = function (margin, border, padding) {\r\n\r\n    this.margin = margin;\r\n    this.border = border;\r\n    this.padding = padding;\r\n\r\n    this.left = this.margin.left + this.border.left + this.padding.left;\r\n    this.right = this.margin.right + this.border.right + this.padding.right;\r\n    this.top = this.margin.top + this.border.top + this.padding.top;\r\n    this.bottom = this.margin.bottom + this.border.bottom + this.padding.bottom;\r\n\r\n    this.width = function () {\r\n        return this.left + this.right;\r\n    };\r\n\r\n    this.height = function () {\r\n        return this.top + this.bottom;\r\n    }\r\n};\r\n\r\n/**\r\n *\r\n * @param $iframe\r\n */\r\nHelpers.triggerLayout = function ($iframe) {\r\n\r\n    var doc = $iframe[0].contentDocument;\r\n\r\n    if (!doc) {\r\n        return;\r\n    }\r\n\r\n    var ss = undefined;\r\n    try {\r\n        ss = doc.styleSheets && doc.styleSheets.length ? doc.styleSheets[0] : undefined;\r\n        if (!ss) {\r\n            var style = doc.createElement('style');\r\n            doc.head.appendChild(style);\r\n            style.appendChild(doc.createTextNode(''));\r\n            ss = style.sheet;\r\n        }\r\n\r\n        if (ss) {\r\n            var cssRule = 'body:first-child::before {content:\\'READIUM\\';color: red;font-weight: bold;}';\r\n            if (ss.cssRules) {\r\n                ss.insertRule(cssRule, ss.cssRules.length);\r\n            } else {\r\n                ss.insertRule(cssRule, 0);\r\n            }\r\n        }\r\n    }\r\n    catch (ex) {\r\n        console.error(ex);\r\n    }\r\n\r\n    try {\r\n        var el = doc.createElementNS(\"http://www.w3.org/1999/xhtml\", \"style\");\r\n        el.appendChild(doc.createTextNode(\"*{}\"));\r\n        doc.body.appendChild(el);\r\n        doc.body.removeChild(el);\r\n\r\n        if (ss) {\r\n            if (ss.cssRules) {\r\n                ss.deleteRule(ss.cssRules.length - 1);\r\n            } else {\r\n                ss.deleteRule(0);\r\n            }\r\n        }\r\n    }\r\n    catch (ex) {\r\n        console.error(ex);\r\n    }\r\n\r\n    if (doc.body) {\r\n        var val = doc.body.offsetTop; // triggers layout\r\n    }\r\n\r\n};\r\n\r\n/**\r\n *\r\n * @param $viewport\r\n * @param spineItem\r\n * @param settings\r\n * @returns {boolean}\r\n */\r\n//Based on https://docs.google.com/spreadsheet/ccc?key=0AoPMUkQhc4wcdDI0anFvWm96N0xRT184ZE96MXFRdFE&usp=drive_web#gid=0 doc\r\n// Returns falsy and truthy\r\n// true and false mean that the synthetic-spread or single-page is \"forced\" (to be respected whatever the external conditions)\r\n// 1 and 0 mean that the synthetic-spread or single-page is \"not forced\" (is allowed to be overriden by external conditions, such as optimum column width / text line number of characters, etc.)\r\nHelpers.deduceSyntheticSpread = function ($viewport, spineItem, settings) {\r\n\r\n    if (!$viewport || $viewport.length == 0) {\r\n        return 0; // non-forced\r\n    }\r\n\r\n    //http://www.idpf.org/epub/fxl/#property-spread-values\r\n\r\n    var rendition_spread = spineItem ? spineItem.getRenditionSpread() : undefined;\r\n\r\n    if (rendition_spread === SpineItem.RENDITION_SPREAD_NONE) {\r\n        return false; // forced\r\n\r\n        //\"Reading Systems must not incorporate this spine item in a synthetic spread.\"\r\n    }\r\n\r\n    if (settings.syntheticSpread == \"double\") {\r\n        return true; // forced\r\n    }\r\n    else if (settings.syntheticSpread == \"single\") {\r\n        return false; // forced\r\n    }\r\n\r\n    if (!spineItem) {\r\n        return 0; // non-forced\r\n    }\r\n\r\n    if (rendition_spread === SpineItem.RENDITION_SPREAD_BOTH) {\r\n        return true; // forced\r\n\r\n        //\"Reading Systems should incorporate this spine item in a synthetic spread regardless of device orientation.\"\r\n    }\r\n\r\n    var orientation = Helpers.getOrientation($viewport);\r\n\r\n    if (rendition_spread === SpineItem.RENDITION_SPREAD_LANDSCAPE) {\r\n        return orientation === Globals.Views.ORIENTATION_LANDSCAPE; // forced\r\n\r\n        //\"Reading Systems should incorporate this spine item in a synthetic spread only when the device is in landscape orientation.\"\r\n    }\r\n\r\n    if (rendition_spread === SpineItem.RENDITION_SPREAD_PORTRAIT) {\r\n        return orientation === Globals.Views.ORIENTATION_PORTRAIT; // forced\r\n\r\n        //\"Reading Systems should incorporate this spine item in a synthetic spread only when the device is in portrait orientation.\"\r\n    }\r\n\r\n    if (!rendition_spread || rendition_spread === SpineItem.RENDITION_SPREAD_AUTO) {\r\n        // if no spread set in document and user didn't set in in setting we will do double for landscape\r\n        var landscape = orientation === Globals.Views.ORIENTATION_LANDSCAPE;\r\n        return landscape ? 1 : 0; // non-forced\r\n\r\n        //\"Reading Systems may use synthetic spreads in specific or all device orientations as part of a display area utilization optimization process.\"\r\n    }\r\n\r\n    console.warn(\"Helpers.deduceSyntheticSpread: spread properties?!\");\r\n    return 0; // non-forced\r\n};\r\n\r\n/**\r\n *\r\n * @param $element\r\n * @returns {Helpers.Rect}\r\n */\r\nHelpers.Margins.fromElement = function ($element) {\r\n    return new this($element.margin(), $element.border(), $element.padding());\r\n};\r\n\r\n/**\r\n * @returns {Helpers.Rect}\r\n */\r\nHelpers.Margins.empty = function () {\r\n\r\n    return new this({left: 0, right: 0, top: 0, bottom: 0}, {left: 0, right: 0, top: 0, bottom: 0}, {\r\n        left: 0,\r\n        right: 0,\r\n        top: 0,\r\n        bottom: 0\r\n    });\r\n\r\n};\r\n\r\n/**\r\n *\r\n * @param name\r\n * @param params\r\n * @returns {Helpers.loadTemplate.cache}\r\n */\r\nHelpers.loadTemplate = function (name, params) {\r\n    return Helpers.loadTemplate.cache[name];\r\n};\r\n\r\n/**\r\n *\r\n * @type {{fixed_book_frame: string, single_page_frame: string, scrolled_book_frame: string, reflowable_book_frame: string, reflowable_book_page_frame: string}}\r\n */\r\nHelpers.loadTemplate.cache = {\r\n    \"fixed_book_frame\": '<div id=\"fixed-book-frame\" class=\"clearfix book-frame fixed-book-frame\"></div>',\r\n\r\n    \"single_page_frame\": '<div><div id=\"scaler\"><iframe scrolling=\"no\" class=\"iframe-fixed\"></iframe></div></div>',\r\n    //\"single_page_frame\" : '<div><iframe scrolling=\"no\" class=\"iframe-fixed\" id=\"scaler\"></iframe></div>',\r\n\r\n    \"scrolled_book_frame\": '<div id=\"reflowable-book-frame\" class=\"clearfix book-frame reflowable-book-frame\"><div id=\"scrolled-content-frame\"></div></div>',\r\n    \"reflowable_book_frame\": '<div id=\"reflowable-book-frame\" class=\"clearfix book-frame reflowable-book-frame\"></div>',\r\n    \"reflowable_book_page_frame\": '<div id=\"reflowable-content-frame\" class=\"reflowable-content-frame\"><iframe scrolling=\"no\" id=\"epubContentIframe\"></iframe></div>'\r\n};\r\n\r\n/**\r\n *\r\n * @param styles\r\n * @param $element\r\n */\r\nHelpers.setStyles = function (styles, $element) {\r\n\r\n    var count = styles.length;\r\n\r\n    if (!count) {\r\n        return;\r\n    }\r\n\r\n    for (var i = 0; i < count; i++) {\r\n        var style = styles[i];\r\n        if (style.selector) {\r\n            $(style.selector, $element).css(style.declarations);\r\n        }\r\n        else {\r\n            $element.css(style.declarations);\r\n        }\r\n    }\r\n\r\n};\r\n\r\n/**\r\n *\r\n * @param iframe\r\n * @returns {boolean}\r\n */\r\nHelpers.isIframeAlive = function (iframe) {\r\n    var w = undefined;\r\n    var d = undefined;\r\n    try {\r\n        w = iframe.contentWindow;\r\n        d = iframe.contentDocument;\r\n    }\r\n    catch (ex) {\r\n        console.error(ex);\r\n        return false;\r\n    }\r\n\r\n    return w && d;\r\n};\r\n\r\n/**\r\n *\r\n * @param $viewport\r\n * @returns {Globals.Views.ORIENTATION_LANDSCAPE|Globals.Views.ORIENTATION_PORTRAIT}\r\n */\r\nHelpers.getOrientation = function ($viewport) {\r\n\r\n    var viewportWidth = $viewport.width();\r\n    var viewportHeight = $viewport.height();\r\n\r\n    if (!viewportWidth || !viewportHeight) {\r\n        return undefined;\r\n    }\r\n\r\n    return viewportWidth >= viewportHeight ? Globals.Views.ORIENTATION_LANDSCAPE : Globals.Views.ORIENTATION_PORTRAIT;\r\n};\r\n\r\n/**\r\n *\r\n * @param item\r\n * @param orientation\r\n * @returns {boolean}\r\n */\r\nHelpers.isRenditionSpreadPermittedForItem = function (item, orientation) {\r\n\r\n    var rendition_spread = item.getRenditionSpread();\r\n\r\n    return !rendition_spread\r\n        || rendition_spread == SpineItem.RENDITION_SPREAD_BOTH\r\n        || rendition_spread == SpineItem.RENDITION_SPREAD_AUTO\r\n        || (rendition_spread == SpineItem.RENDITION_SPREAD_LANDSCAPE\r\n        && orientation == Globals.Views.ORIENTATION_LANDSCAPE)\r\n        || (rendition_spread == SpineItem.RENDITION_SPREAD_PORTRAIT\r\n        && orientation == Globals.Views.ORIENTATION_PORTRAIT );\r\n};\r\n\r\nHelpers.CSSTransition = function ($el, trans) {\r\n\r\n    // does not work!\r\n    //$el.css('transition', trans);\r\n\r\n    var css = {};\r\n    // empty '' prefix FIRST!\r\n    _.each(['', '-webkit-', '-moz-', '-ms-'], function (prefix) {\r\n        css[prefix + 'transition'] = prefix + trans;\r\n    });\r\n    $el.css(css);\r\n}\r\n\r\n//scale, left, top, angle, origin\r\nHelpers.CSSTransformString = function (options) {\r\n    var enable3D = options.enable3D ? true : false;\r\n\r\n    var translate, scale, rotation,\r\n        origin = options.origin;\r\n\r\n    if (options.left || options.top) {\r\n        var left = options.left || 0,\r\n            top = options.top || 0;\r\n\r\n        translate = enable3D ? (\"translate3D(\" + left + \"px, \" + top + \"px, 0)\") : (\"translate(\" + left + \"px, \" + top + \"px)\");\r\n    }\r\n    if (options.scale) {\r\n        scale = enable3D ? (\"scale3D(\" + options.scale + \", \" + options.scale + \", 0)\") : (\"scale(\" + options.scale + \")\");\r\n    }\r\n    if (options.angle) {\r\n        rotation = enable3D ? (\"rotate3D(0,0,\" + options.angle + \"deg)\") : (\"rotate(\" + options.angle + \"deg)\");\r\n    }\r\n\r\n    if (!(translate || scale || rotation)) {\r\n        return {};\r\n    }\r\n\r\n    var transformString = (translate && scale) ? (translate + \" \" + scale) : (translate ? translate : scale); // the order is important!\r\n    if (rotation) {\r\n        transformString = transformString + \" \" + rotation;\r\n        //transformString = rotation + \" \" + transformString;\r\n    }\r\n\r\n    var css = {};\r\n    css['transform'] = transformString;\r\n    css['transform-origin'] = origin ? origin : (enable3D ? '0 0 0' : '0 0');\r\n    return css;\r\n};\r\n\r\nHelpers.extendedThrottle = function (startCb, tickCb, endCb, tickRate, waitThreshold, context) {\r\n    if (!tickRate) tickRate = 250;\r\n    if (!waitThreshold) waitThreshold = tickRate;\r\n\r\n    var first = true,\r\n        last,\r\n        deferTimer;\r\n\r\n    return function () {\r\n        var ctx = context || this,\r\n            now = (Date.now && Date.now()) || new Date().getTime(),\r\n            args = arguments;\r\n\r\n        if (!(last && now < last + tickRate)) {\r\n            last = now;\r\n            if (first) {\r\n                startCb.apply(ctx, args);\r\n                first = false;\r\n            } else {\r\n                tickCb.apply(ctx, args);\r\n            }\r\n        }\r\n\r\n        clearTimeout(deferTimer);\r\n        deferTimer = setTimeout(function () {\r\n            last = now;\r\n            first = true;\r\n            endCb.apply(ctx, args);\r\n        }, waitThreshold);\r\n    };\r\n};\r\n\r\n\r\n//TODO: consider using CSSOM escape() or polyfill\r\n//https://github.com/mathiasbynens/CSS.escape/blob/master/css.escape.js\r\n//http://mathiasbynens.be/notes/css-escapes\r\n/**\r\n *\r\n * @param sel\r\n * @returns {string}\r\n */\r\nHelpers.escapeJQuerySelector = function (sel) {\r\n    //http://api.jquery.com/category/selectors/\r\n    //!\"#$%&'()*+,./:;<=>?@[\\]^`{|}~\r\n    // double backslash escape\r\n\r\n    if (!sel) return undefined;\r\n\r\n    var selector = sel.replace(/([;&,\\.\\+\\*\\~\\?':\"\\!\\^#$%@\\[\\]\\(\\)<=>\\|\\/\\\\{}`])/g, '\\\\$1');\r\n\r\n    // if (selector !== sel)\r\n    // {\r\n    //     console.debug(\"---- SELECTOR ESCAPED\");\r\n    //     console.debug(\"1: \" + sel);\r\n    //     console.debug(\"2: \" + selector);\r\n    // }\r\n    // else\r\n    // {\r\n    //     console.debug(\"---- SELECTOR OKAY: \" + sel);\r\n    // }\r\n\r\n    return selector;\r\n};\r\n\r\nHelpers.polyfillCaretRangeFromPoint = function(document) {\r\n    //Derived from css-regions-polyfill:\r\n    // https://github.com/FremyCompany/css-regions-polyfill/blob/bfbb6445ec2a2a883005ab8801d8463fa54b5701/src/range-extensions.js\r\n    //Copyright (c) 2013 François REMY\r\n    //Copyright (c) 2013 Adobe Systems Inc.\r\n    //Licensed under the Apache License, Version 2.0\r\n    if (!document.caretRangeFromPoint) {\r\n        if (document.caretPositionFromPoint) {\r\n            document.caretRangeFromPoint = function caretRangeFromPoint(x, y) {\r\n                var r = document.createRange();\r\n                var p = document.caretPositionFromPoint(x, y);\r\n                if (!p) return null;\r\n                if (p.offsetNode) {\r\n                    r.setStart(p.offsetNode, p.offset);\r\n                    r.setEnd(p.offsetNode, p.offset);\r\n                }\r\n                return r;\r\n            }\r\n        } else if ((document.body || document.createElement('body')).createTextRange) {\r\n            //\r\n            // we may want to convert TextRange to Range\r\n            //\r\n\r\n            //TextRangeUtils, taken from: https://code.google.com/p/ierange/\r\n            //Copyright (c) 2009 Tim Cameron Ryan\r\n            //Released under the MIT/X License\r\n            var TextRangeUtils = {\r\n                convertToDOMRange: function(textRange, document) {\r\n                    var adoptBoundary = function(domRange, textRangeInner, bStart) {\r\n                        // iterate backwards through parent element to find anchor location\r\n                        var cursorNode = document.createElement('a'),\r\n                            cursor = textRangeInner.duplicate();\r\n                        cursor.collapse(bStart);\r\n                        var parent = cursor.parentElement();\r\n                        do {\r\n                            parent.insertBefore(cursorNode, cursorNode.previousSibling);\r\n                            cursor.moveToElementText(cursorNode);\r\n                        } while (cursor.compareEndPoints(bStart ? 'StartToStart' : 'StartToEnd', textRangeInner) > 0 && cursorNode.previousSibling);\r\n                        // when we exceed or meet the cursor, we've found the node\r\n                        if (cursor.compareEndPoints(bStart ? 'StartToStart' : 'StartToEnd', textRangeInner) == -1 && cursorNode.nextSibling) {\r\n                            // data node\r\n                            cursor.setEndPoint(bStart ? 'EndToStart' : 'EndToEnd', textRangeInner);\r\n                            domRange[bStart ? 'setStart' : 'setEnd'](cursorNode.nextSibling, cursor.text.length);\r\n                        } else {\r\n                            // element\r\n                            domRange[bStart ? 'setStartBefore' : 'setEndBefore'](cursorNode);\r\n                        }\r\n                        cursorNode.parentNode.removeChild(cursorNode);\r\n                    };\r\n                    // return a DOM range\r\n                    var domRange = document.createRange();\r\n                    adoptBoundary(domRange, textRange, true);\r\n                    adoptBoundary(domRange, textRange, false);\r\n                    return domRange;\r\n                }\r\n            };\r\n\r\n            document.caretRangeFromPoint = function caretRangeFromPoint(x, y) {\r\n                // the accepted number of vertical backtracking, in CSS pixels\r\n                var IYDepth = 40;\r\n                // try to create a text range at the specified location\r\n                var tr = document.body.createTextRange();\r\n                for (var iy = IYDepth; iy; iy = iy - 4) {\r\n                    try {\r\n                        tr.moveToPoint(x, iy + y - IYDepth);\r\n                        return TextRangeUtils.convertToDOMRange(tr, document);\r\n                    } catch (ex) {\r\n                    }\r\n                }\r\n                // if that fails, return the location just after the element located there\r\n                try {\r\n                    var elem = document.elementFromPoint(x - 1, y - 1);\r\n                    var r = document.createRange();\r\n                    r.setStartAfter(elem);\r\n                    return r;\r\n                } catch (ex) {\r\n                    return null;\r\n                }\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\nreturn Helpers;\r\n});\r\n\n",
    "//  LauncherOSX\r\n//\r\n//  Created by Boris Schneiderman.\r\n//  Copyright (c) 2014 Readium Foundation and/or its licensees. All rights reserved.\r\n//  \r\n//  Redistribution and use in source and binary forms, with or without modification, \r\n//  are permitted provided that the following conditions are met:\r\n//  1. Redistributions of source code must retain the above copyright notice, this \r\n//  list of conditions and the following disclaimer.\r\n//  2. Redistributions in binary form must reproduce the above copyright notice, \r\n//  this list of conditions and the following disclaimer in the documentation and/or \r\n//  other materials provided with the distribution.\r\n//  3. Neither the name of the organization nor the names of its contributors may be \r\n//  used to endorse or promote products derived from this software without specific \r\n//  prior written permission.\r\n//  \r\n//  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND \r\n//  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED \r\n//  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. \r\n//  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, \r\n//  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, \r\n//  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, \r\n//  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF \r\n//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE \r\n//  OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED \r\n//  OF THE POSSIBILITY OF SUCH DAMAGE.\r\n\r\n/**\r\n * CFI navigation helper class\r\n *\r\n * @param options Additional settings for NavigationLogic object\r\n *      - paginationInfo            Layout details, used by clientRect-based geometry\r\n *      - visibleContentOffsets     Function that returns offsets. If supplied it is used instead of the inferred offsets\r\n *      - frameDimensions           Function that returns an object with width and height properties. Needs to be set.\r\n *      - $iframe                   Iframe reference, and needs to be set.\r\n * @constructor\r\n */\r\ndefine('readium_shared_js/views/cfi_navigation_logic',[\"jquery\", \"underscore\", \"../helpers\", 'readium_cfi_js'], function($, _, Helpers, epubCfi) {\r\n\r\nvar CfiNavigationLogic = function(options) {\r\n\r\n    var self = this;\r\n    options = options || {};\r\n\r\n    var debugMode = ReadiumSDK.DEBUG_MODE;\r\n\r\n    this.getRootElement = function() {\r\n\r\n        return options.$iframe[0].contentDocument.documentElement;\r\n    };\r\n    \r\n    this.getBodyElement = function () {\r\n        \r\n        // In SVG documents the root element can be considered the body.\r\n        return this.getRootDocument().body || this.getRootElement();\r\n    };\r\n\r\n    this.getClassBlacklist = function () {\r\n        return options.classBlacklist || [];\r\n    }\r\n\r\n    this.getIdBlacklist = function () {\r\n        return options.idBlacklist || [];\r\n    }\r\n\r\n    this.getElementBlacklist = function () {\r\n        return options.elementBlacklist || [];\r\n    }\r\n\r\n    this.getRootDocument = function () {\r\n        return options.$iframe[0].contentDocument;\r\n    };\r\n\r\n    function createRange() {\r\n        return self.getRootDocument().createRange();\r\n    }\r\n\r\n    function getNodeClientRect(node) {\r\n        var range = createRange();\r\n        range.selectNode(node);\r\n        return normalizeRectangle(range.getBoundingClientRect(),0,0);\r\n    }\r\n\r\n    function getNodeContentsClientRect(node) {\r\n        var range = createRange();\r\n        range.selectNodeContents(node);\r\n        return normalizeRectangle(range.getBoundingClientRect(),0,0);\r\n    }\r\n\r\n    function getElementClientRect($element) {\r\n        return normalizeRectangle($element[0].getBoundingClientRect(),0,0);\r\n    }\r\n\r\n    function getNodeRangeClientRect(startNode, startOffset, endNode, endOffset) {\r\n        var range = createRange();\r\n        range.setStart(startNode, startOffset ? startOffset : 0);\r\n        if (endNode.nodeType === Node.ELEMENT_NODE) {\r\n            range.setEnd(endNode, endOffset ? endOffset : endNode.childNodes.length);\r\n        } else if (endNode.nodeType === Node.TEXT_NODE) {\r\n            range.setEnd(endNode, endOffset ? endOffset : 0);\r\n        }\r\n        return normalizeRectangle(range.getBoundingClientRect(),0,0);\r\n    }\r\n\r\n    function getNodeClientRectList(node, visibleContentOffsets) {\r\n        visibleContentOffsets = visibleContentOffsets || getVisibleContentOffsets();\r\n        \r\n        var range = createRange();\r\n        range.selectNode(node);\r\n        return _.map(range.getClientRects(), function (rect) {\r\n            return normalizeRectangle(rect, visibleContentOffsets.left, visibleContentOffsets.top);\r\n        });\r\n    }\r\n\r\n    function getFrameDimensions() {\r\n        if (options.frameDimensions) {\r\n            return options.frameDimensions();\r\n        }\r\n        \r\n        console.error('CfiNavigationLogic: No frame dimensions specified!');\r\n        return null;\r\n    }\r\n\r\n    function getCaretRangeFromPoint(x, y, document) {\r\n        document = document || self.getRootDocument();\r\n        Helpers.polyfillCaretRangeFromPoint(document); //only polyfills once, no-op afterwards\r\n        return document.caretRangeFromPoint(x, y);\r\n    }\r\n\r\n    function isPaginatedView() {\r\n        return !!options.paginationInfo;\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * Checks whether or not pages are rendered right-to-left\r\n     *\r\n     * @returns {boolean}\r\n     */\r\n    function isPageProgressionRightToLeft() {\r\n        return options.paginationInfo && !!options.paginationInfo.rightToLeft;\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * Checks whether or not pages are rendered with vertical writing mode\r\n     *\r\n     * @returns {boolean}\r\n     */\r\n    function isVerticalWritingMode() {\r\n        return options.paginationInfo && !!options.paginationInfo.isVerticalWritingMode;\r\n    }\r\n\r\n\r\n    /**\r\n     * @private\r\n     * Checks whether or not a (fully adjusted) rectangle is at least partly visible\r\n     *\r\n     * @param {Object} rect\r\n     * @param {Object} [frameDimensions]\r\n     * @param {boolean} [isVwm]           isVerticalWritingMode\r\n     * @returns {boolean}\r\n     */\r\n    function isRectVisible(rect, ignorePartiallyVisible, frameDimensions, isVwm) {\r\n\r\n        frameDimensions = frameDimensions || getFrameDimensions();\r\n        isVwm = isVwm || isVerticalWritingMode();\r\n\r\n        //Text nodes without printable text dont have client rectangles\r\n        if (!rect) {\r\n            return false;\r\n        }\r\n        //Sometimes we get client rects that are \"empty\" and aren't supposed to be visible\r\n        if (rect.left == 0 && rect.right == 0 && rect.top == 0 && rect.bottom == 0) {\r\n            return false;\r\n        }\r\n\r\n        if (isPaginatedView()) {\r\n            return (rect.left >= 0 && rect.left < frameDimensions.width) || \r\n                (!ignorePartiallyVisible && rect.left < 0 && rect.right >= 0);\r\n        } else {\r\n            return (rect.top >= 0 && rect.top < frameDimensions.height) || \r\n                (!ignorePartiallyVisible && rect.top < 0 && rect.bottom >= 0);\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * Retrieves _current_ full width of a column (including its gap)\r\n     *\r\n     * @returns {number} Full width of a column in pixels\r\n     */\r\n    function getColumnFullWidth() {\r\n\r\n        if (!options.paginationInfo || isVerticalWritingMode())\r\n        {\r\n            return options.$iframe.width();\r\n        }\r\n\r\n        return options.paginationInfo.columnWidth + options.paginationInfo.columnGap;\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     *\r\n     * Retrieves _current_ offset of a viewport\r\n     * (related to the beginning of the chapter)\r\n     *\r\n     * @returns {Object}\r\n     */\r\n    function getVisibleContentOffsets() {\r\n        if (options.visibleContentOffsets) {\r\n            return options.visibleContentOffsets();\r\n        }\r\n\r\n        if (isVerticalWritingMode()) {\r\n            return {\r\n                top: (options.paginationInfo ? options.paginationInfo.pageOffset : 0),\r\n                left: 0\r\n            };\r\n        }\r\n\r\n        return {\r\n            top: 0,\r\n            left: 0\r\n        };\r\n    }\r\n\r\n    /**\r\n     * New (rectangle-based) algorithm, useful in multi-column layouts\r\n     *\r\n     * Note: the second param (props) is ignored intentionally\r\n     * (no need to use those in normalization)\r\n     *\r\n     * @param {jQuery} $element\r\n     * @param {Object} _props\r\n     * @param {boolean} shouldCalculateVisibilityPercentage\r\n     * @param {Object} [frameDimensions]\r\n     * @returns {number|null}\r\n     *      0 for non-visible elements,\r\n     *      0 < n <= 100 for visible elements\r\n     *      (will just give 100, if `shouldCalculateVisibilityPercentage` => false)\r\n     *      null for elements with display:none\r\n     */\r\n    function checkVisibilityByRectangles($element, shouldCalculateVisibilityPercentage, visibleContentOffsets, frameDimensions) {\r\n        visibleContentOffsets = visibleContentOffsets || getVisibleContentOffsets();\r\n        frameDimensions = frameDimensions || getFrameDimensions();\r\n\r\n        var clientRectangles = getNormalizedRectangles($element, visibleContentOffsets);\r\n        if (clientRectangles.length === 0) { // elements with display:none, etc.\r\n            return null;\r\n        }\r\n\r\n        var visibilityPercentage = 0;\r\n\r\n        if (clientRectangles.length === 1) {\r\n            var adjustedRect = clientRectangles[0];\r\n            \r\n            if (isPaginatedView()) {\r\n                if (adjustedRect.bottom > frameDimensions.height || adjustedRect.top < 0) {\r\n                    // because of webkit inconsistency, that single rectangle should be adjusted\r\n                    // until it hits the end OR will be based on the FIRST column that is visible\r\n                    adjustRectangle(adjustedRect, true, frameDimensions);\r\n                }\r\n            }\r\n\r\n            if (isRectVisible(adjustedRect, false, frameDimensions)) {\r\n                //it might still be partially visible in webkit\r\n                if (shouldCalculateVisibilityPercentage && adjustedRect.top < 0) {\r\n                    visibilityPercentage =\r\n                        Math.floor(100 * (adjustedRect.height + adjustedRect.top) / adjustedRect.height);\r\n                } else {\r\n                    visibilityPercentage = 100;\r\n                }\r\n            }\r\n        } else {\r\n            // for an element split between several CSS columns,z\r\n            // both Firefox and IE produce as many client rectangles;\r\n            // each of those should be checked\r\n            for (var i = 0, l = clientRectangles.length; i < l; ++i) {\r\n                if (isRectVisible(clientRectangles[i], false, frameDimensions)) {\r\n                    visibilityPercentage = shouldCalculateVisibilityPercentage\r\n                        ? measureVisibilityPercentageByRectangles(clientRectangles, i)\r\n                        : 100;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        return visibilityPercentage;\r\n    }\r\n\r\n    /**\r\n     * Finds a page index (0-based) for a specific element.\r\n     * Calculations are based on rectangles retrieved with getClientRects() method.\r\n     *\r\n     * @param {jQuery} $element\r\n     * @param {number} spatialVerticalOffset\r\n     * @returns {number|null}\r\n     */\r\n    function findPageByRectangles($element, spatialVerticalOffset) {\r\n\r\n        var visibleContentOffsets = getVisibleContentOffsets();\r\n\r\n        var clientRectangles = getNormalizedRectangles($element, visibleContentOffsets);\r\n        if (clientRectangles.length === 0) { // elements with display:none, etc.\r\n            return null;\r\n        }\r\n\r\n        return calculatePageIndexByRectangles(clientRectangles, spatialVerticalOffset);\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * Calculate a page index (0-based) for given client rectangles.\r\n     *\r\n     * @param {object} clientRectangles\r\n     * @param {number} [spatialVerticalOffset]\r\n     * @param {object} [frameDimensions]\r\n     * @param {object} [columnFullWidth]\r\n     * @returns {number|null}\r\n     */\r\n    function calculatePageIndexByRectangles(clientRectangles, spatialVerticalOffset, frameDimensions, columnFullWidth) {\r\n        var isRtl = isPageProgressionRightToLeft();\r\n        var isVwm = isVerticalWritingMode();\r\n        columnFullWidth = columnFullWidth || getColumnFullWidth();\r\n        frameDimensions = frameDimensions || getFrameDimensions();\r\n\r\n        if (spatialVerticalOffset) {\r\n            trimRectanglesByVertOffset(clientRectangles, spatialVerticalOffset,\r\n                frameDimensions, columnFullWidth, isRtl, isVwm);\r\n        }\r\n\r\n        var firstRectangle = _.first(clientRectangles);\r\n        if (clientRectangles.length === 1) {\r\n            adjustRectangle(firstRectangle, false, frameDimensions, columnFullWidth, isRtl, isVwm);\r\n        }\r\n\r\n        var pageIndex;\r\n\r\n        if (isVwm) {\r\n            var topOffset = firstRectangle.top;\r\n            pageIndex = Math.floor(topOffset / frameDimensions.height);\r\n        } else {\r\n            var leftOffset = firstRectangle.left;\r\n            if (isRtl) {\r\n                leftOffset = (columnFullWidth * (options.paginationInfo ? options.paginationInfo.visibleColumnCount : 1)) - leftOffset;\r\n            }\r\n            pageIndex = Math.floor(leftOffset / columnFullWidth);\r\n        }\r\n\r\n        if (pageIndex < 0) {\r\n            pageIndex = 0;\r\n        }\r\n        else if (pageIndex >= (options.paginationInfo ? options.paginationInfo.columnCount : 1)) {\r\n            pageIndex = (options.paginationInfo ? (options.paginationInfo.columnCount - 1) : 0);\r\n        }\r\n\r\n        return pageIndex;\r\n    }\r\n\r\n    /**\r\n     * Finds a page index (0-based) for a specific client rectangle.\r\n     * Calculations are based on viewport dimensions, offsets, and rectangle coordinates\r\n     *\r\n     * @param {ClientRect} clientRectangle\r\n     * @param {Object} [visibleContentOffsets]\r\n     * @param {Object} [frameDimensions]\r\n     * @returns {number|null}\r\n     */\r\n    function findPageBySingleRectangle(clientRectangle, visibleContentOffsets, frameDimensions) {\r\n        visibleContentOffsets = visibleContentOffsets || getVisibleContentOffsets();\r\n        frameDimensions = frameDimensions || getFrameDimensions();\r\n        \r\n        var normalizedRectangle = normalizeRectangle(\r\n            clientRectangle, visibleContentOffsets.left, visibleContentOffsets.top);\r\n\r\n        return calculatePageIndexByRectangles([normalizedRectangle], frameDimensions);\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * Calculates the visibility offset percentage based on ClientRect dimensions\r\n     *\r\n     * @param {Array} clientRectangles (should already be normalized)\r\n     * @param {number} firstVisibleRectIndex\r\n     * @returns {number} - visibility percentage (0 < n <= 100)\r\n     */\r\n    function measureVisibilityPercentageByRectangles(clientRectangles, firstVisibleRectIndex) {\r\n\r\n        var heightTotal = 0;\r\n        var heightVisible = 0;\r\n\r\n        if (clientRectangles.length > 1) {\r\n            _.each(clientRectangles, function (rect, index) {\r\n                heightTotal += rect.height;\r\n                if (index >= firstVisibleRectIndex) {\r\n                    // in this case, all the rectangles after the first visible\r\n                    // should be counted as visible\r\n                    heightVisible += rect.height;\r\n                }\r\n            });\r\n        }\r\n        else {\r\n            // should already be normalized and adjusted\r\n            heightTotal = clientRectangles[0].height;\r\n            heightVisible = clientRectangles[0].height - Math.max(\r\n                0, -clientRectangles[0].top);\r\n        }\r\n        return heightVisible === heightTotal\r\n            ? 100 // trivial case: element is 100% visible\r\n            : Math.floor(100 * heightVisible / heightTotal);\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * Retrieves the position of $element in multi-column layout\r\n     *\r\n     * @param {jQuery} $el\r\n     * @param {Object} [visibleContentOffsets]\r\n     * @returns {Object}\r\n     */\r\n    function getNormalizedRectangles($el, visibleContentOffsets) {\r\n\r\n        visibleContentOffsets = visibleContentOffsets || {};\r\n        var leftOffset = visibleContentOffsets.left || 0;\r\n        var topOffset = visibleContentOffsets.top || 0;\r\n\r\n        var isTextNode = ($el[0].nodeType === Node.TEXT_NODE);\r\n        var clientRectList;\r\n\r\n        if (isTextNode) {\r\n            var range = createRange();\r\n            range.selectNode($el[0]);\r\n            clientRectList = range.getClientRects();\r\n        } else {\r\n            clientRectList = $el[0].getClientRects();\r\n        }\r\n\r\n        // all the separate rectangles (for detecting position of the element\r\n        // split between several columns)\r\n        var clientRectangles = [];\r\n        for (var i = 0, l = clientRectList.length; i < l; ++i) {\r\n            if (clientRectList[i].height > 0) {\r\n                // Firefox sometimes gets it wrong,\r\n                // adding literally empty (height = 0) client rectangle preceding the real one,\r\n                // that empty client rectanle shouldn't be retrieved\r\n                clientRectangles.push(\r\n                    normalizeRectangle(clientRectList[i], leftOffset, topOffset));\r\n            }\r\n        }\r\n\r\n        return clientRectangles;\r\n    }\r\n\r\n    function getNormalizedBoundingRect($el, visibleContentOffsets) {\r\n        visibleContentOffsets = visibleContentOffsets || {};\r\n        var leftOffset = visibleContentOffsets.left || 0;\r\n        var topOffset = visibleContentOffsets.top || 0;\r\n\r\n        var isTextNode = ($el[0].nodeType === Node.TEXT_NODE);\r\n        var boundingClientRect;\r\n\r\n        if (isTextNode) {\r\n            var range = createRange();\r\n            range.selectNode($el[0]);\r\n            boundingClientRect = range.getBoundingClientRect();\r\n        } else {\r\n            boundingClientRect = $el[0].getBoundingClientRect();\r\n        }\r\n\r\n        // union of all rectangles wrapping the element\r\n        return normalizeRectangle(boundingClientRect, leftOffset, topOffset);\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * Converts TextRectangle object into a plain object,\r\n     * taking content offsets (=scrolls, position shifts etc.) into account\r\n     *\r\n     * @param {TextRectangle} textRect\r\n     * @param {number} leftOffset\r\n     * @param {number} topOffset\r\n     * @returns {Object}\r\n     */\r\n    function normalizeRectangle(textRect, leftOffset, topOffset) {\r\n\r\n        var plainRectObject = {\r\n            left: textRect.left,\r\n            right: textRect.right,\r\n            top: textRect.top,\r\n            bottom: textRect.bottom,\r\n            width: textRect.right - textRect.left,\r\n            height: textRect.bottom - textRect.top\r\n        };\r\n        offsetRectangle(plainRectObject, leftOffset, topOffset);\r\n        return plainRectObject;\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * Offsets plain object (which represents a TextRectangle).\r\n     *\r\n     * @param {Object} rect\r\n     * @param {number} leftOffset\r\n     * @param {number} topOffset\r\n     */\r\n    function offsetRectangle(rect, leftOffset, topOffset) {\r\n\r\n        rect.left += leftOffset;\r\n        rect.right += leftOffset;\r\n        rect.top += topOffset;\r\n        rect.bottom += topOffset;\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     *\r\n     * When element is spilled over two or more columns,\r\n     * most of the time Webkit-based browsers\r\n     * still assign a single clientRectangle to it, setting its `top` property to negative value\r\n     * (so it looks like it's rendered based on the second column)\r\n     * Alas, sometimes they decide to continue the leftmost column - from _below_ its real height.\r\n     * In this case, `bottom` property is actually greater than element's height and had to be adjusted accordingly.\r\n     *\r\n     * Ugh.\r\n     *\r\n     * @param {Object} rect\r\n     * @param {boolean} [shouldLookForFirstVisibleColumn]\r\n     *      If set, there'll be two-phase adjustment\r\n     *      (to align a rectangle with a viewport)\r\n     * @param {Object} [frameDimensions]\r\n     * @param {number} [columnFullWidth]\r\n     * @param {boolean} [isRtl]\r\n     * @param {boolean} [isVwm]               isVerticalWritingMode\r\n     */\r\n    function adjustRectangle(rect, shouldLookForFirstVisibleColumn, frameDimensions, columnFullWidth, isRtl, isVwm) {\r\n\r\n        frameDimensions = frameDimensions || getFrameDimensions();\r\n        columnFullWidth = columnFullWidth || getColumnFullWidth();\r\n        isRtl = isRtl || isPageProgressionRightToLeft();\r\n        isVwm = isVwm || isVerticalWritingMode();\r\n\r\n        // Rectangle adjustment is not needed in VWM since it does not deal with columns\r\n        if (isVwm) {\r\n            return;\r\n        }\r\n\r\n        if (isRtl) {\r\n            columnFullWidth *= -1; // horizontal shifts are reverted in RTL mode\r\n        }\r\n\r\n        // first we go left/right (rebasing onto the very first column available)\r\n        while (rect.top < 0) {\r\n            offsetRectangle(rect, -columnFullWidth, frameDimensions.height);\r\n        }\r\n\r\n        // ... then, if necessary (for visibility offset checks),\r\n        // each column is tried again (now in reverse order)\r\n        // the loop will be stopped when the column is aligned with a viewport\r\n        // (i.e., is the first visible one).\r\n        if (shouldLookForFirstVisibleColumn) {\r\n            while (rect.bottom >= frameDimensions.height) {\r\n                if (isRectVisible(rect, false, frameDimensions, isVwm)) {\r\n                    break;\r\n                }\r\n                offsetRectangle(rect, columnFullWidth, -frameDimensions.height);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * Trims the rectangle(s) representing the given element.\r\n     *\r\n     * @param {Array} rects\r\n     * @param {number} verticalOffset\r\n     * @param {number} frameDimensions\r\n     * @param {number} columnFullWidth\r\n     * @param {boolean} isRtl\r\n     * @param {boolean} isVwm               isVerticalWritingMode\r\n     */\r\n    function trimRectanglesByVertOffset(\r\n            rects, verticalOffset, frameDimensions, columnFullWidth, isRtl, isVwm) {\r\n\r\n        frameDimensions = frameDimensions || getFrameDimensions();\r\n        columnFullWidth = columnFullWidth || getColumnFullWidth();\r\n        isRtl = isRtl || isPageProgressionRightToLeft();\r\n        isVwm = isVwm || isVerticalWritingMode();\r\n\r\n        //TODO: Support vertical writing mode\r\n        if (isVwm) {\r\n            return;\r\n        }\r\n\r\n        var totalHeight = _.reduce(rects, function(prev, cur) {\r\n            return prev + cur.height;\r\n        }, 0);\r\n\r\n        var heightToHide = totalHeight * verticalOffset / 100;\r\n        if (rects.length > 1) {\r\n            var heightAccum = 0;\r\n            do {\r\n                heightAccum += rects[0].height;\r\n                if (heightAccum > heightToHide) {\r\n                    break;\r\n                }\r\n                rects.shift();\r\n            } while (rects.length > 1);\r\n        }\r\n        else {\r\n            // rebase to the last possible column\r\n            // (so that adding to top will be properly processed later)\r\n            if (isRtl) {\r\n                columnFullWidth *= -1;\r\n            }\r\n            while (rects[0].bottom >= frameDimensions.height) {\r\n                offsetRectangle(rects[0], columnFullWidth, -frameDimensions.height);\r\n            }\r\n\r\n            rects[0].top += heightToHide;\r\n            rects[0].height -= heightToHide;\r\n        }\r\n    }\r\n\r\n    this.getCfiForElement = function (element) {\r\n        var cfi = EPUBcfi.Generator.generateElementCFIComponent(element,\r\n            this.getClassBlacklist(),\r\n            this.getElementBlacklist(),\r\n            this.getIdBlacklist());\r\n\r\n        if (cfi[0] == \"!\") {\r\n            cfi = cfi.substring(1);\r\n        }\r\n        return cfi;\r\n    };\r\n\r\n    this.getVisibleCfiFromPoint = function (x, y, precisePoint) {\r\n        var document = self.getRootDocument();\r\n        var firstVisibleCaretRange = getCaretRangeFromPoint(x, y, document);\r\n        var elementFromPoint = document.elementFromPoint(x, y);\r\n        var invalidElementFromPoint = !elementFromPoint || elementFromPoint === document.documentElement;\r\n\r\n        if (precisePoint) {\r\n            if (!elementFromPoint || invalidElementFromPoint) {\r\n                return null;\r\n            }\r\n            var testRect = getNodeContentsClientRect(elementFromPoint);\r\n            if (!isRectVisible(testRect, false)) {\r\n                return null;\r\n            }\r\n            if ((x < testRect.left || x > testRect.right) || (y < testRect.top || y > testRect.bottom)) {\r\n                return null;\r\n            }\r\n        }\r\n\r\n        if (!firstVisibleCaretRange) {\r\n            if (invalidElementFromPoint) {\r\n                console.error(\"Could not generate CFI no visible element on page\");\r\n                return null;\r\n            }\r\n            firstVisibleCaretRange = createRange();\r\n            firstVisibleCaretRange.selectNode(elementFromPoint);\r\n        }\r\n\r\n        var range = firstVisibleCaretRange;\r\n        var cfi;\r\n        //if we get a text node we need to get an approximate range for the first visible character offsets.\r\n        var node = range.startContainer;\r\n        var startOffset, endOffset;\r\n        if (node.nodeType === Node.TEXT_NODE) {\r\n            if (precisePoint && node.parentNode !== elementFromPoint) {\r\n                return null;\r\n            }\r\n            if (node.length === 1 && range.startOffset === 1) {\r\n                startOffset = 0;\r\n                endOffset = 1;\r\n            } else if (range.startOffset === node.length) {\r\n                startOffset = range.startOffset - 1;\r\n                endOffset = range.startOffset;\r\n            } else {\r\n                startOffset = range.startOffset;\r\n                endOffset = range.startOffset + 1;\r\n            }\r\n            var wrappedRange = {\r\n                startContainer: node,\r\n                endContainer: node,\r\n                startOffset: startOffset,\r\n                endOffset: endOffset,\r\n                commonAncestorContainer: range.commonAncestorContainer\r\n            };\r\n\r\n            if (debugMode) {\r\n                drawDebugOverlayFromDomRange(wrappedRange);\r\n            }\r\n\r\n            cfi = generateCfiFromDomRange(wrappedRange);\r\n        } else if (node.nodeType === Node.ELEMENT_NODE) {\r\n            node =\r\n                range.startContainer.childNodes[range.startOffset] ||\r\n                range.startContainer.childNodes[0] ||\r\n                range.startContainer;\r\n            if (precisePoint && node !== elementFromPoint) {\r\n                return null;\r\n            }\r\n\r\n            if (node.nodeType !== Node.ELEMENT_NODE) {\r\n                cfi = generateCfiFromDomRange(range);\r\n            } else {\r\n                cfi = self.getCfiForElement(node);\r\n            }\r\n        } else {\r\n            if (precisePoint && node !== elementFromPoint) {\r\n                return null;\r\n            }\r\n\r\n            cfi = self.getCfiForElement(elementFromPoint);\r\n        }\r\n\r\n        //This should not happen but if it does print some output, just in case\r\n        if (cfi && cfi.indexOf('NaN') !== -1) {\r\n            console.log('Did not generate a valid CFI:' + cfi);\r\n            return undefined;\r\n        }\r\n\r\n        return cfi;\r\n    };\r\n\r\n    this.getRangeCfiFromPoints = function(startX, startY, endX, endY) {\r\n        var document = self.getRootDocument();\r\n        var start = getCaretRangeFromPoint(startX, startY, document),\r\n            end = getCaretRangeFromPoint(endX, endY, document),\r\n            range = createRange();\r\n        range.setStart(start.startContainer, start.startOffset);\r\n        range.setEnd(end.startContainer, end.startOffset);\r\n        // if we're looking at a text node create a nice range (n, n+1)\r\n        if (start.startContainer === start.endContainer && start.startContainer.nodeType === Node.TEXT_NODE && end.startContainer.length > end.startOffset+1) {\r\n            range.setEnd(end.startContainer, end.startOffset+1);\r\n        }\r\n        return generateCfiFromDomRange(range);\r\n    };\r\n\r\n    function getTextNodeRectCornerPairs(rect) {\r\n        //\r\n        //    top left             top right\r\n        //    ╲                   ╱\r\n        //  ── ▒T▒E▒X▒T▒ ▒R▒E▒C▒T▒ ──\r\n        //\r\n        // top left corner & top right corner\r\n        // but for y coord use the mid point between top and bottom\r\n\r\n        if (isVerticalWritingMode()) {\r\n            var x = rect.right - (rect.width / 2);\r\n            return [{x: x, y: rect.top}, {x: x, y: rect.bottom}];\r\n        } else {\r\n            var y = rect.top + (rect.height / 2);\r\n            var result = [{x: rect.left, y: y}, {x: rect.right, y: y}]\r\n            return isPageProgressionRightToLeft() ? result.reverse() : result;\r\n        }\r\n    }\r\n\r\n    var DEBUG = false;\r\n\r\n    function getVisibleTextRangeOffsetsSelectedByFunc(textNode, pickerFunc, visibleContentOffsets, frameDimensions) {\r\n        visibleContentOffsets = visibleContentOffsets || getVisibleContentOffsets();\r\n        \r\n        var textNodeFragments = getNodeClientRectList(textNode, visibleContentOffsets);\r\n\r\n        var visibleFragments = _.filter(textNodeFragments, function (rect) {\r\n            return isRectVisible(rect, false, frameDimensions);\r\n        });\r\n\r\n        var fragment = pickerFunc(visibleFragments);\r\n        if (!fragment) {\r\n            //no visible fragment, empty text node?\r\n            return null;\r\n        }\r\n        var fragmentCorner = pickerFunc(getTextNodeRectCornerPairs(fragment));\r\n        // Reverse taking into account of visible content offsets\r\n        fragmentCorner.x -= visibleContentOffsets.left;\r\n        fragmentCorner.y -= visibleContentOffsets.top;\r\n        \r\n        var caretRange = getCaretRangeFromPoint(fragmentCorner.x, fragmentCorner.y);\r\n\r\n        // Workaround for inconsistencies with the caretRangeFromPoint IE TextRange based shim.\r\n        if (caretRange && caretRange.startContainer !== textNode && caretRange.startContainer === textNode.parentNode) {\r\n            if (DEBUG) console.log('ieTextRangeWorkaround needed');\r\n            var startOrEnd = pickerFunc([0, 1]);\r\n\r\n            // #1\r\n            if (caretRange.startOffset === caretRange.endOffset) {\r\n                var checkNode = caretRange.startContainer.childNodes[Math.max(caretRange.startOffset - 1, 0)];\r\n                if (checkNode === textNode) {\r\n                    caretRange = {\r\n                        startContainer: textNode,\r\n                        endContainer: textNode,\r\n                        startOffset: startOrEnd === 0 ? 0 : textNode.nodeValue.length,\r\n                        startOffset: startOrEnd === 0 ? 0 : textNode.nodeValue.length\r\n                    };\r\n                    if (DEBUG) console.log('ieTextRangeWorkaround #1:', caretRange);\r\n                }\r\n            }\r\n\r\n            // Failed\r\n            else if (DEBUG) {\r\n                console.log('ieTextRangeWorkaround didn\\'t work :(');\r\n            }\r\n        }\r\n\r\n        if (DEBUG)\r\n        console.log('getVisibleTextRangeOffsetsSelectedByFunc: ', 'a0');\r\n        \r\n        // Desperately try to find it from all angles! Darn sub pixeling..\r\n        //TODO: remove the need for this brute-force method, since it's making the result non-deterministic\r\n        if (!caretRange || caretRange.startContainer !== textNode) {\r\n            caretRange = getCaretRangeFromPoint(fragmentCorner.x - 1, fragmentCorner.y);\r\n            \r\n            if (DEBUG)\r\n            console.log('getVisibleTextRangeOffsetsSelectedByFunc: ', 'a1');\r\n        }\r\n        if (!caretRange || caretRange.startContainer !== textNode) {\r\n            caretRange = getCaretRangeFromPoint(fragmentCorner.x, fragmentCorner.y - 1);\r\n            \r\n            if (DEBUG)\r\n            console.log('getVisibleTextRangeOffsetsSelectedByFunc: ', 'a2');\r\n        }\r\n        if (!caretRange || caretRange.startContainer !== textNode) {\r\n            caretRange = getCaretRangeFromPoint(fragmentCorner.x - 1, fragmentCorner.y - 1);\r\n            \r\n            if (DEBUG)\r\n            console.log('getVisibleTextRangeOffsetsSelectedByFunc: ', 'a3');\r\n        }\r\n        if (!caretRange || caretRange.startContainer !== textNode) {\r\n            fragmentCorner.x = Math.floor(fragmentCorner.x);\r\n            fragmentCorner.y = Math.floor(fragmentCorner.y);\r\n            caretRange = getCaretRangeFromPoint(fragmentCorner.x, fragmentCorner.y);\r\n            \r\n            if (DEBUG)\r\n            console.log('getVisibleTextRangeOffsetsSelectedByFunc: ', 'b0');\r\n        }\r\n        // Desperately try to find it from all angles! Darn sub pixeling..\r\n        if (!caretRange || caretRange.startContainer !== textNode) {\r\n            caretRange = getCaretRangeFromPoint(fragmentCorner.x - 1, fragmentCorner.y);\r\n            \r\n            if (DEBUG)\r\n            console.log('getVisibleTextRangeOffsetsSelectedByFunc: ', 'b1');\r\n        }\r\n        if (!caretRange || caretRange.startContainer !== textNode) {\r\n            caretRange = getCaretRangeFromPoint(fragmentCorner.x, fragmentCorner.y - 1);\r\n            \r\n            if (DEBUG)\r\n            console.log('getVisibleTextRangeOffsetsSelectedByFunc: ', 'b2');\r\n        }\r\n        if (!caretRange || caretRange.startContainer !== textNode) {\r\n            caretRange = getCaretRangeFromPoint(fragmentCorner.x - 1, fragmentCorner.y - 1);\r\n            \r\n            if (DEBUG)\r\n            console.log('getVisibleTextRangeOffsetsSelectedByFunc: ', 'b3');\r\n        }\r\n\r\n        // Still nothing? fall through..\r\n        if (!caretRange) {\r\n            \r\n            if (DEBUG)\r\n            console.warn('getVisibleTextRangeOffsetsSelectedByFunc: no caret range result');\r\n            \r\n            return null;\r\n        }\r\n\r\n        if (caretRange.startContainer === textNode) {\r\n            return pickerFunc(\r\n                [{start: caretRange.startOffset, end: caretRange.startOffset + 1},\r\n                {start: caretRange.startOffset - 1, end: caretRange.startOffset}]\r\n            );\r\n        } else {\r\n            \r\n            if (DEBUG)\r\n            console.warn('getVisibleTextRangeOffsetsSelectedByFunc: incorrect caret range result');\r\n            \r\n            return null;\r\n        }\r\n    }\r\n\r\n    function findVisibleLeafNodeCfi(leafNodeList, pickerFunc, targetLeafNode, visibleContentOffsets, frameDimensions, startingParent) {\r\n        var index = 0;\r\n        if (!targetLeafNode) {\r\n            index = leafNodeList.indexOf(pickerFunc(leafNodeList));\r\n            var leafNode = leafNodeList[index];\r\n            if (leafNode) {\r\n                startingParent = leafNode.element;\r\n            }\r\n        } else {\r\n            index = leafNodeList.indexOf(targetLeafNode);\r\n            if (index === -1) {\r\n                //target leaf node not the right type? not in list?\r\n                return null;\r\n            }\r\n            // use the next leaf node in the list\r\n            index += pickerFunc([1, -1]);\r\n        }\r\n        var visibleLeafNode = leafNodeList[index];\r\n\r\n        if (!visibleLeafNode) {\r\n            return null;\r\n        }\r\n\r\n        var element = visibleLeafNode.element;\r\n        var textNode = visibleLeafNode.textNode;\r\n\r\n        if (targetLeafNode && element !== startingParent && !_.contains($(textNode || element).parents(), startingParent)) {\r\n            if (DEBUG) console.warn(\"findVisibleLeafNodeCfi: stopped recursion early\");\r\n            return null;\r\n        }\r\n\r\n        //if a valid text node is found, try to generate a CFI with range offsets\r\n        if (textNode && isValidTextNode(textNode)) {\r\n            var visibleRange = getVisibleTextRangeOffsetsSelectedByFunc(textNode, pickerFunc, visibleContentOffsets, frameDimensions);\r\n            if (!visibleRange) {\r\n                //the text node is valid, but not visible..\r\n                //let's try again with the next node in the list\r\n                return findVisibleLeafNodeCfi(leafNodeList, pickerFunc, visibleLeafNode, visibleContentOffsets, frameDimensions, startingParent);\r\n            }\r\n            var range = createRange();\r\n            range.setStart(textNode, visibleRange.start);\r\n            range.setEnd(textNode, visibleRange.end);\r\n            return generateCfiFromDomRange(range);\r\n        } else {\r\n            //if not then generate a CFI for the element\r\n            return self.getCfiForElement(element);\r\n        }\r\n    }\r\n\r\n    // get an array of visible text elements and then select one based on the func supplied\r\n    // and generate a CFI for the first visible text subrange.\r\n    function getVisibleTextRangeCfiForTextElementSelectedByFunc(pickerFunc, visibleContentOffsets, frameDimensions) {        \r\n        var visibleLeafNodeList = self.getVisibleLeafNodes(visibleContentOffsets, frameDimensions);\r\n        return findVisibleLeafNodeCfi(visibleLeafNodeList, pickerFunc, null, visibleContentOffsets, frameDimensions);\r\n    }\r\n\r\n    function getLastVisibleTextRangeCfi(visibleContentOffsets, frameDimensions) {\r\n        return getVisibleTextRangeCfiForTextElementSelectedByFunc(_.last, visibleContentOffsets, frameDimensions);\r\n    }\r\n\r\n    function getFirstVisibleTextRangeCfi(visibleContentOffsets, frameDimensions) {\r\n        return getVisibleTextRangeCfiForTextElementSelectedByFunc(_.first, visibleContentOffsets, frameDimensions);\r\n    }\r\n\r\n    this.getFirstVisibleCfi = function (visibleContentOffsets, frameDimensions) {\r\n        return getFirstVisibleTextRangeCfi(visibleContentOffsets, frameDimensions);\r\n    };\r\n\r\n    this.getLastVisibleCfi = function (visibleContentOffsets, frameDimensions) {\r\n        return getLastVisibleTextRangeCfi(visibleContentOffsets, frameDimensions);\r\n    };\r\n\r\n    function generateCfiFromDomRange(range) {\r\n        return EPUBcfi.generateRangeComponent(\r\n            range.startContainer, range.startOffset,\r\n            range.endContainer, range.endOffset,\r\n            self.getClassBlacklist(), self.getElementBlacklist(), self.getIdBlacklist());\r\n    }\r\n\r\n    function getRangeTargetNodes(rangeCfi) {\r\n        return EPUBcfi.getRangeTargetElements(\r\n            getWrappedCfiRelativeToContent(rangeCfi),\r\n            self.getRootDocument(),\r\n            self.getClassBlacklist(), self.getElementBlacklist(), self.getIdBlacklist());\r\n    }\r\n\r\n    this.getDomRangeFromRangeCfi = function(rangeCfi, rangeCfi2, inclusive) {\r\n        var range = createRange();\r\n\r\n        if (!rangeCfi2) {\r\n            if (self.isRangeCfi(rangeCfi)) {\r\n                var rangeInfo = getRangeTargetNodes(rangeCfi);\r\n                range.setStart(rangeInfo.startElement, rangeInfo.startOffset);\r\n                range.setEnd(rangeInfo.endElement, rangeInfo.endOffset);\r\n            } else {\r\n                var element = self.getElementByCfi(rangeCfi,\r\n                    this.getClassBlacklist(), this.getElementBlacklist(), this.getIdBlacklist())[0];\r\n                range.selectNode(element);\r\n            }\r\n        } else {\r\n            if (self.isRangeCfi(rangeCfi)) {\r\n                var rangeInfo1 = getRangeTargetNodes(rangeCfi);\r\n                range.setStart(rangeInfo1.startElement, rangeInfo1.startOffset);\r\n            } else {\r\n                var startElement = self.getElementByCfi(rangeCfi,\r\n                    this.getClassBlacklist(), this.getElementBlacklist(), this.getIdBlacklist())[0];\r\n                range.setStart(startElement, 0);\r\n            }\r\n\r\n            if (self.isRangeCfi(rangeCfi2)) {\r\n                var rangeInfo2 = getRangeTargetNodes(rangeCfi2);\r\n                if (inclusive) {\r\n                    range.setEnd(rangeInfo2.endElement, rangeInfo2.endOffset);\r\n                } else {\r\n                    range.setEnd(rangeInfo2.startElement, rangeInfo2.startOffset);\r\n                }\r\n            } else {\r\n                var endElement = self.getElementByCfi(rangeCfi2,\r\n                    this.getClassBlacklist(), this.getElementBlacklist(), this.getIdBlacklist())[0];\r\n                range.setEnd(endElement, endElement.childNodes.length);\r\n            }\r\n        }\r\n        return range;\r\n    };\r\n\r\n    this.getRangeCfiFromDomRange = function(domRange) {\r\n        return generateCfiFromDomRange(domRange);\r\n    };\r\n\r\n    function getWrappedCfi(partialCfi) {\r\n        return \"epubcfi(\" + partialCfi + \")\";\r\n    }\r\n\r\n    function getWrappedCfiRelativeToContent(partialCfi) {\r\n        return \"epubcfi(/99!\" + partialCfi + \")\";\r\n    }\r\n\r\n    this.isRangeCfi = function (partialCfi) {\r\n        return EPUBcfi.Interpreter.isRangeCfi(getWrappedCfi(partialCfi)) || EPUBcfi.Interpreter.isRangeCfi(getWrappedCfiRelativeToContent(partialCfi));\r\n    };\r\n\r\n    this.getPageForElementCfi = function (cfi, classBlacklist, elementBlacklist, idBlacklist) {\r\n\r\n        var cfiParts = splitCfi(cfi);\r\n        var partialCfi = cfiParts.cfi;\r\n\r\n        if (this.isRangeCfi(partialCfi)) {\r\n            //if given a range cfi the exact page index needs to be calculated by getting node info from the range cfi\r\n            var nodeRangeInfoFromCfi = this.getNodeRangeInfoFromCfi(partialCfi);\r\n            //the page index is calculated from the node's client rectangle\r\n            return findPageBySingleRectangle(nodeRangeInfoFromCfi.clientRect);\r\n        }\r\n\r\n        var $element = getElementByPartialCfi(cfiParts.cfi, classBlacklist, elementBlacklist, idBlacklist);\r\n\r\n        if (!$element) {\r\n            return -1;\r\n        }\r\n\r\n        var pageIndex = this.getPageForPointOnElement($element, cfiParts.x, cfiParts.y);\r\n\r\n        return pageIndex;\r\n\r\n    };\r\n\r\n    function getElementByPartialCfi(cfi, classBlacklist, elementBlacklist, idBlacklist) {\r\n\r\n        var contentDoc = self.getRootDocument();\r\n\r\n        var wrappedCfi = getWrappedCfi(cfi);\r\n\r\n        try {\r\n            //noinspection JSUnresolvedVariable\r\n            var $element = EPUBcfi.getTargetElementWithPartialCFI(wrappedCfi, contentDoc, classBlacklist, elementBlacklist, idBlacklist);\r\n\r\n        } catch (ex) {\r\n            //EPUBcfi.Interpreter can throw a SyntaxError\r\n        }\r\n\r\n        if (!$element || $element.length == 0) {\r\n            console.log(\"Can't find element for CFI: \" + cfi);\r\n            return undefined;\r\n        }\r\n\r\n        return $element;\r\n    }\r\n\r\n    this.getElementFromPoint = function (x, y) {\r\n\r\n        var document = self.getRootDocument();\r\n        return document.elementFromPoint(x, y);\r\n    };\r\n\r\n    this.getNodeRangeInfoFromCfi = function (cfi) {\r\n        var contentDoc = self.getRootDocument();\r\n        if (self.isRangeCfi(cfi)) {\r\n            var wrappedCfi = getWrappedCfiRelativeToContent(cfi);\r\n\r\n            try {\r\n                //noinspection JSUnresolvedVariable\r\n                var nodeResult = EPUBcfi.Interpreter.getRangeTargetElements(wrappedCfi, contentDoc,\r\n                    this.getClassBlacklist(),\r\n                    this.getElementBlacklist(),\r\n                    this.getIdBlacklist());\r\n\r\n                if (debugMode) {\r\n                    console.log(nodeResult);\r\n                }\r\n            } catch (ex) {\r\n                //EPUBcfi.Interpreter can throw a SyntaxError\r\n            }\r\n\r\n            if (!nodeResult) {\r\n                console.log(\"Can't find nodes for range CFI: \" + cfi);\r\n                return undefined;\r\n            }\r\n\r\n            var startRangeInfo = {node: nodeResult.startElement, offset: nodeResult.startOffset};\r\n            var endRangeInfo = {node: nodeResult.endElement, offset: nodeResult.endOffset};\r\n            var nodeRangeClientRect =\r\n                startRangeInfo && endRangeInfo ?\r\n                    getNodeRangeClientRect(\r\n                        startRangeInfo.node,\r\n                        startRangeInfo.offset,\r\n                        endRangeInfo.node,\r\n                        endRangeInfo.offset)\r\n                    : null;\r\n\r\n            if (debugMode) {\r\n                console.log(nodeRangeClientRect);\r\n                addOverlayRect(nodeRangeClientRect, 'purple', contentDoc);\r\n            }\r\n\r\n            return {startInfo: startRangeInfo, endInfo: endRangeInfo, clientRect: nodeRangeClientRect}\r\n        } else {\r\n            var $element = self.getElementByCfi(cfi,\r\n                this.getClassBlacklist(),\r\n                this.getElementBlacklist(),\r\n                this.getIdBlacklist());\r\n\r\n            var visibleContentOffsets = getVisibleContentOffsets();\r\n            return {startInfo: null, endInfo: null, clientRect: getNormalizedBoundingRect($element, visibleContentOffsets)};\r\n        }\r\n    };\r\n\r\n    this.isNodeFromRangeCfiVisible = function (cfi) {\r\n        var nodeRangeInfo = this.getNodeRangeInfoFromCfi(cfi);\r\n        if (nodeRangeInfo) {\r\n            return isRectVisible(nodeRangeInfo.clientRect, false);\r\n        } else {\r\n            return undefined;\r\n        }\r\n    };\r\n\r\n    this.getElementByCfi = function (cfi, classBlacklist, elementBlacklist, idBlacklist) {\r\n\r\n        var cfiParts = splitCfi(cfi);\r\n        return getElementByPartialCfi(cfiParts.cfi, classBlacklist, elementBlacklist, idBlacklist);\r\n    };\r\n\r\n    this.getPageForElement = function ($element) {\r\n\r\n        return this.getPageForPointOnElement($element, 0, 0);\r\n    };\r\n\r\n    this.getPageForPointOnElement = function ($element, x, y) {\r\n\r\n        var pageIndex = findPageByRectangles($element, y);\r\n        if (pageIndex === null) {\r\n            console.warn('Impossible to locate a hidden element: ', $element);\r\n            return 0;\r\n        }\r\n        return pageIndex;\r\n    };\r\n\r\n    this.getVerticalOffsetForElement = function ($element) {\r\n      return this.getVerticalOffsetForPointOnElement($element, 0, 0);\r\n    };\r\n\r\n    this.getVerticalOffsetForPointOnElement = function ($element, x, y) {\r\n      var elementRect = Helpers.Rect.fromElement($element);\r\n      return Math.ceil(elementRect.top + y * elementRect.height / 100);\r\n    };\r\n\r\n    this.getElementById = function (id) {\r\n\r\n        var contentDoc = this.getRootDocument();\r\n\r\n        var $element = $(contentDoc.getElementById(id));\r\n        //$(\"#\" + Helpers.escapeJQuerySelector(id), contentDoc);\r\n\r\n        if($element.length == 0) {\r\n            return undefined;\r\n        }\r\n\r\n        return $element;\r\n    };\r\n\r\n    this.getPageForElementId = function (id) {\r\n\r\n        var $element = this.getElementById(id);\r\n        if (!$element) {\r\n            return -1;\r\n        }\r\n\r\n        return this.getPageForElement($element);\r\n    };\r\n\r\n    function splitCfi(cfi) {\r\n\r\n        var ret = {\r\n            cfi: \"\",\r\n            x: 0,\r\n            y: 0\r\n        };\r\n\r\n        var ix = cfi.indexOf(\"@\");\r\n\r\n        if (ix != -1) {\r\n            var terminus = cfi.substring(ix + 1);\r\n\r\n            var colIx = terminus.indexOf(\":\");\r\n            if (colIx != -1) {\r\n                ret.x = parseInt(terminus.substr(0, colIx));\r\n                ret.y = parseInt(terminus.substr(colIx + 1));\r\n            }\r\n            else {\r\n                console.log(\"Unexpected terminating step format\");\r\n            }\r\n\r\n            ret.cfi = cfi.substring(0, ix);\r\n        }\r\n        else {\r\n\r\n            ret.cfi = cfi;\r\n        }\r\n\r\n        return ret;\r\n    }\r\n\r\n    // returns raw DOM element (not $ jQuery-wrapped)\r\n    this.getFirstVisibleMediaOverlayElement = function(visibleContentOffsets) {\r\n        var $root = $(this.getBodyElement());\r\n        if (!$root || !$root.length || !$root[0]) return undefined;\r\n\r\n        var that = this;\r\n\r\n        var firstPartial = undefined;\r\n\r\n        function traverseArray(arr) {\r\n            if (!arr || !arr.length) return undefined;\r\n\r\n            for (var i = 0, count = arr.length; i < count; i++) {\r\n                var item = arr[i];\r\n                if (!item) continue;\r\n\r\n                var $item = $(item);\r\n\r\n                if ($item.data(\"mediaOverlayData\")) {\r\n                    var visible = that.getElementVisibility($item, visibleContentOffsets);\r\n                    if (visible) {\r\n                        if (!firstPartial) firstPartial = item;\r\n\r\n                        if (visible == 100) return item;\r\n                    }\r\n                }\r\n                else {\r\n                    var elem = traverseArray(item.children);\r\n                    if (elem) return elem;\r\n                }\r\n            }\r\n\r\n            return undefined;\r\n        }\r\n\r\n        var el = traverseArray([$root[0]]);\r\n        if (!el) el = firstPartial;\r\n        return el;\r\n\r\n        // var $elements = this.getMediaOverlayElements($root);\r\n        // return this.getVisibleElements($elements, visibleContentOffsets);\r\n    };\r\n\r\n    this.getElementVisibility = function ($element, visibleContentOffsets) {\r\n        return checkVisibilityByRectangles($element, true, visibleContentOffsets);\r\n    };\r\n\r\n\r\n    this.isElementVisible = checkVisibilityByRectangles;\r\n\r\n    this.getVisibleElementsWithFilter = function (visibleContentOffsets, filterFunction) {\r\n        var $elements = this.getElementsWithFilter($(this.getBodyElement()), filterFunction);\r\n        return this.getVisibleElements($elements, visibleContentOffsets);\r\n    };\r\n\r\n    this.getAllElementsWithFilter = function (filterFunction) {\r\n        var $elements = this.getElementsWithFilter($(this.getBodyElement()), filterFunction);\r\n        return $elements;\r\n    };\r\n\r\n    this.getAllVisibleElementsWithSelector = function (selector, visibleContentOffset) {\r\n        var elements = $(selector, this.getRootElement());\r\n        var $newElements = [];\r\n        $.each(elements, function () {\r\n            $newElements.push($(this));\r\n        });\r\n        var visibleElements = this.getVisibleElements($newElements, visibleContentOffset);\r\n        return visibleElements;\r\n    };\r\n\r\n    this.getVisibleElements = function ($elements, visibleContentOffsets, frameDimensions) {\r\n\r\n        var visibleElements = [];\r\n\r\n        _.each($elements, function ($node) {\r\n            var isTextNode = ($node[0].nodeType === Node.TEXT_NODE);\r\n            var $element = isTextNode ? $node.parent() : $node;\r\n            var visibilityPercentage = checkVisibilityByRectangles(\r\n                $node, true, visibleContentOffsets, frameDimensions);\r\n\r\n            if (visibilityPercentage) {\r\n                visibleElements.push({\r\n                    element: $element[0], // DOM Element is pushed\r\n                    textNode: isTextNode ? $node[0] : null,\r\n                    percentVisible: visibilityPercentage\r\n                });\r\n            }\r\n        });\r\n\r\n        return visibleElements;\r\n    };\r\n\r\n    this.getVisibleLeafNodes = function (visibleContentOffsets, frameDimensions) {\r\n\r\n        if (_cacheEnabled) {\r\n            var cacheKey = (options.paginationInfo || {}).currentSpreadIndex || 0;\r\n            var fromCache = _cache.visibleLeafNodes.get(cacheKey);\r\n            if (fromCache) {\r\n                return fromCache;\r\n            }\r\n        }\r\n\r\n        var $elements = this.getLeafNodeElements($(this.getBodyElement()));\r\n\r\n        var visibleElements = this.getVisibleElements($elements, visibleContentOffsets, frameDimensions);\r\n\r\n        if (_cacheEnabled) {\r\n            _cache.visibleLeafNodes.set(cacheKey, visibleElements);\r\n        }\r\n\r\n        return visibleElements;\r\n    };\r\n\r\n    this.getElementsWithFilter = function ($root, filterFunction) {\r\n\r\n        var $elements = [];\r\n\r\n        function traverseCollection(elements) {\r\n\r\n            if (elements == undefined) return;\r\n\r\n            for (var i = 0, count = elements.length; i < count; i++) {\r\n\r\n                var $element = $(elements[i]);\r\n\r\n                if (filterFunction($element)) {\r\n                    $elements.push($element);\r\n                }\r\n                else {\r\n                    traverseCollection($element[0].children);\r\n                }\r\n\r\n            }\r\n        }\r\n\r\n        traverseCollection([$root[0]]);\r\n\r\n        return $elements;\r\n    };\r\n\r\n    function isElementBlacklisted($element) {\r\n        var isBlacklisted = false;\r\n\r\n        _.some(self.getClassBlacklist(), function (value) {\r\n            if ($element.hasClass(value)) {\r\n                isBlacklisted = true;\r\n            }\r\n            return isBlacklisted;\r\n        });\r\n\r\n        _.some(self.getIdBlacklist(), function (value) {\r\n            if ($element.attr(\"id\") === value) {\r\n                isBlacklisted = true;\r\n            }\r\n            return isBlacklisted;\r\n        });\r\n\r\n\r\n        return isBlacklisted;\r\n    }\r\n\r\n    this.getLeafNodeElements = function ($root) {\r\n\r\n        if (_cacheEnabled) {\r\n            var fromCache = _cache.leafNodeElements.get($root);\r\n            if (fromCache) {\r\n                return fromCache;\r\n            }\r\n        }\r\n\r\n        var nodeIterator = document.createNodeIterator(\r\n            $root[0],\r\n            NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_TEXT,\r\n            function() {\r\n                return NodeFilter.FILTER_ACCEPT;\r\n            },\r\n            false\r\n        );\r\n\r\n        var $leafNodeElements = [];\r\n\r\n        var node;\r\n        while ((node = nodeIterator.nextNode())) {\r\n            var isLeafNode = node.nodeType === Node.ELEMENT_NODE && !node.childElementCount && !isValidTextNodeContent(node.textContent);\r\n            if (isLeafNode || isValidTextNode(node)){\r\n                var $node = $(node);\r\n                var $element = (node.nodeType === Node.TEXT_NODE) ? $node.parent() : $node;\r\n                if (!isElementBlacklisted($element)) {\r\n                    $leafNodeElements.push($node);\r\n                }\r\n            }\r\n        }\r\n\r\n        if (_cacheEnabled) {\r\n            _cache.leafNodeElements.set($root, $leafNodeElements);\r\n        }\r\n\r\n        return $leafNodeElements;\r\n    };\r\n\r\n    function isValidTextNode(node) {\r\n\r\n        if (node.nodeType === Node.TEXT_NODE) {\r\n\r\n            return isValidTextNodeContent(node.nodeValue);\r\n        }\r\n\r\n        return false;\r\n\r\n    }\r\n\r\n    function isValidTextNodeContent(text) {\r\n        // Heuristic to find a text node with actual text\r\n        // If we don't do this, we may get a reference to a node that doesn't get rendered\r\n        // (such as for example a node that has tab character and a bunch of spaces)\r\n        // this is would be bad! ask me why.\r\n        return text.replace(/[\\s\\n\\r\\t]/g, \"\").length > 0;\r\n    }\r\n\r\n    this.getElements = function (selector) {\r\n        if (!selector) {\r\n            return $(this.getRootElement()).children();\r\n        }\r\n        return $(selector, this.getRootElement());\r\n    };\r\n\r\n    this.getElement = function (selector) {\r\n\r\n        var $element = this.getElements(selector);\r\n\r\n        if($element.length > 0) {\r\n            return $element;\r\n        }\r\n\r\n        return undefined;\r\n    };\r\n\r\n    function Cache() {\r\n        var that = this;\r\n\r\n        //true = survives invalidation\r\n        var props = {\r\n            leafNodeElements: true,\r\n            visibleLeafNodes: false\r\n        };\r\n\r\n        _.each(props, function (val, key) {\r\n            that[key] = new Map();\r\n        });\r\n\r\n        this._invalidate = function () {\r\n            _.each(props, function (val, key) {\r\n                if (!val) {\r\n                    that[key] = new Map();\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    var _cache = new Cache();\r\n\r\n    var _cacheEnabled = false;\r\n\r\n    this.invalidateCache = function () {\r\n        _cache._invalidate();\r\n    };\r\n\r\n\r\n    // dmitry debug\r\n    // dmitry debug\r\n    // dmitry debug\r\n    // dmitry debug\r\n    // dmitry debug\r\n    // dmitry debug\r\n\r\n    var parseContentCfi = function(cont) {\r\n        return cont.replace(/\\[(.*?)\\]/, \"\").split(/[\\/,:]/).map(function(n) { return parseInt(n); }).filter(Boolean);\r\n    };\r\n\r\n    var contentCfiComparator = function(cont1, cont2) {\r\n        cont1 = this.parseContentCfi(cont1);\r\n        cont2 = this.parseContentCfi(cont2);\r\n\r\n        //compare cont arrays looking for differences\r\n        for (var i=0; i<cont1.length; i++) {\r\n            if (cont1[i] > cont2[i]) {\r\n                return 1;\r\n            }\r\n            else if (cont1[i] < cont2[i]) {\r\n                return -1;\r\n            }\r\n        }\r\n\r\n        //no differences found, so confirm that cont2 did not have values we didn't check\r\n        if (cont1.length < cont2.length) {\r\n            return -1;\r\n        }\r\n\r\n        //cont arrays are identical\r\n        return 0;\r\n    };\r\n\r\n\r\n    // end dmitry debug\r\n\r\n    //if (debugMode) {\r\n\r\n        var $debugOverlays = [];\r\n\r\n        //used for visual debug atm\r\n        function getRandomColor() {\r\n            var letters = '0123456789ABCDEF'.split('');\r\n            var color = '#';\r\n            for (var i = 0; i < 6; i++) {\r\n                color += letters[Math.round(Math.random() * 15)];\r\n            }\r\n            return color;\r\n        }\r\n\r\n        //used for visual debug atm\r\n        function addOverlayRect(rects, color, doc) {\r\n            var random = getRandomColor();\r\n            if (!(rects instanceof Array)) {\r\n                rects = [rects];\r\n            }\r\n            for (var i = 0; i != rects.length; i++) {\r\n                var rect = rects[i];\r\n                var overlayDiv = doc.createElement('div');\r\n                overlayDiv.style.position = 'absolute';\r\n                $(overlayDiv).css('z-index', '1000');\r\n                $(overlayDiv).css('pointer-events', 'none');\r\n                $(overlayDiv).css('opacity', '0.4');\r\n                overlayDiv.style.border = '1px solid white';\r\n                if (!color && !random) {\r\n                    overlayDiv.style.background = 'purple';\r\n                } else if (random && !color) {\r\n                    overlayDiv.style.background = random;\r\n                } else {\r\n                    if (color === true) {\r\n                        color = 'red';\r\n                    }\r\n                    overlayDiv.style.border = '1px dashed ' + color;\r\n                    overlayDiv.style.background = 'yellow';\r\n                }\r\n\r\n                overlayDiv.style.margin = overlayDiv.style.padding = '0';\r\n                overlayDiv.style.top = (rect.top ) + 'px';\r\n                overlayDiv.style.left = (rect.left ) + 'px';\r\n                // we want rect.width to be the border width, so content width is 2px less.\r\n                overlayDiv.style.width = (rect.width - 2) + 'px';\r\n                overlayDiv.style.height = (rect.height - 2) + 'px';\r\n                doc.documentElement.appendChild(overlayDiv);\r\n                $debugOverlays.push($(overlayDiv));\r\n            }\r\n        }\r\n\r\n        function drawDebugOverlayFromRect(rect) {\r\n            var leftOffset, topOffset;\r\n\r\n            if (isVerticalWritingMode()) {\r\n                leftOffset = 0;\r\n                topOffset = -getPaginationLeftOffset();\r\n            } else {\r\n                leftOffset = -getPaginationLeftOffset();\r\n                topOffset = 0;\r\n            }\r\n\r\n            addOverlayRect({\r\n                left: rect.left + leftOffset,\r\n                top: rect.top + topOffset,\r\n                width: rect.width,\r\n                height: rect.height\r\n            }, true, self.getRootDocument());\r\n        }\r\n\r\n        function drawDebugOverlayFromDomRange(range) {\r\n            var rect = getNodeRangeClientRect(\r\n                range.startContainer,\r\n                range.startOffset,\r\n                range.endContainer,\r\n                range.endOffset);\r\n            drawDebugOverlayFromRect(rect);\r\n            return rect;\r\n        }\r\n\r\n        function drawDebugOverlayFromNode(node) {\r\n            drawDebugOverlayFromRect(getNodeClientRect(node));\r\n        }\r\n\r\n        function getPaginationLeftOffset() {\r\n\r\n            var $htmlElement = $(\"html\", self.getRootDocument());\r\n            var offsetLeftPixels = $htmlElement.css(isVerticalWritingMode() ? \"top\" : (isPageProgressionRightToLeft() ? \"right\" : \"left\"));\r\n            var offsetLeft = parseInt(offsetLeftPixels.replace(\"px\", \"\"));\r\n            if (isNaN(offsetLeft)) {\r\n                //for fixed layouts, $htmlElement.css(\"left\") has no numerical value\r\n                offsetLeft = 0;\r\n            }\r\n            if (isPageProgressionRightToLeft() && !isVerticalWritingMode()) return -offsetLeft; \r\n            return offsetLeft;\r\n        }\r\n\r\n        function clearDebugOverlays() {\r\n            _.each($debugOverlays, function($el){\r\n                $el.remove();\r\n            });\r\n            $debugOverlays.clear();\r\n        }\r\n\r\n        ReadiumSDK._DEBUG_CfiNavigationLogic = {\r\n            clearDebugOverlays: clearDebugOverlays,\r\n            drawDebugOverlayFromRect: drawDebugOverlayFromRect,\r\n            drawDebugOverlayFromDomRange: drawDebugOverlayFromDomRange,\r\n            drawDebugOverlayFromNode: drawDebugOverlayFromNode,\r\n            debugVisibleCfis: function () {\r\n                console.log(JSON.stringify(ReadiumSDK.reader.getPaginationInfo().openPages));\r\n\r\n                var cfi1 = ReadiumSDK.reader.getFirstVisibleCfi();\r\n                var range1 = ReadiumSDK.reader.getDomRangeFromRangeCfi(cfi1);\r\n                console.log(cfi1, range1, drawDebugOverlayFromDomRange(range1));\r\n\r\n                var cfi2 = ReadiumSDK.reader.getLastVisibleCfi();\r\n                var range2 = ReadiumSDK.reader.getDomRangeFromRangeCfi(cfi2);\r\n                console.log(cfi2, range2, drawDebugOverlayFromDomRange(range2));\r\n            }\r\n        };\r\n\r\n        //\r\n   // }\r\n\r\n};\r\nreturn CfiNavigationLogic;\r\n});\r\n\n",
    "//  Created by Boris Schneiderman.\r\n//  Copyright (c) 2014 Readium Foundation and/or its licensees. All rights reserved.\r\n//  \r\n//  Redistribution and use in source and binary forms, with or without modification, \r\n//  are permitted provided that the following conditions are met:\r\n//  1. Redistributions of source code must retain the above copyright notice, this \r\n//  list of conditions and the following disclaimer.\r\n//  2. Redistributions in binary form must reproduce the above copyright notice, \r\n//  this list of conditions and the following disclaimer in the documentation and/or \r\n//  other materials provided with the distribution.\r\n//  3. Neither the name of the organization nor the names of its contributors may be \r\n//  used to endorse or promote products derived from this software without specific \r\n//  prior written permission.\r\n//  \r\n//  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND \r\n//  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED \r\n//  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. \r\n//  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, \r\n//  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, \r\n//  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, \r\n//  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF \r\n//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE \r\n//  OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED \r\n//  OF THE POSSIBILITY OF SUCH DAMAGE.\r\n\r\ndefine('readium_shared_js/models/viewer_settings',[], function() {\r\n/**\r\n *\r\n * @param settingsData\r\n * @constructor\r\n */\r\nvar ViewerSettings = function(settingsData) {\r\n\r\n    var self = this;\r\n\r\n    /** Set to \"auto\"\r\n     *\r\n     * @property syntheticSpread\r\n     * @type \r\n     */\r\n\r\n    this.syntheticSpread = \"auto\";\r\n    \r\n    /** \r\n     *\r\n     * @property fontSize\r\n     * @type number\r\n     */\r\n\r\n    this.fontSize = 100;\r\n\r\n    /** \r\n     *\r\n     * @property columnGap\r\n     * @type number\r\n     */\r\n\r\n    this.columnGap = 20;\r\n    \r\n    /** \r\n     *\r\n     * @property columnMaxWidth\r\n     * @type number\r\n     */\r\n\r\n    this.columnMaxWidth = 700;\r\n\r\n    /** \r\n     *\r\n     * @property columnMinWidth\r\n     * @type number\r\n     */\r\n\r\n    this.columnMinWidth = 400;\r\n\r\n    /** \r\n     *\r\n     * @property mediaOverlaysPreservePlaybackWhenScroll\r\n     * @type bool\r\n     */\r\n\r\n    this.mediaOverlaysPreservePlaybackWhenScroll = false;\r\n\r\n    /** \r\n     *\r\n     * @property mediaOverlaysSkipSkippables\r\n     * @type bool\r\n     */\r\n\r\n    this.mediaOverlaysSkipSkippables = false;\r\n\r\n    /** \r\n     *\r\n     * @property mediaOverlaysEscapables\r\n     * @type bool\r\n     */\r\n\r\n    this.mediaOverlaysEscapeEscapables = true;\r\n\r\n    /** \r\n     *\r\n     * @property mediaOverlaysSkippables\r\n     * @type array\r\n     */\r\n\r\n    this.mediaOverlaysSkippables = [];\r\n    \r\n    /** \r\n     *\r\n     * @property mediaOverlaysEscapables\r\n     * @type array\r\n     */\r\n\r\n    this.mediaOverlaysEscapables = [];\r\n\r\n    /** \r\n     *\r\n     * @property mediaOverlaysEnableClick\r\n     * @type bool\r\n     */\r\n    \r\n    this.mediaOverlaysEnableClick = true;\r\n\r\n    /** \r\n     *\r\n     * @property mediaOverlaysRate\r\n     * @type number\r\n     */\r\n\r\n    this.mediaOverlaysRate = 1;\r\n\r\n    /** \r\n     *\r\n     * @property mediaOverlaysVolume\r\n     * @type number\r\n     */\r\n\r\n    this.mediaOverlaysVolume = 100;\r\n\r\n    /** \r\n     *\r\n     * @property mediaOverlaysSynchronizationGranularity\r\n     * @type string\r\n     */\r\n    \r\n    this.mediaOverlaysSynchronizationGranularity = \"\";\r\n\r\n    /** \r\n     *\r\n     * @property mediaOverlaysAutomaticPageTurn\r\n     * @type bool\r\n     */    \r\n\r\n    this.mediaOverlaysAutomaticPageTurn = true;\r\n\r\n    /** \r\n     *\r\n     * @property enableGPUHardwareAccelerationCSS3D\r\n     * @type bool\r\n     */    \r\n\r\n\r\n    this.enableGPUHardwareAccelerationCSS3D = false;\r\n\r\n    // -1 ==> disable\r\n    // [0...n] ==> index of transition in pre-defined array\r\n    \r\n    /** \r\n     *\r\n     * @property pageTransition\r\n     * @type number\r\n     */        \r\n\r\n    this.pageTransition = -1;\r\n \r\n    /** \r\n     *\r\n     * @property scroll\r\n     * @type string\r\n     */        \r\n\r\n    this.scroll = \"auto\";\r\n\r\n    /**\r\n     * Builds an array\r\n     *\r\n     * @method     buildArray\r\n     * @param      {string} str\r\n     * @return     {array} retArr\r\n     */\r\n\r\n    function buildArray(str)\r\n    {\r\n        var retArr = [];\r\n        var arr = str.split(/[\\s,;]+/); //','\r\n        for (var i = 0; i < arr.length; i++)\r\n        {\r\n            var item = arr[i].trim();\r\n            if (item !== \"\")\r\n            {\r\n                retArr.push(item);\r\n            }\r\n        }\r\n        return retArr;\r\n    }\r\n\r\n    /**\r\n     * Maps the properties to the settings\r\n     *\r\n     * @method     mapProperty\r\n     * @param      {string} propName\r\n     * @param      settingsData\r\n     * @param      functionToApply\r\n     */\r\n\r\n    function mapProperty(propName, settingsData, functionToApply) {\r\n\r\n        if(settingsData[propName] !== undefined) {\r\n            if(functionToApply) {\r\n\r\n                self[propName] = functionToApply(settingsData[propName]);\r\n            }\r\n            else {\r\n                self[propName] = settingsData[propName];\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     * Updates the settings' new values\r\n     *\r\n     * @method     update\r\n     * @param      settingsData\r\n     */\r\n\r\n    this.update = function(settingsData) {\r\n\r\n        mapProperty(\"columnGap\", settingsData);\r\n        mapProperty(\"columnMaxWidth\", settingsData);\r\n        mapProperty(\"columnMinWidth\", settingsData);\r\n        mapProperty(\"fontSize\", settingsData);\r\n        mapProperty(\"mediaOverlaysPreservePlaybackWhenScroll\", settingsData);\r\n        mapProperty(\"mediaOverlaysSkipSkippables\", settingsData);\r\n        mapProperty(\"mediaOverlaysEscapeEscapables\", settingsData);\r\n        mapProperty(\"mediaOverlaysSkippables\", settingsData, buildArray);\r\n        mapProperty(\"mediaOverlaysEscapables\", settingsData, buildArray);\r\n        mapProperty(\"mediaOverlaysEnableClick\", settingsData);\r\n        mapProperty(\"mediaOverlaysRate\", settingsData);\r\n        mapProperty(\"mediaOverlaysVolume\", settingsData);\r\n        mapProperty(\"mediaOverlaysSynchronizationGranularity\", settingsData);\r\n        mapProperty(\"mediaOverlaysAutomaticPageTurn\", settingsData);\r\n        mapProperty(\"scroll\", settingsData);\r\n        mapProperty(\"syntheticSpread\", settingsData);\r\n        mapProperty(\"pageTransition\", settingsData);\r\n        mapProperty(\"enableGPUHardwareAccelerationCSS3D\", settingsData);\r\n    };\r\n\r\n    this.update(settingsData);\r\n};\r\n    return ViewerSettings;\r\n});\r\n\n",
    "/**\r\n * Copyright Marc J. Schmidt. See the LICENSE file at the top-level\r\n * directory of this distribution and at\r\n * https://github.com/marcj/css-element-queries/blob/master/LICENSE.\r\n */\r\n;\r\n(function (root, factory) {\r\n    if (typeof define === \"function\" && define.amd) {\r\n        define('ResizeSensor',factory);\r\n    } else if (typeof exports === \"object\") {\r\n        module.exports = factory();\r\n    } else {\r\n        root.ResizeSensor = factory();\r\n    }\r\n}(this, function () {\r\n\r\n    // Only used for the dirty checking, so the event callback count is limted to max 1 call per fps per sensor.\r\n    // In combination with the event based resize sensor this saves cpu time, because the sensor is too fast and\r\n    // would generate too many unnecessary events.\r\n    var requestAnimationFrame = window.requestAnimationFrame ||\r\n        window.mozRequestAnimationFrame ||\r\n        window.webkitRequestAnimationFrame ||\r\n        function (fn) {\r\n            return window.setTimeout(fn, 20);\r\n        };\r\n\r\n    /**\r\n     * Iterate over each of the provided element(s).\r\n     *\r\n     * @param {HTMLElement|HTMLElement[]} elements\r\n     * @param {Function}                  callback\r\n     */\r\n    function forEachElement(elements, callback){\r\n        var elementsType = Object.prototype.toString.call(elements);\r\n        var isCollectionTyped = ('[object Array]' === elementsType\r\n            || ('[object NodeList]' === elementsType)\r\n            || ('[object HTMLCollection]' === elementsType)\r\n            || ('undefined' !== typeof jQuery && elements instanceof jQuery) //jquery\r\n            || ('undefined' !== typeof Elements && elements instanceof Elements) //mootools\r\n        );\r\n        var i = 0, j = elements.length;\r\n        if (isCollectionTyped) {\r\n            for (; i < j; i++) {\r\n                callback(elements[i]);\r\n            }\r\n        } else {\r\n            callback(elements);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Class for dimension change detection.\r\n     *\r\n     * @param {Element|Element[]|Elements|jQuery} element\r\n     * @param {Function} callback\r\n     *\r\n     * @constructor\r\n     */\r\n    var ResizeSensor = function(element, callback) {\r\n        /**\r\n         *\r\n         * @constructor\r\n         */\r\n        function EventQueue() {\r\n            var q = [];\r\n            this.add = function(ev) {\r\n                q.push(ev);\r\n            };\r\n\r\n            var i, j;\r\n            this.call = function() {\r\n                for (i = 0, j = q.length; i < j; i++) {\r\n                    q[i].call();\r\n                }\r\n            };\r\n\r\n            this.remove = function(ev) {\r\n                var newQueue = [];\r\n                for(i = 0, j = q.length; i < j; i++) {\r\n                    if(q[i] !== ev) newQueue.push(q[i]);\r\n                }\r\n                q = newQueue;\r\n            }\r\n\r\n            this.length = function() {\r\n                return q.length;\r\n            }\r\n        }\r\n\r\n        /**\r\n         * @param {HTMLElement} element\r\n         * @param {String}      prop\r\n         * @returns {String|Number}\r\n         */\r\n        function getComputedStyle(element, prop) {\r\n            if (element.currentStyle) {\r\n                return element.currentStyle[prop];\r\n            } else if (window.getComputedStyle) {\r\n                return window.getComputedStyle(element, null).getPropertyValue(prop);\r\n            } else {\r\n                return element.style[prop];\r\n            }\r\n        }\r\n\r\n        /**\r\n         *\r\n         * @param {HTMLElement} element\r\n         * @param {Function}    resized\r\n         */\r\n        function attachResizeEvent(element, resized) {\r\n            if (!element.resizedAttached) {\r\n                element.resizedAttached = new EventQueue();\r\n                element.resizedAttached.add(resized);\r\n            } else if (element.resizedAttached) {\r\n                element.resizedAttached.add(resized);\r\n                return;\r\n            }\r\n\r\n            element.resizeSensor = document.createElement('div');\r\n            element.resizeSensor.className = 'resize-sensor';\r\n            var style = 'position: absolute; left: 0; top: 0; right: 0; bottom: 0; overflow: hidden; z-index: -1; visibility: hidden;';\r\n            var styleChild = 'position: absolute; left: 0; top: 0; transition: 0s;';\r\n\r\n            element.resizeSensor.style.cssText = style;\r\n            element.resizeSensor.innerHTML =\r\n                '<div class=\"resize-sensor-expand\" style=\"' + style + '\">' +\r\n                    '<div style=\"' + styleChild + '\" class=\"resize-sensor-inner\"></div>' +\r\n                '</div>' +\r\n                '<div class=\"resize-sensor-shrink\" style=\"' + style + '\">' +\r\n                    '<div style=\"' + styleChild + ' width: 200%; height: 200%\" class=\"resize-sensor-inner\"></div>' +\r\n                '</div>';\r\n            element.appendChild(element.resizeSensor);\r\n\r\n            if (getComputedStyle(element, 'position') == 'static') {\r\n                element.style.position = 'relative';\r\n            }\r\n\r\n            var expand = element.resizeSensor.childNodes[0];\r\n            var expandChild = expand.childNodes[0];\r\n            var shrink = element.resizeSensor.childNodes[1];\r\n\r\n            var reset = function() {\r\n                expandChild.style.width  = 100000 + 'px';\r\n                expandChild.style.height = 100000 + 'px';\r\n\r\n                expand.scrollLeft = 100000;\r\n                expand.scrollTop = 100000;\r\n\r\n                shrink.scrollLeft = 100000;\r\n                shrink.scrollTop = 100000;\r\n            };\r\n\r\n            reset();\r\n            var dirty = false;\r\n\r\n            var dirtyChecking = function() {\r\n                if (dirty && element.resizedAttached) {\r\n                    element.resizedAttached.call();\r\n                }\r\n                dirty = false;\r\n            };\r\n\r\n            requestAnimationFrame(dirtyChecking);\r\n            var lastWidth, lastHeight;\r\n            var cachedWidth, cachedHeight; //useful to not query offsetWidth twice\r\n\r\n            var onScroll = function() {\r\n              if ((cachedWidth = element.offsetWidth) != lastWidth || (cachedHeight = element.offsetHeight) != lastHeight) {\r\n                  dirty = true;\r\n\r\n                  lastWidth = cachedWidth;\r\n                  lastHeight = cachedHeight;\r\n\r\n                  requestAnimationFrame(dirtyChecking);\r\n              }\r\n              reset();\r\n            };\r\n\r\n            var addEvent = function(el, name, cb) {\r\n                if (el.attachEvent) {\r\n                    el.attachEvent('on' + name, cb);\r\n                } else {\r\n                    el.addEventListener(name, cb);\r\n                }\r\n            };\r\n\r\n            addEvent(expand, 'scroll', onScroll);\r\n            addEvent(shrink, 'scroll', onScroll);\r\n        }\r\n\r\n        forEachElement(element, function(elem){\r\n            attachResizeEvent(elem, callback);\r\n        });\r\n\r\n        this.detach = function(ev) {\r\n            ResizeSensor.detach(element, ev);\r\n        };\r\n    };\r\n\r\n    ResizeSensor.detach = function(element, ev) {\r\n        forEachElement(element, function(elem){\r\n            if(elem.resizedAttached && typeof ev == \"function\"){\r\n                elem.resizedAttached.remove(ev);\r\n                if(elem.resizedAttached.length()) return;\r\n            }\r\n            if (elem.resizeSensor) {\r\n                if (elem.contains(elem.resizeSensor)) {\r\n                    elem.removeChild(elem.resizeSensor);\r\n                }\r\n                delete elem.resizeSensor;\r\n                delete elem.resizedAttached;\r\n            }\r\n        });\r\n    };\r\n\r\n    return ResizeSensor;\r\n\r\n}));\r\n\n",
    "//  Created by Boris Schneiderman.\r\n//  Copyright (c) 2014 Readium Foundation and/or its licensees. All rights reserved.\r\n//\r\n//  Redistribution and use in source and binary forms, with or without modification,\r\n//  are permitted provided that the following conditions are met:\r\n//  1. Redistributions of source code must retain the above copyright notice, this\r\n//  list of conditions and the following disclaimer.\r\n//  2. Redistributions in binary form must reproduce the above copyright notice,\r\n//  this list of conditions and the following disclaimer in the documentation and/or\r\n//  other materials provided with the distribution.\r\n//  3. Neither the name of the organization nor the names of its contributors may be\r\n//  used to endorse or promote products derived from this software without specific\r\n//  prior written permission.\r\n//\r\n//  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\r\n//  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n//  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\r\n//  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\r\n//  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\r\n//  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\r\n//  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\r\n//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE\r\n//  OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\r\n//  OF THE POSSIBILITY OF SUCH DAMAGE.\r\n\r\n\r\ndefine('readium_shared_js/views/one_page_view',[\"../globals\", \"jquery\", \"underscore\", \"eventEmitter\", \"./cfi_navigation_logic\", \"../helpers\", \"../models/viewer_settings\", \"../models/bookmark_data\", \"ResizeSensor\"],\r\n    function (Globals, $, _, EventEmitter, CfiNavigationLogic, Helpers, ViewerSettings, BookmarkData, ResizeSensor) {\r\n\r\n/**\r\n * Renders one page of fixed layout spread\r\n *\r\n * @param options\r\n * @param classes\r\n * @param enableBookStyleOverrides\r\n * @constructor\r\n */\r\nvar OnePageView = function (options, classes, enableBookStyleOverrides, reader) {\r\n\r\n    $.extend(this, new EventEmitter());\r\n\r\n    var self = this;\r\n\r\n    var _$epubHtml;\r\n    var _$epubBody;\r\n    var _$el;\r\n    var _$iframe;\r\n    var _currentSpineItem;\r\n    var _spine = options.spine;\r\n    var _iframeLoader = options.iframeLoader;\r\n    var _navigationLogic = undefined;\r\n    var _bookStyles = options.bookStyles;\r\n\r\n    var _$viewport = options.$viewport;\r\n\r\n    var _isIframeLoaded = false;\r\n\r\n    var _$scaler;\r\n\r\n    var PageTransitionHandler = function (opts) {\r\n        var PageTransition = function (begin, end) {\r\n            this.begin = begin;\r\n            this.end = end;\r\n        };\r\n\r\n        var _pageTransition_OPACITY = new PageTransition(\r\n            function (scale, left, top, $el, meta_width, meta_height, pageSwitchDir) {\r\n                $el.css(\"opacity\", \"0\");\r\n            },\r\n            function (scale, left, top, $el, meta_width, meta_height, pageSwitchDir) {\r\n                $el.css(\"transform\", \"none\");\r\n\r\n                Helpers.CSSTransition($el, \"opacity 150ms ease-out\");\r\n\r\n                $el.css(\"opacity\", \"1\");\r\n            }\r\n        );\r\n\r\n        var _pageTransition_TRANSLATE = new PageTransition(\r\n            function (scale, left, top, $el, meta_width, meta_height, pageSwitchDir) {\r\n                $el.css(\"opacity\", \"0\");\r\n\r\n                var elWidth = Math.ceil(meta_width * scale);\r\n\r\n                var initialLeft = elWidth * 0.8 * (pageSwitchDir === 2 ? 1 : -1);\r\n                var move = Helpers.CSSTransformString({\r\n                    left: Math.round(initialLeft),\r\n                    origin: \"50% 50% 0\",\r\n                    enable3D: _enable3D\r\n                });\r\n                $el.css(move);\r\n            },\r\n            function (scale, left, top, $el, meta_width, meta_height, pageSwitchDir) {\r\n                $el.css(\"opacity\", \"1\");\r\n\r\n                Helpers.CSSTransition($el, \"transform 150ms ease-out\");\r\n\r\n                $el.css(\"transform\", \"none\");\r\n            }\r\n        );\r\n\r\n        var _pageTransition_ROTATE = new PageTransition(\r\n            function (scale, left, top, $el, meta_width, meta_height, pageSwitchDir) {\r\n                $el.css(\"opacity\", \"0\");\r\n\r\n                var elWidth = Math.ceil(meta_width * scale);\r\n\r\n                var initialLeft = elWidth * 1.7 * (pageSwitchDir === 2 ? 1 : -1);\r\n                var trans = Helpers.CSSTransformString({\r\n                    left: Math.round(initialLeft),\r\n                    angle: (pageSwitchDir === 2 ? -1 : 1) * 30,\r\n                    origin: \"50% 50% 0\",\r\n                    enable3D: _enable3D\r\n                }); //(pageSwitchDir === 2 ? '0% 0%' : '100% 0%')\r\n                $el.css(trans);\r\n            },\r\n            function (scale, left, top, $el, meta_width, meta_height, pageSwitchDir) {\r\n                $el.css(\"opacity\", \"1\");\r\n\r\n                Helpers.CSSTransition($el, \"transform 300ms ease-in-out\");\r\n\r\n                $el.css(\"transform\", \"none\");\r\n            }\r\n        );\r\n\r\n        var _pageTransition_SWING = new PageTransition(\r\n            function (scale, left, top, $el, meta_width, meta_height, pageSwitchDir) {\r\n                $el.css(\"opacity\", \"0\");\r\n\r\n                // SUPER HACKY!! (just for demo)\r\n                var isLeft = false;\r\n                var isCenter = false;\r\n                var isRight = false;\r\n                for (var i = 0; i < classes.length; i++) {\r\n                    var c = classes[i].toLowerCase();\r\n                    if (c.indexOf(\"left\") >= 0) {\r\n                        isLeft = true;\r\n                        break;\r\n                    }\r\n                    if (c.indexOf(\"right\") >= 0) {\r\n                        isRight = true;\r\n                        break;\r\n                    }\r\n                    if (c.indexOf(\"center\") >= 0) {\r\n                        isCenter = true;\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                var elWidth = Math.ceil(meta_width * scale);\r\n\r\n                var initialLeft = elWidth * 0.5 * ((isLeft || isCenter && pageSwitchDir === 1) ? 1 : -1);\r\n                var trans = Helpers.CSSTransformString({\r\n                    scale: 0.2,\r\n                    left: Math.round(initialLeft),\r\n                    angle: ((isLeft || isCenter && pageSwitchDir === 1) ? 1 : -1) * 30,\r\n                    origin: '50% 50% 0',\r\n                    enable3D: _enable3D\r\n                });\r\n                $el.css(trans);\r\n            },\r\n            function (scale, left, top, $el, meta_width, meta_height, pageSwitchDir) {\r\n                $el.css(\"opacity\", \"1\");\r\n\r\n                Helpers.CSSTransition($el, \"transform 400ms ease-out\");\r\n\r\n                $el.css(\"transform\", \"none\");\r\n            }\r\n        );\r\n\r\n        var _pageTransitions = [];\r\n        _pageTransitions.push(_pageTransition_OPACITY); // 0\r\n        _pageTransitions.push(_pageTransition_TRANSLATE); // 1\r\n        _pageTransitions.push(_pageTransition_ROTATE); // 2\r\n        _pageTransitions.push(_pageTransition_SWING); // 3\r\n\r\n        var _disablePageTransitions = opts.disablePageTransitions || false;\r\n                \r\n        // TODO: page transitions are broken, sp we disable them to avoid nasty visual artefacts\r\n        _disablePageTransitions = true;\r\n\r\n        var _pageTransition = -1;\r\n\r\n        var _enable3D = new ViewerSettings({}).enableGPUHardwareAccelerationCSS3D;\r\n\r\n        var _viewerSettings = undefined;\r\n        this.updateOptions = function (o) {\r\n            _viewerSettings = o;\r\n\r\n            var settings = _viewerSettings;\r\n            if (!settings || typeof settings.enableGPUHardwareAccelerationCSS3D === \"undefined\") {\r\n                //defaults\r\n                settings = new ViewerSettings({});\r\n            }\r\n            if (settings.enableGPUHardwareAccelerationCSS3D) {\r\n                _enable3D = true;\r\n            }\r\n\r\n            if (o.pageTransition !== null && typeof o.pageTransition !== \"undefined\") {\r\n                _pageTransition = o.pageTransition;\r\n            }\r\n        };\r\n        this.updateOptions(opts);\r\n\r\n        var _pageSwitchDir = 0;\r\n        var _pageSwitchActuallyChanged = false;\r\n        var _pageSwitchActuallyChanged_IFRAME_LOAD = false;\r\n\r\n        // dir: 0 => new or same page, 1 => previous, 2 => next\r\n        this.updatePageSwitchDir = function (dir, hasChanged) {\r\n            if (_pageSwitchActuallyChanged_IFRAME_LOAD) {\r\n                return;\r\n            }\r\n\r\n            _pageSwitchDir = dir;\r\n            _pageSwitchActuallyChanged = hasChanged;\r\n        };\r\n\r\n        this.onIFrameLoad = function () {\r\n            _pageSwitchActuallyChanged_IFRAME_LOAD = true; // second pass, but initial display for transition\r\n        };\r\n\r\n        this.transformContentImmediate_BEGIN = function ($el, scale, left, top) {\r\n            var pageSwitchActuallyChanged = _pageSwitchActuallyChanged || _pageSwitchActuallyChanged_IFRAME_LOAD;\r\n            _pageSwitchActuallyChanged_IFRAME_LOAD = false;\r\n\r\n            if (_disablePageTransitions || _pageTransition === -1) return;\r\n\r\n            Helpers.CSSTransition($el, \"all 0 ease 0\");\r\n\r\n            if (!pageSwitchActuallyChanged) return;\r\n\r\n            var pageTransition = (_pageTransition >= 0 && _pageTransition < _pageTransitions.length) ? _pageTransitions[_pageTransition] : undefined;\r\n\r\n            if (_pageSwitchDir === 0 || !pageTransition) {\r\n                $el.css(\"opacity\", \"0\");\r\n            }\r\n            else {\r\n                pageTransition.begin(scale, left, top, $el, self.meta_width(), self.meta_height(), _pageSwitchDir);\r\n            }\r\n        };\r\n\r\n        this.transformContentImmediate_END = function ($el, scale, left, top) {\r\n            if (_disablePageTransitions || _pageTransition === -1) {\r\n                $el.css(\"transform\", \"none\");\r\n                return;\r\n            }\r\n\r\n            setTimeout(function () {\r\n                var pageTransition = (_pageTransition >= 0 && _pageTransition < _pageTransitions.length) ? _pageTransitions[_pageTransition] : undefined;\r\n\r\n                if (_pageSwitchDir === 0 || !pageTransition) {\r\n                    $el.css(\"transform\", \"none\");\r\n\r\n                    Helpers.CSSTransition($el, \"opacity 250ms linear\");\r\n\r\n                    $el.css(\"opacity\", \"1\");\r\n                }\r\n                else {\r\n                    pageTransition.end(scale, left, top, $el, self.meta_width(), self.meta_height(), _pageSwitchDir);\r\n                }\r\n\r\n            }, 10);\r\n        };\r\n    };\r\n    var _pageTransitionHandler = new PageTransitionHandler(options);\r\n\r\n\r\n    // fixed layout does not apply user styles to publisher content, but reflowable scroll view does\r\n    var _enableBookStyleOverrides = enableBookStyleOverrides || false;\r\n\r\n    var _meta_size = {\r\n        width: 0,\r\n        height: 0\r\n    };\r\n\r\n    this.element = function () {\r\n        return _$el;\r\n    };\r\n\r\n    this.meta_height = function () {\r\n        return _meta_size.height;\r\n    };\r\n\r\n    this.meta_width = function () {\r\n        return _meta_size.width;\r\n    };\r\n\r\n    this.isDisplaying = function () {\r\n\r\n        return _isIframeLoaded; //_$iframe && _$iframe[0] && _$epubHtml\r\n    };\r\n\r\n    this.render = function () {\r\n\r\n        var template = Helpers.loadTemplate(\"single_page_frame\", {});\r\n\r\n        _$el = $(template);\r\n\r\n        _$scaler = $(\"#scaler\", _$el);\r\n\r\n        Helpers.CSSTransition(_$el, \"all 0 ease 0\");\r\n\r\n        _$el.css(\"transform\", \"none\");\r\n\r\n        var settings = reader.viewerSettings();\r\n        if (!settings || typeof settings.enableGPUHardwareAccelerationCSS3D === \"undefined\") {\r\n            //defaults\r\n            settings = new ViewerSettings({});\r\n        }\r\n        if (settings.enableGPUHardwareAccelerationCSS3D) {\r\n\r\n            // This fixes rendering issues with WebView (native apps), which crops content embedded in iframes unless GPU hardware acceleration is enabled for CSS rendering.\r\n            _$el.css(\"transform\", \"translateZ(0)\");\r\n        }\r\n\r\n        _$el.css(\"height\", \"100%\");\r\n        _$el.css(\"width\", \"100%\");\r\n\r\n        for (var i = 0, count = classes.length; i < count; i++) {\r\n            _$el.addClass(classes[i]);\r\n        }\r\n\r\n        _$iframe = $(\"iframe\", _$el);\r\n\r\n        return this;\r\n    };\r\n\r\n\r\n    this.decorateIframe = function () {\r\n        if (!_$iframe || !_$iframe.length) return;\r\n\r\n        _$iframe.css(\"border-bottom\", \"1px dashed silver\");\r\n        _$iframe.css(\"border-top\", \"1px dashed silver\");\r\n    };\r\n\r\n    this.remove = function () {\r\n        this.clear();\r\n        \r\n        _currentSpineItem = undefined;\r\n        \r\n        if (_$el && _$el[0]) {\r\n            _$el.remove();\r\n        }\r\n        \r\n        _$el = undefined;\r\n        _$scaler = undefined;\r\n        _$iframe = undefined;\r\n    };\r\n\r\n    this.clear = function () {\r\n        _isIframeLoaded = false;\r\n        \r\n        if (_$iframe && _$iframe[0]) {\r\n            _$iframe[0].src = \"\";\r\n        }\r\n    };\r\n\r\n    this.currentSpineItem = function () {\r\n\r\n        return _currentSpineItem;\r\n    };\r\n\r\n    function onIFrameLoad(success) {\r\n\r\n        if (success) {\r\n            _isIframeLoaded = true;\r\n            var epubContentDocument = _$iframe[0].contentDocument;\r\n            _$epubHtml = $(\"html\", epubContentDocument);\r\n            if (!_$epubHtml || _$epubHtml.length == 0) {\r\n                _$epubHtml = $(\"svg\", epubContentDocument);\r\n            } else {\r\n                _$epubBody = $(\"body\", _$epubHtml);\r\n            }\r\n\r\n            //_$epubHtml.css(\"overflow\", \"hidden\");\r\n\r\n\r\n\r\n            if (_enableBookStyleOverrides) {\r\n                self.applyBookStyles();\r\n            }\r\n\r\n            updateMetaSize();\r\n\r\n            var bodyElement = _$epubBody[0];\r\n            bodyElement.resizeSensor = new ResizeSensor(bodyElement, function() {\r\n                console.log(\"OnePageView iframe body resized\", $(bodyElement).width(), $(bodyElement).height());\r\n                var src = _spine.package.resolveRelativeUrl(_currentSpineItem.href);\r\n                Globals.logEvent(\"OnePageView.Events.CONTENT_SIZE_CHANGED\", \"EMIT\", \"one_page_view.js [ \" + _currentSpineItem.href + \" -- \" + src + \" ]\");\r\n                self.emit(OnePageView.Events.CONTENT_SIZE_CHANGED, _$iframe, _currentSpineItem);\r\n                //updatePagination();\r\n            });\r\n\r\n            _pageTransitionHandler.onIFrameLoad();\r\n        }\r\n    }\r\n\r\n    var _viewSettings = undefined;\r\n    this.setViewSettings = function (settings) {\r\n\r\n        _viewSettings = settings;\r\n\r\n        if (_enableBookStyleOverrides) {\r\n            self.applyBookStyles();\r\n        }\r\n\r\n        updateMetaSize();\r\n\r\n        _pageTransitionHandler.updateOptions(settings);\r\n    };\r\n\r\n    function updateHtmlFontSize() {\r\n\r\n        if (!_enableBookStyleOverrides) return;\r\n\r\n        if (_$epubHtml && _viewSettings) {\r\n            Helpers.UpdateHtmlFontSize(_$epubHtml, _viewSettings.fontSize);\r\n        }\r\n    }\r\n\r\n    this.applyBookStyles = function () {\r\n\r\n        if (!_enableBookStyleOverrides) return;\r\n\r\n        if (_$epubHtml) {\r\n            Helpers.setStyles(_bookStyles.getStyles(), _$epubHtml);\r\n            updateHtmlFontSize();\r\n        }\r\n    };\r\n\r\n    //this is called by scroll_view for fixed spine item\r\n    this.scaleToWidth = function (width) {\r\n\r\n        if (_meta_size.width <= 0) return; // resize event too early!\r\n\r\n        var scale = width / _meta_size.width;\r\n        self.transformContentImmediate(scale, 0, 0);\r\n    };\r\n\r\n    //this is called by scroll_view for reflowable spine item\r\n    this.resizeIFrameToContent = function () {\r\n        var contHeight = getContentDocHeight();\r\n        //console.log(\"resizeIFrameToContent: \" + contHeight);\r\n\r\n        self.setHeight(contHeight);\r\n\r\n        self.showIFrame();\r\n    };\r\n\r\n    this.setHeight = function (height) {\r\n\r\n        _$scaler.css(\"height\", height + \"px\");\r\n        _$el.css(\"height\", height + \"px\");\r\n\r\n//        _$iframe.css(\"height\", height + \"px\");\r\n    };\r\n\r\n    var _useCSSTransformToHideIframe = true;\r\n\r\n    this.showIFrame = function () {\r\n\r\n        _$iframe.css(\"visibility\", \"visible\");\r\n\r\n        if (_useCSSTransformToHideIframe) {\r\n            _$iframe.css(\"transform\", \"none\");\r\n\r\n            var enable3D = false;\r\n            var settings = _viewSettings;\r\n            if (!settings || typeof settings.enableGPUHardwareAccelerationCSS3D === \"undefined\") {\r\n                //defaults\r\n                settings = new ViewerSettings({});\r\n            }\r\n            if (settings.enableGPUHardwareAccelerationCSS3D) {\r\n                enable3D = true;\r\n                _$iframe.css(\"transform\", \"translateZ(0)\");\r\n            }\r\n        }\r\n        else {\r\n            _$iframe.css({left: \"0px\", top: \"0px\"});\r\n        }\r\n    };\r\n\r\n    this.hideIFrame = function () {\r\n\r\n        _$iframe.css(\"visibility\", \"hidden\");\r\n\r\n        // With some books, despite the iframe and its containing div wrapper being hidden,\r\n        // the iframe's contentWindow / contentDocument is still visible!\r\n        // Thus why we translate the iframe out of view instead.\r\n\r\n        if (_useCSSTransformToHideIframe) {\r\n            var enable3D = false;\r\n            var settings = _viewSettings;\r\n            if (!settings || typeof settings.enableGPUHardwareAccelerationCSS3D === \"undefined\") {\r\n                //defaults\r\n                settings = new ViewerSettings({});\r\n            }\r\n            if (settings.enableGPUHardwareAccelerationCSS3D) {\r\n                enable3D = true;\r\n            }\r\n\r\n            var css = Helpers.CSSTransformString({left: \"10000\", top: \"10000\", enable3D: enable3D});\r\n            _$iframe.css(css);\r\n        }\r\n        else {\r\n            _$iframe.css({left: \"10000px\", top: \"10000px\"});\r\n        }\r\n    };\r\n\r\n    function getContentDocHeight() {\r\n\r\n        if (!_$iframe || !_$iframe.length) {\r\n            return 0;\r\n        }\r\n\r\n        if (Helpers.isIframeAlive(_$iframe[0])) {\r\n            var win = _$iframe[0].contentWindow;\r\n            var doc = _$iframe[0].contentDocument;\r\n\r\n            var height = Math.round(parseFloat(win.getComputedStyle(doc.documentElement).height)); //body can be shorter!\r\n            return height;\r\n        }\r\n        else if (_$epubHtml) {\r\n            console.error(\"getContentDocHeight ??\");\r\n\r\n            var jqueryHeight = _$epubHtml.height();\r\n            return jqueryHeight;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    // dir: 0 => new or same page, 1 => previous, 2 => next\r\n    this.updatePageSwitchDir = function (dir, hasChanged) {\r\n        _pageTransitionHandler.updatePageSwitchDir(dir, hasChanged);\r\n    };\r\n\r\n\r\n    this.transformContentImmediate = function (scale, left, top) {\r\n\r\n        var elWidth = Math.ceil(_meta_size.width * scale);\r\n        var elHeight = Math.floor(_meta_size.height * scale);\r\n\r\n        _pageTransitionHandler.transformContentImmediate_BEGIN(_$el, scale, left, top);\r\n\r\n        _$el.css(\"left\", left + \"px\");\r\n        _$el.css(\"top\", top + \"px\");\r\n        _$el.css(\"width\", elWidth + \"px\");\r\n        _$el.css(\"height\", elHeight + \"px\");\r\n\r\n        if (!_$epubHtml) {\r\n//                  debugger;\r\n            return;\r\n        }\r\n\r\n        var enable3D = false;\r\n        var settings = _viewSettings;\r\n        if (!settings || typeof settings.enableGPUHardwareAccelerationCSS3D === \"undefined\") {\r\n            //defaults\r\n            settings = new ViewerSettings({});\r\n        }\r\n        if (settings.enableGPUHardwareAccelerationCSS3D) {\r\n            enable3D = true;\r\n        }\r\n        \r\n        if (reader.needsFixedLayoutScalerWorkAround()) {\r\n            var css1 = Helpers.CSSTransformString({scale: scale, enable3D: enable3D});\r\n            \r\n            // See https://github.com/readium/readium-shared-js/issues/285 \r\n            css1[\"min-width\"] = _meta_size.width;\r\n            css1[\"min-height\"] = _meta_size.height;\r\n            \r\n            _$epubHtml.css(css1);\r\n            \r\n            // Ensures content dimensions matches viewport meta (authors / production tools should do this in their CSS...but unfortunately some don't).\r\n            if (_$epubBody && _$epubBody.length) {\r\n                _$epubBody.css({width:_meta_size.width, height:_meta_size.height});\r\n            }\r\n\r\n            var css2 = Helpers.CSSTransformString({scale : 1, enable3D: enable3D});\r\n            css2[\"width\"] = _meta_size.width * scale;\r\n            css2[\"height\"] = _meta_size.height * scale;\r\n\r\n            _$scaler.css(css2);\r\n        }\r\n        else {\r\n            var css = Helpers.CSSTransformString({scale: scale, enable3D: enable3D});\r\n            css[\"width\"] = _meta_size.width;\r\n            css[\"height\"] = _meta_size.height;\r\n            _$scaler.css(css);\r\n        }\r\n                \r\n        // Chrome workaround: otherwise text is sometimes invisible (probably a rendering glitch due to the 3D transform graphics backend?)\r\n        //_$epubHtml.css(\"visibility\", \"hidden\"); // \"flashing\" in two-page spread mode is annoying :(\r\n        _$epubHtml.css(\"opacity\", \"0.999\");\r\n\r\n        self.showIFrame();\r\n\r\n        setTimeout(function () {\r\n            //_$epubHtml.css(\"visibility\", \"visible\");\r\n            _$epubHtml.css(\"opacity\", \"1\");\r\n        }, 0);\r\n        \r\n        // TODO: the CSS transitions do not work anymore, tested on Firefox and Chrome.\r\n        // The line of code below still needs to be invoked, but the logic in _pageTransitionHandler probably need adjusting to work around the animation timing issue.\r\n        // PS: opacity=1 above seems to interfere with the fade-in transition, probably a browser issue with mixing inner-iframe effects with effects applied to the iframe parent/ancestors.\r\n        _pageTransitionHandler.transformContentImmediate_END(_$el, scale, left, top);\r\n    };\r\n\r\n    this.getCalculatedPageHeight = function () {\r\n        return _$el.height();\r\n    };\r\n\r\n    this.transformContent = _.bind(_.debounce(this.transformContentImmediate, 50), self);\r\n\r\n    function updateMetaSize() {\r\n\r\n        _meta_size.width = 0;\r\n        _meta_size.height = 0;\r\n\r\n        var size = undefined;\r\n\r\n        var isFallbackDimension = false;\r\n        var widthPercent = undefined;\r\n        var heightPercent = undefined;\r\n\r\n        var contentDocument = _$iframe[0].contentDocument;\r\n\r\n        // first try to read viewport size\r\n        var content = $('meta[name=viewport]', contentDocument).attr(\"content\");\r\n\r\n        // if not found try viewbox (used for SVG)\r\n        if (!content) {\r\n            content = $('meta[name=viewbox]', contentDocument).attr(\"content\");\r\n        }\r\n\r\n        if (content) {\r\n            size = parseMetaSize(content);\r\n        }\r\n\r\n        if (!size) {\r\n\r\n            //var $svg = $(contentDocument).find('svg');\r\n            // if($svg.length > 0) {\r\n            if (contentDocument && contentDocument.documentElement && contentDocument.documentElement.nodeName && contentDocument.documentElement.nodeName.toLowerCase() == \"svg\") {\r\n\r\n                var width = undefined;\r\n                var height = undefined;\r\n\r\n                var wAttr = contentDocument.documentElement.getAttribute(\"width\");\r\n                var isWidthPercent = wAttr && wAttr.length >= 1 && wAttr[wAttr.length - 1] == '%';\r\n                if (wAttr) {\r\n                    try {\r\n                        width = parseInt(wAttr, 10);\r\n                    }\r\n                    catch (err) {}\r\n                }\r\n                if (width && isWidthPercent) {\r\n                    widthPercent = width;\r\n                    width = undefined;\r\n                }\r\n\r\n                var hAttr = contentDocument.documentElement.getAttribute(\"height\");\r\n                var isHeightPercent = hAttr && hAttr.length >= 1 && hAttr[hAttr.length - 1] == '%';\r\n                if (hAttr) {\r\n                    try {\r\n                        height = parseInt(hAttr, 10);\r\n                    }\r\n                    catch (err) {}\r\n                }\r\n                if (height && isHeightPercent) {\r\n                    heightPercent = height;\r\n                    height = undefined;\r\n                }\r\n\r\n                if (width && height) {\r\n                    size = {\r\n                        width: width,\r\n                        height: height\r\n                    }\r\n                }\r\n                else {\r\n                    /// DISABLED (not a satisfactory fallback)\r\n                    // content = $svg.attr('viewBox');\r\n                    // if(content) {\r\n                    //     size = parseViewBoxSize(content);\r\n                    // }\r\n                    //\r\n                    // if (size) {\r\n                    //     console.warn(\"Viewport SVG: using viewbox!\");\r\n                    // }\r\n                }\r\n            }\r\n        }\r\n\r\n        if (!size && _currentSpineItem) {\r\n            content = _currentSpineItem.getRenditionViewport();\r\n\r\n            if (content) {\r\n                size = parseMetaSize(content);\r\n                if (size) {\r\n                    console.log(\"Viewport: using rendition:viewport dimensions\");\r\n                }\r\n            }\r\n        }\r\n\r\n        if (!size) {\r\n            // Image fallback (auto-generated HTML template when WebView / iFrame is fed with image media type)\r\n            var $img = $(contentDocument).find('img');\r\n            if ($img.length > 0) {\r\n                size = {\r\n                    width: $img.width(),\r\n                    height: $img.height()\r\n                };\r\n\r\n                var isImage = _currentSpineItem && _currentSpineItem.media_type && _currentSpineItem.media_type.length && _currentSpineItem.media_type.indexOf(\"image/\") == 0;\r\n                if (!isImage) {\r\n                    console.warn(\"Viewport: using img dimensions!\");\r\n                }\r\n            }\r\n            else {\r\n                $img = $(contentDocument).find('image');\r\n                if ($img.length > 0) {\r\n                    var width = undefined;\r\n                    var height = undefined;\r\n\r\n                    var wAttr = $img[0].getAttribute(\"width\");\r\n                    if (wAttr) {\r\n                        try {\r\n                            width = parseInt(wAttr, 10);\r\n                        }\r\n                        catch (err) {}\r\n                    }\r\n                    var hAttr = $img[0].getAttribute(\"height\");\r\n                    if (hAttr) {\r\n                        try {\r\n                            height = parseInt(hAttr, 10);\r\n                        }\r\n                        catch (err) {}\r\n                    }\r\n\r\n\r\n                    if (width && height) {\r\n                        size = {\r\n                            width: width,\r\n                            height: height\r\n                        };\r\n\r\n                        isFallbackDimension = true;\r\n\r\n                        console.warn(\"Viewport: using image dimensions!\");\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        if (!size) {\r\n            // Not a great fallback, as it has the aspect ratio of the full window, but it is better than no display at all.\r\n            width = _$viewport.width();\r\n            height = _$viewport.height();\r\n\r\n            // hacky method to determine the actual available horizontal space (half the two-page spread is a reasonable approximation, this means that whatever the size of the other iframe / one_page_view, the aspect ratio of this one exactly corresponds to half the viewport rendering surface)\r\n            var isTwoPageSyntheticSpread = $(\"iframe.iframe-fixed\", _$viewport).length > 1;\r\n            if (isTwoPageSyntheticSpread) width *= 0.5;\r\n\r\n            // the original SVG width/height might have been specified as a percentage of the containing viewport\r\n            if (widthPercent) {\r\n                width *= (widthPercent / 100);\r\n            }\r\n            if (heightPercent) {\r\n                height *= (heightPercent / 100);\r\n            }\r\n\r\n            size = {\r\n                width: width,\r\n                height: height\r\n            };\r\n\r\n            isFallbackDimension = true;\r\n\r\n            console.warn(\"Viewport: using browser / e-reader viewport dimensions!\");\r\n        }\r\n\r\n        if (size) {\r\n            _meta_size.width = size.width;\r\n            _meta_size.height = size.height;\r\n\r\n            // Not strictly necessary, let's preserve the percentage values\r\n            // if (isFallbackDimension && contentDocument && contentDocument.documentElement && contentDocument.documentElement.nodeName && contentDocument.documentElement.nodeName.toLowerCase() == \"svg\") {\r\n            //     contentDocument.documentElement.setAttribute(\"width\", size.width + \"px\");\r\n            //     contentDocument.documentElement.setAttribute(\"height\", size.height + \"px\");\r\n            // }\r\n        }\r\n    }\r\n\r\n    function onUnload (spineItem) {\r\n        if (spineItem) {\r\n            \r\n            Globals.logEvent(\"CONTENT_DOCUMENT_UNLOADED\", \"EMIT\", \"one_page_view.js [ \" + spineItem.href + \" ]\");\r\n            self.emit(Globals.Events.CONTENT_DOCUMENT_UNLOADED, _$iframe, spineItem);\r\n        }\r\n    }\r\n\r\n    this.onUnload = function () {\r\n        onUnload(_currentSpineItem);\r\n    };\r\n\r\n    //expected callback signature: function(success, $iframe, spineItem, isNewlyLoaded, context)\r\n    this.loadSpineItem = function (spineItem, callback, context) {\r\n\r\n        if (_currentSpineItem != spineItem) {\r\n\r\n            var prevSpineItem = _currentSpineItem;\r\n            _currentSpineItem = spineItem;\r\n            var src = _spine.package.resolveRelativeUrl(spineItem.href);\r\n\r\n            // both fixed layout and reflowable documents need hiding due to flashing during layout/rendering\r\n            //hide iframe until content is scaled\r\n            self.hideIFrame();\r\n\r\n            onUnload(prevSpineItem);\r\n\r\n\r\n            Globals.logEvent(\"OnePageView.Events.SPINE_ITEM_OPEN_START\", \"EMIT\", \"one_page_view.js [ \" + spineItem.href + \" -- \" + src + \" ]\");\r\n            self.emit(OnePageView.Events.SPINE_ITEM_OPEN_START, _$iframe, _currentSpineItem);\r\n            \r\n            _iframeLoader.loadIframe(_$iframe[0], src, function (success) {\r\n\r\n                if (success && callback) {\r\n                    var func = function () {\r\n                        callback(success, _$iframe, _currentSpineItem, true, context);\r\n                    };\r\n\r\n                    if (Helpers.isIframeAlive(_$iframe[0])) {\r\n                        onIFrameLoad(success); // applies styles\r\n\r\n                        func();\r\n                    }\r\n                    else {\r\n                        console.error(\"onIFrameLoad !! doc && win + TIMEOUT\");\r\n                        console.debug(spineItem.href);\r\n\r\n                        onIFrameLoad(success);\r\n\r\n                        setTimeout(func, 500);\r\n                    }\r\n                }\r\n                else {\r\n                    onIFrameLoad(success);\r\n                }\r\n\r\n            }, self, {spineItem: _currentSpineItem});\r\n        }\r\n        else {\r\n            if (callback) {\r\n                callback(true, _$iframe, _currentSpineItem, false, context);\r\n            }\r\n        }\r\n    };\r\n    //\r\n    // function parseViewBoxSize(viewBoxString) {\r\n    //\r\n    //     var parts = viewBoxString.split(' ');\r\n    //\r\n    //     if(parts.length < 4) {\r\n    //         console.warn(viewBoxString + \" value is not valid viewBox size\")\r\n    //         return undefined;\r\n    //     }\r\n    //\r\n    //     var width = parseInt(parts[2]);\r\n    //     var height = parseInt(parts[3]);\r\n    //\r\n    //     if(!isNaN(width) && !isNaN(height)) {\r\n    //         return { width: width, height: height} ;\r\n    //     }\r\n    //\r\n    //     return undefined;\r\n    // }\r\n\r\n    function parseMetaSize(content) {\r\n\r\n        var pairs = content.replace(/\\s/g, '').split(\",\");\r\n\r\n        var dict = {};\r\n\r\n        for (var i = 0; i < pairs.length; i++) {\r\n            var nameVal = pairs[i].split(\"=\");\r\n            if (nameVal.length == 2) {\r\n\r\n                dict[nameVal[0]] = nameVal[1];\r\n            }\r\n        }\r\n\r\n        var width = Number.NaN;\r\n        var height = Number.NaN;\r\n\r\n        if (dict[\"width\"]) {\r\n            width = parseInt(dict[\"width\"]);\r\n        }\r\n\r\n        if (dict[\"height\"]) {\r\n            height = parseInt(dict[\"height\"]);\r\n        }\r\n\r\n        if (!isNaN(width) && !isNaN(height)) {\r\n            return {width: width, height: height};\r\n        }\r\n\r\n        return undefined;\r\n    }\r\n\r\n    function getVisibleContentOffsets() {\r\n        return {\r\n            top: -_$el.parent().scrollTop(),\r\n            left: 0\r\n        };\r\n    }\r\n    \r\n    function getFrameDimensions() {\r\n        return {\r\n            width: _$el.parent()[0].clientWidth,\r\n            height: _$el.parent()[0].clientHeight\r\n        };\r\n    }\r\n    \r\n    this.getNavigator = function () {\r\n        return new CfiNavigationLogic({\r\n            $iframe: _$iframe,\r\n            frameDimensions: getFrameDimensions,\r\n            visibleContentOffsets: getVisibleContentOffsets,\r\n            classBlacklist: [\"cfi-marker\", \"mo-cfi-highlight\", \"resize-sensor\", \"resize-sensor-expand\", \"resize-sensor-shrink\"],\r\n            elementBlacklist: [],\r\n            idBlacklist: [\"MathJax_Message\", \"MathJax_SVG_Hidden\"]\r\n        });\r\n    };\r\n\r\n    this.getElementByCfi = function (spineItemIdref, cfi, classBlacklist, elementBlacklist, idBlacklist) {\r\n\r\n        if (spineItemIdref != _currentSpineItem.idref) {\r\n            console.error(\"spine item is not loaded\");\r\n            return undefined;\r\n        }\r\n\r\n        var navigation = self.getNavigator();\r\n        return navigation.getElementByCfi(cfi, classBlacklist, elementBlacklist, idBlacklist);\r\n    };\r\n\r\n    this.getElementById = function (spineItemIdref, id) {\r\n\r\n        if (spineItemIdref != _currentSpineItem.idref) {\r\n            console.error(\"spine item is not loaded\");\r\n            return undefined;\r\n        }\r\n\r\n        var navigation = self.getNavigator();\r\n        return navigation.getElementById(id);\r\n    };\r\n\r\n    this.getElement = function (spineItemIdref, selector) {\r\n\r\n        if(spineItemIdref != _currentSpineItem.idref) {\r\n            console.error(\"spine item is not loaded\");\r\n            return undefined;\r\n        }\r\n\r\n        var navigation = self.getNavigator();\r\n        return navigation.getElement(selector);\r\n    };\r\n\r\n    this.getFirstVisibleMediaOverlayElement = function() {\r\n        var navigation = self.getNavigator();\r\n        return navigation.getFirstVisibleMediaOverlayElement();\r\n    };\r\n\r\n    this.offset = function () {\r\n        if (_$iframe) {\r\n            return _$iframe.offset();\r\n        }\r\n        return undefined;\r\n    };\r\n\r\n    this.getVisibleElementsWithFilter = function (filterFunction) {\r\n        var navigation = self.getNavigator();\r\n        var elements = navigation.getVisibleElementsWithFilter(null, filterFunction);\r\n        return elements;\r\n    };\r\n\r\n    this.getVisibleElements = function (selector) {\r\n\r\n        var navigation = self.getNavigator();\r\n        var elements = navigation.getAllVisibleElementsWithSelector(selector);\r\n        return elements;\r\n    };\r\n\r\n    this.getAllElementsWithFilter = function (filterFunction, outsideBody) {\r\n        var navigation = self.getNavigator();\r\n        var elements = navigation.getAllElementsWithFilter(filterFunction, outsideBody);\r\n        return elements;\r\n    };\r\n\r\n    this.getElements = function(spineItemIdref, selector) {\r\n\r\n        if(spineItemIdref != _currentSpineItem.idref) {\r\n            console.error(\"spine item is not loaded\");\r\n            return undefined;\r\n        }\r\n\r\n        var navigation = self.getNavigator();\r\n\r\n        return navigation.getElements(selector);\r\n    };\r\n\r\n    this.getNodeRangeInfoFromCfi = function (spineIdRef, partialCfi) {\r\n        if (spineIdRef != _currentSpineItem.idref) {\r\n            console.warn(\"spine item is not loaded\");\r\n            return undefined;\r\n        }\r\n        var navigation = self.getNavigator();\r\n\r\n        return navigation.getNodeRangeInfoFromCfi(partialCfi);\r\n    };\r\n\r\n    function createBookmarkFromCfi(cfi){\r\n        return new BookmarkData(_currentSpineItem.idref, cfi);\r\n    }\r\n\r\n    this.getLoadedContentFrames = function () {\r\n        return [{spineItem: _currentSpineItem, $iframe: _$iframe}];\r\n    };\r\n\r\n    this.getFirstVisibleCfi = function (visibleContentOffsets, frameDimensions) {\r\n        return createBookmarkFromCfi(self.getNavigator().getFirstVisibleCfi(visibleContentOffsets, frameDimensions));\r\n    };\r\n\r\n    this.getLastVisibleCfi = function (visibleContentOffsets, frameDimensions) {\r\n        return createBookmarkFromCfi(self.getNavigator().getLastVisibleCfi(visibleContentOffsets, frameDimensions));\r\n    };\r\n\r\n    this.getDomRangeFromRangeCfi = function (rangeCfi, rangeCfi2, inclusive) {\r\n        return self.getNavigator().getDomRangeFromRangeCfi(rangeCfi, rangeCfi2, inclusive);\r\n    };\r\n\r\n    this.getRangeCfiFromDomRange = function (domRange) {\r\n        return createBookmarkFromCfi(self.getNavigator().getRangeCfiFromDomRange(domRange));\r\n    };\r\n\r\n    this.getVisibleCfiFromPoint = function (x, y, precisePoint) {\r\n        return createBookmarkFromCfi(self.getNavigator().getVisibleCfiFromPoint(x, y, precisePoint));\r\n    };\r\n\r\n    this.getRangeCfiFromPoints = function(startX, startY, endX, endY) {\r\n        return createBookmarkFromCfi(self.getNavigator().getRangeCfiFromPoints(startX, startY, endX, endY));\r\n    };\r\n\r\n    this.getCfiForElement = function(element) {\r\n        return createBookmarkFromCfi(self.getNavigator().getCfiForElement(element));\r\n    };\r\n\r\n    this.getElementFromPoint = function (x, y) {\r\n        return self.getNavigator().getElementFromPoint(x, y);\r\n    };\r\n\r\n};\r\n\r\nOnePageView.Events = {\r\n    SPINE_ITEM_OPEN_START: \"SpineItemOpenStart\",\r\n    CONTENT_SIZE_CHANGED: \"ContentSizeChanged\"\r\n};\r\nreturn OnePageView;\r\n});\r\n\n",
    "//  Created by Boris Schneiderman.\r\n//  Copyright (c) 2014 Readium Foundation and/or its licensees. All rights reserved.\r\n//  \r\n//  Redistribution and use in source and binary forms, with or without modification, \r\n//  are permitted provided that the following conditions are met:\r\n//  1. Redistributions of source code must retain the above copyright notice, this \r\n//  list of conditions and the following disclaimer.\r\n//  2. Redistributions in binary form must reproduce the above copyright notice, \r\n//  this list of conditions and the following disclaimer in the documentation and/or \r\n//  other materials provided with the distribution.\r\n//  3. Neither the name of the organization nor the names of its contributors may be \r\n//  used to endorse or promote products derived from this software without specific \r\n//  prior written permission.\r\n//  \r\n//  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND \r\n//  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED \r\n//  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. \r\n//  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, \r\n//  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, \r\n//  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, \r\n//  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF \r\n//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE \r\n//  OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED \r\n//  OF THE POSSIBILITY OF SUCH DAMAGE.\r\n\r\ndefine('readium_shared_js/models/page_open_request',[],function() {\r\n/**\r\n * Representation of opening page request\r\n * Provides the spine item to be opened and one of the following properties:\r\n *  spineItemPageIndex {Number},\r\n *  elementId {String},\r\n *  elementCfi {String},\r\n *  firstPage {bool},\r\n *  lastPage {bool}\r\n *\r\n * @class Models.PageOpenRequest\r\n * @constructor\r\n * @param {Models.SpineItem} spineItem\r\n * @param {object} [initiator]\r\n *\r\n\r\n */\r\nvar PageOpenRequest = function(spineItem, initiator) {\r\n\r\n    this.spineItem = spineItem;\r\n    this.spineItemPageIndex = undefined;\r\n    this.elementId = undefined;\r\n    this.elementCfi = undefined;\r\n    this.firstVisibleCfi = undefined;\r\n    this.lastVisibleCfi = undefined;\r\n    this.firstPage = false;\r\n    this.lastPage = false;\r\n    this.initiator = initiator;\r\n\r\n    /**\r\n     * Resets the reading system\r\n     *\r\n     * @method     reset\r\n     */\r\n\r\n    this.reset = function() {\r\n        this.spineItemPageIndex = undefined;\r\n        this.elementId = undefined;\r\n        this.elementCfi = undefined;\r\n        this.firstPage = false;\r\n        this.lastPage = false;\r\n    };\r\n\r\n    /**\r\n     * Sets the first page of the book\r\n     *\r\n     * @method     setFirstPage\r\n     */\r\n\r\n    this.setFirstPage = function() {\r\n        this.reset();\r\n        this.firstPage = true;\r\n    };\r\n\r\n    /**\r\n     * Sets the last page of the book\r\n     *\r\n     * @method     setLastPage\r\n     */\r\n\r\n    this.setLastPage = function() {\r\n        this.reset();\r\n        this.lastPage = true;\r\n    };\r\n\r\n    /**\r\n     * Sets the index of the book\r\n     *\r\n     * @method     setPageIndex\r\n     * @param      pageIndex\r\n     */\r\n\r\n    this.setPageIndex = function(pageIndex) {\r\n        this.reset();\r\n        this.spineItemPageIndex = pageIndex;\r\n    };\r\n\r\n    /**\r\n     * Sets the ID of the current element\r\n     *\r\n     * @method     setElementId\r\n     * @param      {number} elementId \r\n     */\r\n\r\n    this.setElementId = function(elementId) {\r\n        this.reset();\r\n        this.elementId = elementId;\r\n    };\r\n    \r\n    /**\r\n     * Sets the CFI of the current element\r\n     *\r\n     * @method     setElementCfi\r\n     * @param      elementCfi\r\n     */\r\n\r\n    this.setElementCfi = function(elementCfi) {\r\n        this.reset();\r\n        this.elementCfi = elementCfi;\r\n    };\r\n\r\n    // Used by ReflowView to better keep track of the current page\r\n    // using just a bookmark to firstVisibleElement makes the current\r\n    // page gradually shift to the beginning of the chapter. By bookmarking\r\n    // both the first and last visible elements, we can keep track of the \r\n    // \"middle\" of the visible area.\r\n    this.setFirstAndLastVisibleCfi = function(firstVisibleCfi, lastVisibleCfi) {\r\n        this.reset();\r\n        this.firstVisibleCfi = firstVisibleCfi;\r\n        this.lastVisibleCfi = lastVisibleCfi;\r\n    }\r\n\r\n};\r\n\r\nreturn PageOpenRequest;\r\n});\n",
    "//  Created by Boris Schneiderman.\r\n//  Copyright (c) 2014 Readium Foundation and/or its licensees. All rights reserved.\r\n//  \r\n//  Redistribution and use in source and binary forms, with or without modification, \r\n//  are permitted provided that the following conditions are met:\r\n//  1. Redistributions of source code must retain the above copyright notice, this \r\n//  list of conditions and the following disclaimer.\r\n//  2. Redistributions in binary form must reproduce the above copyright notice, \r\n//  this list of conditions and the following disclaimer in the documentation and/or \r\n//  other materials provided with the distribution.\r\n//  3. Neither the name of the organization nor the names of its contributors may be \r\n//  used to endorse or promote products derived from this software without specific \r\n//  prior written permission.\r\n//  \r\n//  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND \r\n//  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED \r\n//  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. \r\n//  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, \r\n//  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, \r\n//  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, \r\n//  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF \r\n//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE \r\n//  OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED \r\n//  OF THE POSSIBILITY OF SUCH DAMAGE.\r\n\r\ndefine ('readium_shared_js/views/fixed_view',[\"../globals\", \"jquery\", \"underscore\", \"eventEmitter\", \"../models/bookmark_data\", \"../models/current_pages_info\",\r\n    \"../models/fixed_page_spread\", \"./one_page_view\", \"../models/page_open_request\", \"../helpers\"],\r\n    function(Globals, $, _, EventEmitter, BookmarkData, CurrentPagesInfo,\r\n             Spread, OnePageView, PageOpenRequest, Helpers) {\r\n/**\r\n * View for rendering fixed layout page spread\r\n * @param options\r\n * @param reader\r\n * @constructor\r\n */\r\nvar FixedView = function(options, reader){\r\n\r\n    $.extend(this, new EventEmitter());\r\n\r\n    var self = this;\r\n\r\n    var _$el;\r\n    var _$viewport = options.$viewport;\r\n    var _spine = options.spine;\r\n    var _userStyles = options.userStyles;\r\n    var _bookStyles = options.bookStyles;\r\n    var _zoom = options.zoom || {style: 'default'};\r\n    var _currentScale;\r\n    var _iframeLoader = options.iframeLoader;\r\n    var _viewSettings = undefined;\r\n\r\n    var _leftPageView = createOnePageView(\"fixed-page-frame-left\");\r\n    var _rightPageView = createOnePageView(\"fixed-page-frame-right\");\r\n    var _centerPageView = createOnePageView(\"fixed-page-frame-center\");\r\n\r\n    var _pageViews = [];\r\n    _pageViews.push(_leftPageView);\r\n    _pageViews.push(_rightPageView);\r\n    _pageViews.push(_centerPageView);\r\n\r\n    var _spread = new Spread(_spine, false);\r\n    var _bookMargins;\r\n    var _contentMetaSize;\r\n    var _isRedrowing = false;\r\n    var _redrawRequest = false;\r\n\r\n    function createOnePageView(elementClass) {\r\n\r\n        var pageView = new OnePageView(options,\r\n        [elementClass],\r\n        false, //enableBookStyleOverrides\r\n        reader\r\n        );\r\n\r\n\r\n        pageView.on(OnePageView.Events.SPINE_ITEM_OPEN_START, function($iframe, spineItem) {\r\n            \r\n            Globals.logEvent(\"OnePageView.Events.SPINE_ITEM_OPEN_START\", \"ON\", \"fixed_view.js [ \" + spineItem.href + \" ]\");\r\n\r\n            Globals.logEvent(\"CONTENT_DOCUMENT_LOAD_START\", \"EMIT\", \"fixed_view.js [ \" + spineItem.href + \" ]\");\r\n            self.emit(Globals.Events.CONTENT_DOCUMENT_LOAD_START, $iframe, spineItem);\r\n        });\r\n\r\n        pageView.on(Globals.Events.CONTENT_DOCUMENT_UNLOADED, function($iframe, spineItem) {\r\n\r\n            Globals.logEvent(\"CONTENT_DOCUMENT_UNLOADED\", \"ON\", \"fixed_view.js [ \" + spineItem.href + \" ]\");\r\n\r\n            Globals.logEvent(\"CONTENT_DOCUMENT_UNLOADED\", \"EMIT\", \"fixed_view.js [ \" + spineItem.href + \" ]\");\r\n            self.emit(Globals.Events.CONTENT_DOCUMENT_UNLOADED, $iframe, spineItem);\r\n        });\r\n\r\n        return pageView;\r\n    }\r\n\r\n    this.isReflowable = function() {\r\n        return false;\r\n    };\r\n\r\n    this.setZoom = function(zoom){\r\n        _zoom = zoom;\r\n\r\n        resizeBook(false); \r\n    }\r\n\r\n    this.render = function(){\r\n\r\n        var template = Helpers.loadTemplate(\"fixed_book_frame\", {});\r\n\r\n        _$el = $(template);\r\n\r\n        Helpers.CSSTransition(_$el, \"all 0 ease 0\");\r\n        \r\n        _$el.css(\"overflow\", \"hidden\");\r\n        \r\n        // Removed, see one_page_view@render()\r\n        // var settings = reader.viewerSettings();\r\n        // if (!settings || typeof settings.enableGPUHardwareAccelerationCSS3D === \"undefined\")\r\n        // {\r\n        //     //defaults\r\n        //     settings = new Globals.Models.ViewerSettings({});\r\n        // }\r\n        // if (settings.enableGPUHardwareAccelerationCSS3D) {\r\n        //\r\n        //     // This fixes rendering issues with WebView (native apps), which crops content embedded in iframes unless GPU hardware acceleration is enabled for CSS rendering.\r\n        //     _$el.css(\"transform\", \"translateZ(0)\");\r\n        // }\r\n        \r\n        _$viewport.append(_$el);\r\n\r\n        self.applyStyles();\r\n\r\n        return this;\r\n    };\r\n\r\n    this.remove = function() {\r\n\r\n        _$el.remove();\r\n    };\r\n\r\n\r\n    this.setViewSettings = function(settings) {\r\n        \r\n        _viewSettings = settings;\r\n        \r\n        _spread.setSyntheticSpread(Helpers.deduceSyntheticSpread(_$viewport, getFirstVisibleItem(), _viewSettings) == true); // force boolean value (from truthy/falsey return value)\r\n\r\n        var views = getDisplayingViews();\r\n        for(var i = 0, count = views.length; i < count; i++) {\r\n            views[i].setViewSettings(settings);\r\n        }\r\n    };\r\n\r\n    function getFirstVisibleItem() {\r\n\r\n        var visibleItems = _spread.validItems();\r\n        return visibleItems[0];\r\n    }\r\n\r\n    function redraw(initiator, paginationRequest) {\r\n\r\n        if(_isRedrowing) {\r\n            _redrawRequest = {initiator: initiator, paginationRequest: paginationRequest};\r\n            return;\r\n        }\r\n\r\n        _isRedrowing = true;\r\n\r\n        var context = {isElementAdded : false};\r\n\r\n        var pageLoadDeferrals = createPageLoadDeferrals([\r\n            {pageView: _leftPageView, spineItem: _spread.leftItem, context: context},\r\n            {pageView: _rightPageView, spineItem: _spread.rightItem, context: context},\r\n            {pageView: _centerPageView, spineItem: _spread.centerItem, context: context}]);\r\n\r\n        $.when.apply($, pageLoadDeferrals).done(function(){\r\n            _isRedrowing = false;\r\n\r\n            if(_redrawRequest) {\r\n                var p1 = _redrawRequest.initiator;\r\n                var p2 = _redrawRequest.paginationRequest;\r\n                _redrawRequest = undefined;\r\n                redraw(p1, p2);\r\n            }\r\n            else {\r\n                \r\n                if(context.isElementAdded) {\r\n                    //self.applyStyles();\r\n                    \r\n                    Helpers.setStyles(_userStyles.getStyles(), _$el.parent());\r\n                    updateBookMargins();\r\n                    // updateContentMetaSize() and resizeBook() are invoked in onPagesLoaded below\r\n                }\r\n\r\n                if (paginationRequest)\r\n                {\r\n                    onPagesLoaded(initiator, paginationRequest.spineItem, paginationRequest.elementId)\r\n                }\r\n                else\r\n                {\r\n                    onPagesLoaded(initiator);\r\n                }\r\n            }\r\n\r\n        });\r\n\r\n    }\r\n\r\n    // dir: 0 => new or same page, 1 => previous, 2 => next\r\n    var updatePageSwitchDir = function(dir, hasChanged)\r\n    {\r\n        // irrespective of display state\r\n        if (_leftPageView) _leftPageView.updatePageSwitchDir(dir, hasChanged);\r\n        if (_rightPageView) _rightPageView.updatePageSwitchDir(dir, hasChanged);\r\n        if (_centerPageView) _centerPageView.updatePageSwitchDir(dir, hasChanged);\r\n\r\n        // var views = getDisplayingViews();\r\n        // for(var i = 0, count = views.length; i < count; i++) {\r\n        //     views[i].updatePageSwitchDir(dir, hasChanged);\r\n        // }\r\n    };\r\n    \r\n\r\n    this.applyStyles = function() {\r\n\r\n        Helpers.setStyles(_userStyles.getStyles(), _$el.parent());\r\n        updateBookMargins();\r\n        \r\n        updateContentMetaSize();\r\n        resizeBook();\r\n    };\r\n\r\n    this.applyBookStyles = function() {\r\n\r\n        var views = getDisplayingViews();\r\n\r\n        for(var i = 0, count = views.length; i < count; i++) {\r\n            views[i].applyBookStyles();\r\n        }\r\n    };\r\n\r\n    function createPageLoadDeferrals(viewItemPairs) {\r\n\r\n        var pageLoadDeferrals = [];\r\n\r\n        for(var i = 0; i < viewItemPairs.length; i++) {\r\n\r\n            var dfd = updatePageViewForItem(viewItemPairs[i].pageView, viewItemPairs[i].spineItem, viewItemPairs[i].context);\r\n            pageLoadDeferrals.push(dfd);\r\n        }\r\n\r\n        return pageLoadDeferrals;\r\n\r\n    }\r\n\r\n    function onPagesLoaded(initiator, paginationRequest_spineItem, paginationRequest_elementId) {\r\n        \r\n        updateContentMetaSize();\r\n        resizeBook();\r\n        \r\n        window.setTimeout(function () {\r\n            \r\n            Globals.logEvent(\"InternalEvents.CURRENT_VIEW_PAGINATION_CHANGED\", \"EMIT\", \"fixed_view.js\");\r\n            self.emit(Globals.InternalEvents.CURRENT_VIEW_PAGINATION_CHANGED, {\r\n                paginationInfo: self.getPaginationInfo(),\r\n                initiator: initiator,\r\n                spineItem: paginationRequest_spineItem,\r\n                elementId: paginationRequest_elementId\r\n            });\r\n        }, 60);\r\n        //this delay of 60ms is to ensure that it triggers\r\n        // after any other 10-50ms timers that defer the pagination process in OnePageView\r\n    }\r\n\r\n    this.onViewportResize = function() {\r\n\r\n        //because change of the viewport orientation can alter pagination behaviour we have to check if\r\n        //visible content stays same\r\n\r\n        var firstVisibleItem = getFirstVisibleItem();\r\n        if(!firstVisibleItem) {\r\n            return;\r\n        }\r\n\r\n        var isSyntheticSpread = Helpers.deduceSyntheticSpread(_$viewport, firstVisibleItem, _viewSettings) == true; // force boolean value (from truthy/falsey return value)\r\n\r\n        if(isSpreadChanged(firstVisibleItem, isSyntheticSpread)) {\r\n            _spread.setSyntheticSpread(isSyntheticSpread);\r\n            var paginationRequest = new PageOpenRequest(firstVisibleItem, self);\r\n            self.openPage(paginationRequest);\r\n        }\r\n        else {\r\n            resizeBook(true);\r\n        }\r\n    };\r\n\r\n    function isSpreadChanged(firstVisibleItem, isSyntheticSpread) {\r\n\r\n        var tmpSpread = new Spread(_spine, isSyntheticSpread);\r\n        tmpSpread.openItem(firstVisibleItem);\r\n\r\n        return _spread.leftItem != tmpSpread.leftItem || _spread.rightItem != tmpSpread.rightItem || _spread.centerItem != tmpSpread.centerItem;\r\n    }\r\n\r\n    this.getViewScale = function(){\r\n        return _currentScale;\r\n    };\r\n\r\n    function isContentRendered() {\r\n\r\n        if(!_contentMetaSize || !_bookMargins) {\r\n            return false;\r\n        }\r\n\r\n        var viewportWidth = _$viewport.width();\r\n        var viewportHeight = _$viewport.height();\r\n\r\n        return viewportWidth && viewportHeight;\r\n    }\r\n\r\n    function resizeBook(viewportIsResizing) {\r\n\r\n        updatePageSwitchDir(0, false);\r\n        \r\n        if(!isContentRendered()) {\r\n            return;\r\n        }\r\n\r\n        var viewportWidth = _$viewport.width();\r\n        var viewportHeight = _$viewport.height();\r\n\r\n        var leftPageMargins = _leftPageView.isDisplaying() ? Helpers.Margins.fromElement(_leftPageView.element()) : Helpers.Margins.empty();\r\n        var rightPageMargins = _rightPageView.isDisplaying() ? Helpers.Margins.fromElement(_rightPageView.element()) : Helpers.Margins.empty();\r\n        var centerPageMargins = _centerPageView.isDisplaying() ? Helpers.Margins.fromElement(_centerPageView.element()) : Helpers.Margins.empty();\r\n\r\n        var pageMargins = getMaxPageMargins(leftPageMargins, rightPageMargins, centerPageMargins);\r\n\r\n        var potentialTargetElementSize = {   width: viewportWidth - _bookMargins.width(),\r\n                                             height: viewportHeight - _bookMargins.height()};\r\n\r\n        var potentialContentSize = {    width: potentialTargetElementSize.width - pageMargins.width(),\r\n                                        height: potentialTargetElementSize.height - pageMargins.height() };\r\n\r\n        if(potentialTargetElementSize.width <= 0 || potentialTargetElementSize.height <= 0) {\r\n            return;\r\n        }\r\n\r\n        var horScale = potentialContentSize.width / _contentMetaSize.width;\r\n        var verScale = potentialContentSize.height / _contentMetaSize.height;\r\n        \r\n        _$viewport.css(\"overflow\", \"auto\");\r\n            \r\n        var scale;\r\n        if (_zoom.style == 'fit-width'){\r\n            scale = horScale;\r\n        }\r\n        else if (_zoom.style == 'fit-height'){\r\n            scale = verScale;\r\n        }\r\n        else if (_zoom.style == 'user'){\r\n            scale = _zoom.scale;\r\n        }\r\n        else{\r\n            scale = Math.min(horScale, verScale);\r\n\r\n            // no need for pan during \"viewport fit\" zoom\r\n            _$viewport.css(\"overflow\", \"hidden\");\r\n        }\r\n\r\n        _currentScale = scale;\r\n\r\n        var contentSize = { width: _contentMetaSize.width * scale,\r\n                            height: _contentMetaSize.height * scale };\r\n\r\n        var targetElementSize = {   width: contentSize.width + pageMargins.width(),\r\n                                    height: contentSize.height + pageMargins.height() };\r\n\r\n        var bookSize = {    width: targetElementSize.width + _bookMargins.width(),\r\n                            height: targetElementSize.height + _bookMargins.height() };\r\n\r\n\r\n        var bookLeft = Math.floor((viewportWidth - bookSize.width) / 2);\r\n        var bookTop = Math.floor((viewportHeight - bookSize.height) / 2);\r\n\r\n        if(bookLeft < 0) bookLeft = 0;\r\n        if(bookTop < 0) bookTop = 0;\r\n        \r\n        _$el.css(\"left\", bookLeft + \"px\");\r\n        _$el.css(\"top\", bookTop + \"px\");\r\n        _$el.css(\"width\", targetElementSize.width + \"px\");\r\n        _$el.css(\"height\", targetElementSize.height + \"px\");\r\n\r\n        var left = _bookMargins.padding.left;\r\n        var top = _bookMargins.padding.top;\r\n\r\n        var transFunc = viewportIsResizing ? \"transformContentImmediate\" : \"transformContent\";\r\n\r\n        if(_leftPageView.isDisplaying()) {\r\n\r\n             _leftPageView[transFunc](scale, left, top);\r\n        }\r\n\r\n        if(_rightPageView.isDisplaying()) {\r\n\r\n            left += _contentMetaSize.separatorPosition * scale;\r\n\r\n            if(_leftPageView.isDisplaying()) {\r\n                left += leftPageMargins.left;\r\n            }\r\n\r\n            _rightPageView[transFunc](scale, left, top);\r\n        }\r\n\r\n        if(_centerPageView.isDisplaying()) {\r\n\r\n            _centerPageView[transFunc](scale, left, top);\r\n        }\r\n        \r\n        Globals.logEvent(\"FXL_VIEW_RESIZED\", \"EMIT\", \"fixed_view.js\");\r\n        self.emit(Globals.Events.FXL_VIEW_RESIZED);\r\n    }\r\n\r\n    function getMaxPageMargins(leftPageMargins, rightPageMargins, centerPageMargins) {\r\n\r\n         var sumMargin = {\r\n            left: Math.max(leftPageMargins.margin.left, rightPageMargins.margin.left, centerPageMargins.margin.left),\r\n            right: Math.max(leftPageMargins.margin.right, rightPageMargins.margin.right, centerPageMargins.margin.right),\r\n            top: Math.max(leftPageMargins.margin.top, rightPageMargins.margin.top, centerPageMargins.margin.top),\r\n            bottom: Math.max(leftPageMargins.margin.bottom, rightPageMargins.margin.bottom, centerPageMargins.margin.bottom)\r\n        };\r\n\r\n        var sumBorder = {\r\n            left: Math.max(leftPageMargins.border.left, rightPageMargins.border.left, centerPageMargins.border.left),\r\n            right: Math.max(leftPageMargins.border.right, rightPageMargins.border.right, centerPageMargins.border.right),\r\n            top: Math.max(leftPageMargins.border.top, rightPageMargins.border.top, centerPageMargins.border.top),\r\n            bottom: Math.max(leftPageMargins.border.bottom, rightPageMargins.border.bottom, centerPageMargins.border.bottom)\r\n        };\r\n\r\n        var sumPAdding = {\r\n            left: Math.max(leftPageMargins.padding.left, rightPageMargins.padding.left, centerPageMargins.padding.left),\r\n            right: Math.max(leftPageMargins.padding.right, rightPageMargins.padding.right, centerPageMargins.padding.right),\r\n            top: Math.max(leftPageMargins.padding.top, rightPageMargins.padding.top, centerPageMargins.padding.top),\r\n            bottom: Math.max(leftPageMargins.padding.bottom, rightPageMargins.padding.bottom, centerPageMargins.padding.bottom)\r\n        };\r\n\r\n        return new Helpers.Margins(sumMargin, sumBorder, sumPAdding);\r\n\r\n    }\r\n\r\n    function updateContentMetaSize() {\r\n\r\n        _contentMetaSize = {};\r\n\r\n        if(_centerPageView.isDisplaying()) {\r\n            _contentMetaSize.width = _centerPageView.meta_width();\r\n            _contentMetaSize.height = _centerPageView.meta_height();\r\n            _contentMetaSize.separatorPosition = 0;\r\n        }\r\n        else if(_leftPageView.isDisplaying() && _rightPageView.isDisplaying()) {\r\n            if(_leftPageView.meta_height() == _rightPageView.meta_height()) {\r\n                _contentMetaSize.width = _leftPageView.meta_width() + _rightPageView.meta_width();\r\n                _contentMetaSize.height = _leftPageView.meta_height();\r\n                _contentMetaSize.separatorPosition = _leftPageView.meta_width();\r\n            }\r\n            else {\r\n                //normalize by height\r\n                _contentMetaSize.width = _leftPageView.meta_width() + _rightPageView.meta_width() * (_leftPageView.meta_height() / _rightPageView.meta_height());\r\n                _contentMetaSize.height = _leftPageView.meta_height();\r\n                _contentMetaSize.separatorPosition = _leftPageView.meta_width();\r\n            }\r\n        }\r\n        else if(_leftPageView.isDisplaying()) {\r\n            _contentMetaSize.width = _leftPageView.meta_width() * 2;\r\n            _contentMetaSize.height = _leftPageView.meta_height();\r\n            _contentMetaSize.separatorPosition = _leftPageView.meta_width();\r\n        }\r\n        else if(_rightPageView.isDisplaying()) {\r\n            _contentMetaSize.width = _rightPageView.meta_width() * 2;\r\n            _contentMetaSize.height = _rightPageView.meta_height();\r\n            _contentMetaSize.separatorPosition = _rightPageView.meta_width();\r\n        }\r\n        else {\r\n            _contentMetaSize = undefined;\r\n        }\r\n\r\n    }\r\n\r\n    function updateBookMargins() {\r\n        _bookMargins = Helpers.Margins.fromElement(_$el);\r\n    }\r\n\r\n    // dir: 0 => new or same page, 1 => previous, 2 => next\r\n    this.openPage =  function(paginationRequest, dir) {\r\n\r\n        if(!paginationRequest.spineItem) {\r\n            return;\r\n        }\r\n\r\n        var leftItem = _spread.leftItem;\r\n        var rightItem = _spread.rightItem;\r\n        var centerItem = _spread.centerItem;\r\n\r\n        var isSyntheticSpread = Helpers.deduceSyntheticSpread(_$viewport, paginationRequest.spineItem, _viewSettings) == true; // force boolean value (from truthy/falsey return value)\r\n        _spread.setSyntheticSpread(isSyntheticSpread);\r\n        _spread.openItem(paginationRequest.spineItem);\r\n        \r\n        var hasChanged = leftItem !== _spread.leftItem || rightItem !== _spread.rightItem || centerItem !== _spread.centerItem;\r\n        \r\n        if (dir === null || typeof dir === \"undefined\") dir = 0;\r\n        \r\n        updatePageSwitchDir(dir === 0 ? 0 : (_spread.spine.isRightToLeft() ? (dir === 1 ? 2 : 1) : dir), hasChanged);\r\n        \r\n        redraw(paginationRequest.initiator, paginationRequest);\r\n    };\r\n\r\n\r\n    this.openPagePrev = function(initiator) {\r\n\r\n        _spread.openPrev();\r\n        \r\n        updatePageSwitchDir(_spread.spine.isRightToLeft() ? 2 : 1, true);\r\n        \r\n        redraw(initiator, undefined);\r\n    };\r\n\r\n    this.openPageNext = function(initiator) {\r\n\r\n        _spread.openNext();\r\n        \r\n        updatePageSwitchDir(_spread.spine.isRightToLeft() ? 1 : 2, true);\r\n        \r\n        redraw(initiator, undefined);\r\n    };\r\n\r\n    function updatePageViewForItem(pageView, item, context) {\r\n\r\n        var dfd = $.Deferred();\r\n\r\n        if(!item) {\r\n            if(pageView.isDisplaying()) {\r\n                pageView.remove();\r\n            }\r\n\r\n            dfd.resolve();\r\n        }\r\n        else {\r\n\r\n            //if(pageView.isDisplaying()) { // always DO (no iframe reuse, as this creates problems with BlobURIs, and navigator history ... just like the reflowable view, we re-create an iframe from the template whenever needed for a new spine item URI)\r\n            pageView.remove();\r\n            \r\n            //if(!pageView.isDisplaying()) { // always TRUE\r\n            _$el.append(pageView.render().element());\r\n            context.isElementAdded = true;\r\n        \r\n\r\n            pageView.loadSpineItem(item, function(success, $iframe, spineItem, isNewContentDocumentLoaded, context){\r\n\r\n                if(success && isNewContentDocumentLoaded) {\r\n\r\n                    //if we a re loading fixed view meta size should be defined\r\n                    if(!pageView.meta_height() || !pageView.meta_width()) {\r\n                        console.error(\"Invalid document \" + spineItem.href + \": viewport is not specified!\");\r\n                    }\r\n\r\n                    Globals.logEvent(\"CONTENT_DOCUMENT_LOADED\", \"EMIT\", \"fixed_view.js [ \" + spineItem.href + \" ]\");\r\n                    self.emit(Globals.Events.CONTENT_DOCUMENT_LOADED, $iframe, spineItem);\r\n                }\r\n\r\n                dfd.resolve();\r\n\r\n            }, context);\r\n        }\r\n\r\n        return dfd.promise();\r\n    }\r\n\r\n    this.getPaginationInfo = function() {\r\n\r\n        var paginationInfo = new CurrentPagesInfo(_spine, true);\r\n\r\n        var spreadItems = [_spread.leftItem, _spread.rightItem, _spread.centerItem];\r\n\r\n        for(var i = 0; i < spreadItems.length; i++) {\r\n\r\n            var spreadItem = spreadItems[i];\r\n\r\n            if(spreadItem) {\r\n                paginationInfo.addOpenPage(0, 1, spreadItem.idref, spreadItem.index);\r\n            }\r\n        }\r\n\r\n        return paginationInfo;\r\n    };\r\n\r\n    this.bookmarkCurrentPage = function() {\r\n\r\n        var views = getDisplayingViews();\r\n\r\n        if(views.length > 0) {\r\n\r\n            return views[0].getFirstVisibleCfi();\r\n        }\r\n\r\n        return undefined;\r\n    };\r\n\r\n    function getDisplayingViews() {\r\n\r\n        var viewsToCheck = [];\r\n\r\n        if( _spine.isLeftToRight() ) {\r\n            viewsToCheck = [_leftPageView, _centerPageView, _rightPageView];\r\n        }\r\n        else {\r\n            viewsToCheck = [_rightPageView, _centerPageView, _leftPageView];\r\n        }\r\n\r\n        var views = [];\r\n\r\n        for(var i = 0, count = viewsToCheck.length; i < count; i++) {\r\n            if(viewsToCheck[i].isDisplaying()) {\r\n                views.push(viewsToCheck[i]);\r\n            }\r\n        }\r\n\r\n        return views;\r\n    }\r\n\r\n    this.getLoadedSpineItems = function() {\r\n\r\n        return _spread.validItems();\r\n    };\r\n\r\n    function callOnPageView(spineItemIdref, fn) {\r\n        var views = getDisplayingViews();\r\n\r\n        for (var i = 0, count = views.length; i < count; i++) {\r\n\r\n            var view = views[i];\r\n            if (view.currentSpineItem().idref == spineItemIdref) {\r\n                return fn(view);\r\n            }\r\n        }\r\n\r\n        console.error(\"spine item is not loaded\");\r\n        return undefined;\r\n    }\r\n\r\n    this.getElement = function (spineItemIdref, selector) {\r\n\r\n        return callOnPageView(spineItemIdref, function (view) {\r\n            return view.getElement(spineItemIdref, selector);\r\n        });\r\n    };\r\n\r\n    this.getElementById = function (spineItemIdref, id) {\r\n\r\n        return callOnPageView(spineItemIdref, function (view) {\r\n            return view.getElementById(spineItemIdref, id);\r\n        });\r\n    };\r\n\r\n\r\n    this.getElementByCfi = function(spineItemIdref, cfi, classBlacklist, elementBlacklist, idBlacklist) {\r\n\r\n        return callOnPageView(spineItemIdref, function (view) {\r\n            return view.getElementByCfi(spineItemIdref, cfi, classBlacklist, elementBlacklist, idBlacklist);\r\n        });\r\n    };\r\n    \r\n    this.getFirstVisibleMediaOverlayElement = function() {\r\n\r\n        var views = getDisplayingViews();\r\n\r\n        for(var i = 0, count = views.length; i < count; i++) {\r\n            var el = views[i].getFirstVisibleMediaOverlayElement();\r\n            if (el) return el;\r\n        }\r\n\r\n        return undefined;\r\n    };\r\n\r\n    this.insureElementVisibility = function(spineItemId, element, initiator) {\r\n\r\n        //TODO: during zoom+pan, playing element might not actually be visible\r\n\r\n    };\r\n    \r\n    this.getElements = function(spineItemIdref, selector) {\r\n\r\n        return callOnPageView(spineItemIdref, function (view) {\r\n            return view.getElements(spineItemIdref, selector);\r\n        });\r\n    };\r\n    \r\n    this.isElementVisible = function($element){\r\n\r\n        //for now we assume that for fixed layouts, elements are always visible\r\n        return true;\r\n    };\r\n    \r\n    this.getVisibleElementsWithFilter = function(filterFunction, includeSpineItems) {\r\n\r\n        var elements = [];\r\n\r\n        var views = getDisplayingViews();\r\n\r\n        for(var i = 0, count = views.length; i < count; i++) {\r\n            //for now we assume that for fixed layouts, elements are always visible\r\n            elements.push(views[i].getAllElementsWithFilter(filterFunction, includeSpineItems));\r\n        }\r\n\r\n        return elements;\r\n    };\r\n\r\n    this.getVisibleElements = function (selector, includeSpineItems) {\r\n\r\n        var elements = [];\r\n\r\n        var views = getDisplayingViews();\r\n\r\n        for (var i = 0, count = views.length; i < count; i++) {\r\n            //for now we assume that for fixed layouts, elements are always visible\r\n            if (includeSpineItems) {\r\n                elements.push({elements: views[i].getElements(views[i].currentSpineItem().idref, selector), spineItem: views[i].currentSpineItem()});\r\n            } else {\r\n                elements.push(views[i].getElements(views[i].currentSpineItem().idref, selector));\r\n            }\r\n        }\r\n\r\n        return elements;\r\n    };\r\n\r\n    this.isElementVisible = function($element){\r\n\r\n        //for now we assume that for fixed layouts, elements are always visible\r\n        return true;\r\n    };\r\n    \r\n    this.isVisibleSpineItemElementCfi = function (spineItemIdref, partialCfi) {\r\n\r\n        return callOnPageView(spineItemIdref, function (view) {\r\n            //for now we assume that for fixed layouts, everything is always visible\r\n            return true;\r\n        });\r\n    };\r\n\r\n    this.getNodeRangeInfoFromCfi = function (spineItemIdref, partialCfi) {\r\n\r\n        return callOnPageView(spineItemIdref, function (view) {\r\n            return view.getNodeRangeInfoFromCfi(spineItemIdref, partialCfi);\r\n        });\r\n    };\r\n\r\n\r\n    this.getFirstVisibleCfi = function () {\r\n        var views = getDisplayingViews();\r\n        if (views.length > 0) {\r\n            return views[0].getFirstVisibleCfi();\r\n        }\r\n        return undefined;\r\n    };\r\n\r\n    this.getLastVisibleCfi = function () {\r\n        var views = getDisplayingViews();\r\n        if (views.length > 0) {\r\n            return views[views.length - 1].getLastVisibleCfi();\r\n        }\r\n        return undefined;\r\n    };\r\n\r\n    this.getDomRangesFromRangeCfi = function (rangeCfi, rangeCfi2, inclusive) {\r\n        var views = getDisplayingViews();\r\n        if (rangeCfi2 && rangeCfi.idref !== rangeCfi2.idref) {\r\n            var ranges = [];\r\n            for (var i = 0, count = views.length; i < count; i++) {\r\n                var view = views[i];\r\n                if (view.currentSpineItem().idref === rangeCfi.idref) {\r\n                    var last = view.getLastVisibleCfi();\r\n                    ranges.push(view.getDomRangeFromRangeCfi(rangeCfi.contentCFI, last.contentCFI, inclusive));\r\n                } else if (view.currentSpineItem().idref === rangeCfi2.idref) {\r\n                    var first = view.getFirstVisibleCfi();\r\n                    ranges.push(view.getDomRangeFromRangeCfi(first.contentCFI, rangeCfi2.contentCFI, inclusive));\r\n                }\r\n            }\r\n            return ranges;\r\n        }\r\n\r\n        return [this.getDomRangeFromRangeCfi(rangeCfi, rangeCfi2, inclusive)];\r\n    },\r\n\r\n    this.getDomRangeFromRangeCfi = function (rangeCfi, rangeCfi2, inclusive) {\r\n        var views = getDisplayingViews();\r\n        if (rangeCfi2 && rangeCfi.idref !== rangeCfi2.idref) {\r\n            console.error(\"getDomRangeFromRangeCfi: both CFIs must be scoped under the same spineitem idref\");\r\n            return undefined;\r\n        }\r\n        for (var i = 0, count = views.length; i < count; i++) {\r\n\r\n            var view = views[i];\r\n            if (view.currentSpineItem().idref === rangeCfi.idref) {\r\n                return view.getDomRangeFromRangeCfi(rangeCfi.contentCFI, rangeCfi2 ? rangeCfi2.contentCFI : null, inclusive);\r\n            }\r\n        }\r\n\r\n        return undefined;\r\n    };\r\n\r\n    this.getRangeCfiFromDomRange = function (domRange) {\r\n\r\n        var views = getDisplayingViews();\r\n\r\n        for (var i = 0, count = views.length; i < count; i++) {\r\n\r\n            var view = views[i];\r\n            if (view.getLoadedContentFrames()[0].$iframe[0].contentDocument === domRange.startContainer.ownerDocument) {\r\n                return view.getRangeCfiFromDomRange(domRange);\r\n            }\r\n        }\r\n\r\n        return undefined;\r\n    };\r\n\r\n    this.getVisibleCfiFromPoint = function (x, y, precisePoint, spineItemIdref) {\r\n        if (!spineItemIdref) {\r\n            throw new Error(\"getVisibleCfiFromPoint: Spine item idref must be specified for this fixed layout view.\");\r\n        }\r\n        return callOnPageView(spineItemIdref, function (view) {\r\n            return view.getVisibleCfiFromPoint(x,y, precisePoint);\r\n        });\r\n    };\r\n\r\n    this.getRangeCfiFromPoints = function (startX, startY, endX, endY, spineItemIdref) {\r\n        if (!spineItemIdref) {\r\n            throw new Error(\"getRangeCfiFromPoints: Spine item idref must be specified for this fixed layout view.\");\r\n        }\r\n        return callOnPageView(spineItemIdref, function (view) {\r\n            return view.getRangeCfiFromPoints(startX, startY, endX, endY);\r\n        });\r\n    };\r\n\r\n    this.getCfiForElement = function (element) {\r\n\r\n        var views = getDisplayingViews();\r\n\r\n        for (var i = 0, count = views.length; i < count; i++) {\r\n\r\n            var view = views[i];\r\n            if (view.getLoadedContentFrames()[0].$iframe[0].contentDocument === element.ownerDocument) {\r\n                return view.getCfiForElement(element);\r\n            }\r\n        }\r\n\r\n        return undefined;\r\n    };\r\n\r\n    this.getElementFromPoint = function (x, y, spineItemIdref) {\r\n        if (!spineItemIdref) {\r\n            throw new Error(\"getElementFromPoint: Spine item idref must be specified for this fixed layout view.\");\r\n        }\r\n        return callOnPageView(spineItemIdref, function (view) {\r\n            return view.getElementFromPoint(x,y);\r\n        });\r\n    };\r\n\r\n};\r\n    return FixedView;\r\n});\r\n\n",
    "//  LauncherOSX\r\n//\r\n//  Created by Boris Schneiderman.\r\n// Modified by Daniel Weck\r\n//  Copyright (c) 2014 Readium Foundation and/or its licensees. All rights reserved.\r\n//  \r\n//  Redistribution and use in source and binary forms, with or without modification, \r\n//  are permitted provided that the following conditions are met:\r\n//  1. Redistributions of source code must retain the above copyright notice, this \r\n//  list of conditions and the following disclaimer.\r\n//  2. Redistributions in binary form must reproduce the above copyright notice, \r\n//  this list of conditions and the following disclaimer in the documentation and/or \r\n//  other materials provided with the distribution.\r\n//  3. Neither the name of the organization nor the names of its contributors may be \r\n//  used to endorse or promote products derived from this software without specific \r\n//  prior written permission.\r\n//  \r\n//  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND \r\n//  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED \r\n//  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. \r\n//  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, \r\n//  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, \r\n//  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, \r\n//  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF \r\n//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE \r\n//  OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED \r\n//  OF THE POSSIBILITY OF SUCH DAMAGE.\r\n\r\ndefine('readium_shared_js/views/iframe_loader',[\"jquery\", \"underscore\"], function($, _) {\r\n/**\r\n *\r\n * @constructor\r\n */\r\nvar IFrameLoader = function() {\r\n\r\n    var self = this;\r\n    var eventListeners = {};\r\n\r\n\r\n    this.addIFrameEventListener = function (eventName, callback, context) {\r\n\r\n        if (eventListeners[eventName] == undefined) {\r\n            eventListeners[eventName] = [];\r\n        }\r\n\r\n        eventListeners[eventName].push({callback: callback, context: context});\r\n    };\r\n\r\n    this.updateIframeEvents = function (iframe) {\r\n\r\n        _.each(eventListeners, function (value, key) {\r\n            $(iframe.contentWindow).off(key);\r\n            for (var i = 0, count = value.length; i < count; i++) {\r\n                $(iframe.contentWindow).on(key, value[i].callback, value[i].context);\r\n            }\r\n        });\r\n    };\r\n\r\n    this.loadIframe = function (iframe, src, callback, context, attachedData) {\r\n\r\n        if (!iframe.baseURI) {\r\n            if (typeof location !== 'undefined') {\r\n                iframe.baseURI = location.href + \"\";\r\n            }\r\n            console.error(\"!iframe.baseURI => \" + iframe.baseURI);\r\n        }\r\n    \r\n        console.log(\"EPUB doc iframe src:\");\r\n        console.log(src);\r\n        console.log(\"EPUB doc iframe base URI:\");\r\n        console.log(iframe.baseURI);\r\n        \r\n        iframe.setAttribute(\"data-baseUri\", iframe.baseURI);\r\n        iframe.setAttribute(\"data-src\", src);\r\n\r\n        var loadedDocumentUri = new URI(src).absoluteTo(iframe.baseURI).search('').hash('').toString();\r\n\r\n        self._loadIframeWithUri(iframe, attachedData, loadedDocumentUri, function () {\r\n            \r\n            callback.call(context, true, attachedData);\r\n        });\r\n    };\r\n\r\n    this._loadIframeWithUri = function (iframe, attachedData, contentUri, callback) {\r\n\r\n        iframe.onload = function () {\r\n\r\n            var doc = iframe.contentDocument || iframe.contentWindow.document;\r\n            $('svg', doc).on(\"load\", function(){\r\n                console.log('SVG loaded');\r\n            });\r\n            \r\n            self.updateIframeEvents(iframe);\r\n\r\n            var mathJax = iframe.contentWindow.MathJax;\r\n            if (mathJax) {\r\n                \r\n                console.log(\"MathJax VERSION: \" + mathJax.cdnVersion + \" // \" + mathJax.fileversion + \" // \" + mathJax.version);\r\n    \r\n                var useFontCache = true; // default in MathJax\r\n                \r\n                // Firefox fails to render SVG otherwise\r\n                if (mathJax.Hub.Browser.isFirefox) {\r\n                    useFontCache = false;\r\n                }\r\n                \r\n                // Chrome 49+ fails to render SVG otherwise\r\n                // https://github.com/readium/readium-js/issues/138\r\n                if (mathJax.Hub.Browser.isChrome) {\r\n                    useFontCache = false;\r\n                }\r\n                \r\n                // Edge fails to render SVG otherwise\r\n                // https://github.com/readium/readium-js-viewer/issues/394#issuecomment-185382196\r\n                if (window.navigator.userAgent.indexOf(\"Edge\") > 0) {\r\n                    useFontCache = false;\r\n                }\r\n                \r\n                mathJax.Hub.Config({showMathMenu:false, messageStyle: \"none\", showProcessingMessages: true, SVG:{useFontCache:useFontCache}});\r\n                \r\n                // If MathJax is being used, delay the callback until it has completed rendering\r\n                var mathJaxCallback = _.once(callback);\r\n                try {\r\n                    mathJax.Hub.Queue(mathJaxCallback);\r\n                } catch (err) {\r\n                    console.error(\"MathJax fail!\");\r\n                    callback();\r\n                }\r\n                // Or at an 8 second timeout, which ever comes first\r\n                //window.setTimeout(mathJaxCallback, 8000);\r\n            } else {\r\n                callback();\r\n            }\r\n        };\r\n\r\n        iframe.setAttribute(\"src\", contentUri);\r\n    };\r\n\r\n};\r\n\r\nreturn IFrameLoader;\r\n});\r\n\n",
    "//  Copyright (c) 2014 Readium Foundation and/or its licensees. All rights reserved.\r\n// \r\n//  Redistribution and use in source and binary forms, with or without modification, \r\n//  are permitted provided that the following conditions are met:\r\n//  1. Redistributions of source code must retain the above copyright notice, this \r\n//  list of conditions and the following disclaimer.\r\n//  2. Redistributions in binary form must reproduce the above copyright notice, \r\n//  this list of conditions and the following disclaimer in the documentation and/or \r\n//  other materials provided with the distribution.\r\n//  3. Neither the name of the organization nor the names of its contributors may be \r\n//  used to endorse or promote products derived from this software without specific \r\n//  prior written permission.\r\n//  \r\n//  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND \r\n//  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED \r\n//  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. \r\n//  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, \r\n//  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, \r\n//  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, \r\n//  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF \r\n//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE \r\n//  OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED \r\n//  OF THE POSSIBILITY OF SUCH DAMAGE.\r\n\r\ndefine('readium_shared_js/views/internal_links_support',['jquery', '../helpers', 'readium_cfi_js'], function($, Helpers, epubCfi) {\r\n/**\r\n *\r\n * @param reader\r\n * @constructor\r\n */\r\nvar InternalLinksSupport = function(reader) {\r\n\r\n    var self = this;\r\n\r\n    function splitCfi(fullCfi) {\r\n\r\n        var startIx = fullCfi.indexOf(\"(\");\r\n        var bungIx = fullCfi.indexOf(\"!\");\r\n        var endIx = fullCfi.indexOf(\")\");\r\n\r\n        if(bungIx == -1) {\r\n            return undefined;\r\n        }\r\n\r\n        if(endIx == -1) {\r\n            endIx = fullCfi.length;\r\n        }\r\n\r\n        return {\r\n\r\n            spineItemCfi: fullCfi.substring(startIx + 1, bungIx),\r\n            elementCfi: fullCfi.substring(bungIx + 1, endIx)\r\n        }\r\n    }\r\n\r\n    function getAbsoluteUriRelativeToSpineItem(hrefUri, spineItem) {\r\n\r\n        var fullPath = reader.package().resolveRelativeUrl(spineItem.href);\r\n\r\n        var absUrl = hrefUri.absoluteTo(fullPath);\r\n\r\n        return absUrl;\r\n    }\r\n\r\n    function processDeepLink(hrefUri, spineItem) {\r\n\r\n        var absoluteOpfUri = getAbsoluteUriRelativeToSpineItem(hrefUri, spineItem);\r\n\r\n        if(!absoluteOpfUri) {\r\n            console.error(\"Unable to resolve \" + hrefUri.href())\r\n            return;\r\n        }\r\n\r\n        var fullCfi = hrefUri.fragment();\r\n\r\n        var absPath = absoluteOpfUri.toString();\r\n\r\n        absPath = Helpers.RemoveFromString(absPath, \"#\" +  fullCfi);\r\n\r\n        readOpfFile(absPath, function(opfText) {\r\n\r\n            if(!opfText) {\r\n                return;\r\n            }\r\n\r\n            var parser = new window.DOMParser;\r\n            var packageDom = parser.parseFromString(opfText, 'text/xml');\r\n            var cfi = splitCfi(fullCfi);\r\n\r\n            if(!cfi) {\r\n                console.warn(\"Unable to split cfi:\" + fullCfi);\r\n                return;\r\n            }\r\n\r\n            var contentDocRef = EPUBcfi.Interpreter.getContentDocHref(\"epubcfi(\" + cfi.spineItemCfi + \")\", packageDom);\r\n\r\n            if(contentDocRef) {\r\n\r\n                var newSpineItem = reader.spine().getItemByHref(contentDocRef);\r\n                if(newSpineItem) {\r\n\r\n                    reader.openSpineItemElementCfi(newSpineItem.idref, cfi.elementCfi, self);\r\n                }\r\n                else {\r\n                    console.warn(\"Unable to find spineItem with href=\" + contentDocRef);\r\n                }\r\n\r\n            }\r\n            else {\r\n                console.warn(\"Unable to find document ref from \" +  fullCfi +\" cfi\");\r\n            }\r\n\r\n        });\r\n\r\n    }\r\n\r\n    function readOpfFile(path, callback) {\r\n\r\n        //TODO: this should use readium-js resource fetcher (file / URI access abstraction layer), as right now this fails with packed EPUBs  \r\n        $.ajax({\r\n            // encoding: \"UTF-8\",\r\n            // mimeType: \"text/plain; charset=UTF-8\",\r\n            // beforeSend: function( xhr ) {\r\n            //     xhr.overrideMimeType(\"text/plain; charset=UTF-8\");\r\n            // },\r\n            isLocal: path.indexOf(\"http\") === 0 ? false : true,\r\n            url: path,\r\n            dataType: 'text',\r\n            async: true,\r\n            success: function (result) {\r\n                callback(result);\r\n            },\r\n            error: function (xhr, status, errorThrown) {\r\n                console.error('Error when AJAX fetching ' + path);\r\n                console.error(status);\r\n                console.error(errorThrown);\r\n                callback();\r\n            }\r\n        });\r\n    }\r\n\r\n    //checks if href includes path to opf file and full cfi\r\n    function isDeepLikHref(uri) {\r\n\r\n        var fileName = uri.filename();\r\n        return fileName && Helpers.EndsWith(fileName, \".opf\");\r\n    }\r\n\r\n    function processLinkWithHash(hrefUri, spineItem) {\r\n\r\n        var fileName = hrefUri.filename();\r\n\r\n        var idref;\r\n\r\n        //reference to another file\r\n        if(fileName) {\r\n            var normalizedUri = new URI(hrefUri, spineItem.href);\r\n            \r\n            var pathname = decodeURIComponent(normalizedUri.pathname());\r\n            \r\n            var newSpineItem = reader.spine().getItemByHref(pathname);\r\n\r\n            if(!newSpineItem) {\r\n                console.error(\"spine item with href=\" + pathname + \" not found\");\r\n                return;\r\n            }\r\n\r\n            idref = newSpineItem.idref;\r\n        }\r\n        else { //hush in the same file\r\n            idref = spineItem.idref;\r\n        }\r\n\r\n        var hashFrag = hrefUri.fragment();\r\n\r\n        reader.openSpineItemElementId(idref, hashFrag, self);\r\n\r\n    }\r\n\r\n    this.processLinkElements = function($iframe, spineItem) {\r\n\r\n        var epubContentDocument = $iframe[0].contentDocument;\r\n\r\n        $('a', epubContentDocument).click(function (clickEvent) {\r\n            // Check for both href and xlink:href attribute and get value\r\n            var href;\r\n            if (clickEvent.currentTarget.attributes[\"xlink:href\"]) {\r\n                \r\n                href = clickEvent.currentTarget.attributes[\"xlink:href\"].value;\r\n            }\r\n            else {\r\n                href = clickEvent.currentTarget.attributes[\"href\"].value;\r\n            }\r\n\r\n            var overrideClickEvent = false;\r\n            var hrefUri = new URI(href);\r\n            var hrefIsRelative = hrefUri.is('relative');\r\n\r\n            if (hrefIsRelative) {\r\n\r\n                if(isDeepLikHref(hrefUri)) {\r\n                    processDeepLink(hrefUri, spineItem);\r\n                    overrideClickEvent = true;\r\n                }\r\n                else {\r\n                    processLinkWithHash(hrefUri, spineItem);\r\n                    overrideClickEvent = true;\r\n                }\r\n\r\n            } else {\r\n                // It's an absolute URL to a remote site - open it in a separate window outside the reader\r\n                window.open(href, '_blank');\r\n                overrideClickEvent = true;\r\n            }\r\n\r\n            if (overrideClickEvent) {\r\n                clickEvent.preventDefault();\r\n                clickEvent.stopPropagation();\r\n            }\r\n        });\r\n\r\n    }\r\n\r\n};\r\n\r\nreturn InternalLinksSupport;\r\n});\r\n\n",
    "//  LauncherOSX\r\n//\r\n//  Created by Boris Schneiderman.\r\n//  Modified by Daniel Weck\r\n//  Copyright (c) 2016 Readium Foundation and/or its licensees. All rights reserved.\r\n//  \r\n//  Redistribution and use in source and binary forms, with or without modification, \r\n//  are permitted provided that the following conditions are met:\r\n//  1. Redistributions of source code must retain the above copyright notice, this \r\n//  list of conditions and the following disclaimer.\r\n//  2. Redistributions in binary form must reproduce the above copyright notice, \r\n//  this list of conditions and the following disclaimer in the documentation and/or \r\n//  other materials provided with the distribution.\r\n//  3. Neither the name of the organization nor the names of its contributors may be \r\n//  used to endorse or promote products derived from this software without specific \r\n//  prior written permission.\r\n//  \r\n//  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND \r\n//  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED \r\n//  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. \r\n//  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, \r\n//  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, \r\n//  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, \r\n//  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF \r\n//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE \r\n//  OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED \r\n//  OF THE POSSIBILITY OF SUCH DAMAGE.\r\ndefine ('readium_shared_js/models/smil_iterator',[\"jquery\", \"../helpers\"], function($, Helpers) {\r\n/**\r\n * Wrapper of a smil iterator object. \r\n * A smil iterator is used by the media overlay player, to move along text areas which have an audio overlay. \r\n * Such areas are specified in the smil model via parallel smil nodes (text + audio).  \r\n *\r\n * @class  Models.SmilIterator\r\n * @constructor\r\n * @param {Models.SmilModel} smil The current smil model\r\n */\r\nvar SmilIterator = function(smil) {\r\n\r\n   /**\r\n     * The smil model\r\n     *\r\n     * @property smil\r\n     * @type Models.SmilModel\r\n     */\r\n    this.smil = smil;\r\n\r\n    /**\r\n     * The current parallel smil node\r\n     *\r\n     * @property currentPar\r\n     * @type object\r\n     */\r\n     \r\n    this.currentPar = undefined;\r\n\r\n    /**\r\n     * Resets the iterator. \r\n     * In practice, looks for the first parallel smil node in the smil model\r\n     *\r\n     * @method     reset\r\n     */\r\n\r\n    this.reset = function() {\r\n        this.currentPar = findParNode(0, this.smil, false);\r\n    };\r\n\r\n    /*\r\n    this.firstDeep = function(container) {\r\n        var par = container.nodeType === \"par\" ? container : findParNode(0, container, false);\r\n\r\n        return par;\r\n    };\r\n    */\r\n//\r\n//    this.ensureNextValidTextElement = function()\r\n//    {\r\n//        if (!this.currentPar)\r\n//        {\r\n//            console.debug(\"Par iterator is out of range\");\r\n//            return;\r\n//        }\r\n//\r\n//        while (this.currentPar && !this.currentPar.element)\r\n//        {\r\n//            this.next();\r\n//        }\r\n//    };\r\n    \r\n    /**\r\n     * Looks for a text smil node identified by the id parameter \r\n     * Returns true if the id param identifies a text smil node.\r\n     *\r\n     * @method     findTextId\r\n     * @param      {Number} id A smil node identifier\r\n     * @return     {Boolean} \r\n     */\r\n    this.findTextId = function(id)\r\n    {\r\n        if (!this.currentPar)\r\n        {\r\n            console.debug(\"Par iterator is out of range\");\r\n            return;\r\n        }\r\n\r\n        if (!id)\r\n        {\r\n            return false;\r\n        }\r\n\r\n        while (this.currentPar)\r\n        {\r\n            if (this.currentPar.element)\r\n            {\r\n                if (id === this.currentPar.text.srcFragmentId) //this.currentPar.element.id\r\n                {\r\n                    return true;\r\n                }\r\n\r\n                // OUTER match\r\n                var parent = this.currentPar.element.parentNode;\r\n                while(parent)\r\n                {\r\n                    if (parent.id && parent.id == id)\r\n                    {\r\n                        return true;\r\n                    }\r\n\r\n                    parent = parent.parentNode;\r\n                }\r\n                //console.log(parent);\r\n\r\n                // INNER match\r\n                //var inside = this.currentPar.element.ownerDocument.getElementById(id);\r\n                var inside = $(\"#\" + Helpers.escapeJQuerySelector(id), this.currentPar.element);\r\n                if (inside && inside.length && inside[0])\r\n                {\r\n                    return true;\r\n                }\r\n            }\r\n            // moves to the next parallel smil node\r\n            this.next();\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Looks for the next parallel smil node\r\n     *\r\n     * @method     next \r\n     */\r\n\r\n    this.next = function() {\r\n\r\n        if(!this.currentPar) {\r\n            console.debug(\"Par iterator is out of range\");\r\n            return;\r\n        }\r\n\r\n        this.currentPar = findParNode(this.currentPar.index + 1, this.currentPar.parent, false);\r\n    };\r\n\r\n    /**\r\n     * Looks for the previous parallel smil node\r\n     *\r\n     * @method     previous\r\n     */\r\n\r\n    this.previous = function() {\r\n\r\n        if(!this.currentPar) {\r\n            console.debug(\"Par iterator is out of range\");\r\n            return;\r\n        }\r\n\r\n        this.currentPar = findParNode(this.currentPar.index - 1, this.currentPar.parent, true);\r\n    };\r\n\r\n    /**\r\n     * Checks if the current parallel smil node is the last one in the smil model\r\n     *\r\n     * @method     isLast\r\n     * @return     {Bool}\r\n     */\r\n\r\n    this.isLast = function() {\r\n\r\n        if(!this.currentPar) {\r\n            console.debug(\"Par iterator is out of range\");\r\n            return;\r\n        }\r\n\r\n        if (findParNode(this.currentPar.index + 1, this.currentPar.parent, false))\r\n        {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Moves to the parallel smil node given as a parameter. \r\n     *\r\n     * @method     goToPar\r\n     * @param      {Containter} par A parallel smil node\r\n     * @return     {Boolean} \r\n     */\r\n\r\n    this.goToPar =  function(par) {\r\n\r\n        while(this.currentPar) {\r\n            if(this.currentPar == par) {\r\n                break;\r\n            }\r\n\r\n            this.next();\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Looks for a parallel smil node in the smil model.\r\n     *\r\n     * @method     findParNode\r\n     * @param      {Number} startIndex Start index inside the container\r\n     * @param      {Models.SMilModel} container The smil model\r\n     * @param      {Boolean} previous True if  search among previous nodes\r\n     * @return     {Smil.ParNode} \r\n     */\r\n\r\n    function findParNode(startIndex, container, previous) {\r\n\r\n        for(var i = startIndex, count = container.children.length;\r\n            i >= 0 && i < count;\r\n            i += (previous ? -1 : 1)) {\r\n\r\n            var node = container.children[i];\r\n            if(node.nodeType == \"par\") {\r\n                return node;\r\n            }\r\n\r\n            // assert(node.nodeType == \"seq\")\r\n            node = findParNode(previous ? node.children.length - 1 : 0, node, previous);\r\n\r\n            if(node) {\r\n                return node;\r\n            }\r\n        }\r\n\r\n        if(container.parent) {\r\n            return findParNode(container.index + (previous ? -1 : 1), container.parent, previous);\r\n        }\r\n\r\n        return undefined;\r\n    }\r\n\r\n    this.reset();\r\n};\r\n\r\nreturn SmilIterator;\r\n});\r\n\n",
    "//  Copyright (c) 2014 Readium Foundation and/or its licensees. All rights reserved.\r\n//  \r\n//  Redistribution and use in source and binary forms, with or without modification, \r\n//  are permitted provided that the following conditions are met:\r\n//  1. Redistributions of source code must retain the above copyright notice, this \r\n//  list of conditions and the following disclaimer.\r\n//  2. Redistributions in binary form must reproduce the above copyright notice, \r\n//  this list of conditions and the following disclaimer in the documentation and/or \r\n//  other materials provided with the distribution.\r\n//  3. Neither the name of the organization nor the names of its contributors may be \r\n//  used to endorse or promote products derived from this software without specific \r\n//  prior written permission.\r\n//  \r\n//  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND \r\n//  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED \r\n//  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. \r\n//  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, \r\n//  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, \r\n//  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, \r\n//  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF \r\n//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE \r\n//  OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED \r\n//  OF THE POSSIBILITY OF SUCH DAMAGE.\r\n\r\ndefine ('readium_shared_js/views/media_overlay_data_injector',[\"jquery\", \"underscore\", \"../helpers\", \"../models/smil_iterator\", \"rangy\", 'readium_cfi_js'], function($, _, Helpers, SmilIterator, rangy, epubCfi) {\r\n/**\r\n *\r\n * @param mediaOverlay\r\n * @param mediaOverlayPlayer\r\n * @constructor\r\n */\r\nvar MediaOverlayDataInjector = function (mediaOverlay, mediaOverlayPlayer) {\r\n\r\n    this.attachMediaOverlayData = function ($iframe, spineItem, mediaOverlaySettings) {\r\n\r\n        var contentDocElement = $iframe[0].contentDocument.documentElement;\r\n\r\n        if (!spineItem.media_overlay_id && mediaOverlay.smil_models.length === 0) {\r\n            return;\r\n        }\r\n\r\n        var $body = $(\"body\", contentDocElement);\r\n        if ($body.length == 0) {\r\n            console.error(\"! BODY ???\");\r\n        }\r\n        else {\r\n            var click = $body.data(\"mediaOverlayClick\");\r\n            if (click) {\r\n                console.error(\"[WARN] already mediaOverlayClick\");\r\n            }\r\n            else {\r\n                $body.data(\"mediaOverlayClick\", {ping: \"pong\"});\r\n\r\n                var touchClickMOEventHandler = function (event)\r\n                {\r\n                    //console.debug(\"MO TOUCH-DOWN: \"+event.type);\r\n                    \r\n                    var elem = $(this)[0]; // body\r\n                    elem = event.target; // body descendant\r\n\r\n                    if (!elem)\r\n                    {\r\n                        mediaOverlayPlayer.touchInit();\r\n                        return true;\r\n                    }\r\n\r\n//console.debug(\"MO CLICK: \" + elem.id);\r\n\r\n                    var data = undefined;\r\n                    var el = elem;\r\n\r\n                    var inLink = false;\r\n                    if (el.nodeName.toLowerCase() === \"a\")\r\n                    {\r\n                        inLink = true;\r\n                    }\r\n\r\n                    while (!(data = $(el).data(\"mediaOverlayData\")))\r\n                    {\r\n                        if (el.nodeName.toLowerCase() === \"a\")\r\n                        {\r\n                            inLink = true;\r\n                        }\r\n                        el = el.parentNode;\r\n                        if (!el)\r\n                        {\r\n                            break;\r\n                        }\r\n                    }\r\n                    \r\n                    if (data && (data.par || data.pars))\r\n                    {\r\n                        if (el !== elem)\r\n                        {\r\n//console.log(\"MO CLICK REDIRECT: \" + el.id);\r\n                        }\r\n\r\n                        if (!mediaOverlaySettings.mediaOverlaysEnableClick)\r\n                        {\r\nconsole.log(\"MO CLICK DISABLED\");\r\n                            mediaOverlayPlayer.touchInit();\r\n                            return true;\r\n                        }\r\n\r\n                        if (inLink)\r\n                        {\r\nconsole.log(\"MO CLICKED LINK\");\r\n                            mediaOverlayPlayer.touchInit();\r\n                            return true;\r\n                        }\r\n\r\n                        var par = data.par ? data.par : data.pars[0];\r\n\r\n                        if (data.pars && (typeof rangy !== \"undefined\"))\r\n                        {\r\n                            var wasPaused = false;\r\n                            \r\n                            // To remove highlight which may have altered DOM (and break CFI expressions)\r\n                            if (mediaOverlayPlayer.isPlayingCfi())\r\n                            {\r\n                                wasPaused = true;\r\n                                mediaOverlayPlayer.pause();\r\n                            }\r\n                         \r\n                            // /////////////////////\r\n                            // \r\n                            // var p = {x: event.pageX, y: event.pageY};\r\n                            // if (webkitConvertPointFromPageToNode)\r\n                            // {\r\n                            //     p = webkitConvertPointFromPageToNode(elem.ownerDocument.body, new WebKitPoint(event.pageX, event.pageY));\r\n                            // }\r\n                            // \r\n                            // var div = elem.ownerDocument.getElementById(\"CLICKED\");\r\n                            // if (div)\r\n                            // {\r\n                            //     div.parentNode.removeChild(div);\r\n                            // }\r\n                            // \r\n                            // div = elem.ownerDocument.createElementNS(\"http://www.w3.org/1999/xhtml\", 'div');\r\n                            // div.setAttribute(\"style\", \"background-color: red; position: absolute; z-index: 999; width: 50px; height: 50px; left: \" + p.x + \"px; top: \" + p.y + \"px;\");\r\n                            // div.id = \"CLICKED\";\r\n                            // div.setAttribute(\"id\", div.id);\r\n                            // var divTxt = elem.ownerDocument.createTextNode(\" \");\r\n                            // div.appendChild(divTxt);\r\n                            // elem.ownerDocument.body.appendChild(div);\r\n                            //                          \r\n                            // /////////////////////\r\n\r\n\r\n                            //rangy.init();\r\n                            try\r\n                            {\r\n// THIS WORKS (same as Rangy's method below)\r\n//                                 var r;\r\n//                                 if (elem.ownerDocument.caretRangeFromPoint)\r\n//                                 {\r\n//                                     r = elem.ownerDocument.caretRangeFromPoint(event.pageX, event.pageY);\r\n//                                 }\r\n//                                 else if (event.rangeParent)\r\n//                                 {\r\n//                                     r = elem.ownerDocument.createRange();\r\n//                                     range.setStart(event.rangeParent, event.rangeOffset);\r\n//                                 }\r\n//                                 \r\n// console.log(\"------ 1\");\r\n// console.log(elem.ownerDocument);\r\n// console.log(event.pageX);\r\n// console.log(event.pageY);\r\n// console.log(r.startContainer);\r\n// console.log(r.startOffset);\r\n// console.log(\"------\");\r\n\r\n                                var pos = rangy.positionFromPoint(event.pageX, event.pageY, elem.ownerDocument);\r\n// console.log(\"------ 2\");\r\n// console.log(pos.node.textContent);\r\n// console.log(pos.offset);\r\n// console.log(\"------\");\r\n\r\n                                par = undefined;\r\n                                \r\n                                for (var iPar = 0; iPar < data.pars.length; iPar++)\r\n                                {\r\n                                    var p = data.pars[iPar];\r\n\r\n                                    var startCFI = \"epubcfi(\" + p.cfi.partialStartCfi + \")\";\r\n                                    var infoStart = EPUBcfi.getTextTerminusInfoWithPartialCFI(startCFI, elem.ownerDocument,\r\n                [\"cfi-marker\", \"mo-cfi-highlight\"],\r\n                [],\r\n                [\"MathJax_Message\"]);\r\n//console.log(infoStart);\r\n\r\n                                    var endCFI = \"epubcfi(\" + p.cfi.partialEndCfi + \")\";\r\n                                    var infoEnd = EPUBcfi.getTextTerminusInfoWithPartialCFI(endCFI, elem.ownerDocument,\r\n                [\"cfi-marker\", \"mo-cfi-highlight\"],\r\n                [],\r\n                [\"MathJax_Message\"]);\r\n//console.log(infoEnd);\r\n\r\n                                    var range = rangy.createRange(elem.ownerDocument); //createNativeRange\r\n                                    range.setStartAndEnd(\r\n                                        infoStart.textNode, infoStart.textOffset,\r\n                                        infoEnd.textNode, infoEnd.textOffset\r\n                                    );\r\n        \r\n                                    if (range.isPointInRange(pos.node, pos.offset))\r\n                                    {\r\n// console.log(p.cfi.partialStartCfi);\r\n// console.log(p.cfi.partialEndCfi);\r\n                                        // DOUBLE CHECK WITH getClientRects ??\r\n                                        \r\n                                        par = p;\r\n                                        break;\r\n                                    }\r\n                                }\r\n                            }\r\n                            catch (e)\r\n                            {\r\n                                console.error(e);\r\n                            }\r\n                            \r\n                            if (!par)\r\n                            {\r\n                                if (wasPaused)\r\n                                {\r\n                                    mediaOverlayPlayer.toggleMediaOverlay();\r\n                                }\r\n                                return true;\r\n                            }\r\n                        }\r\n\r\n\r\n                        if (el && el != elem && el.nodeName.toLowerCase() === \"body\" && par && !par.getSmil().id)\r\n                        {\r\n//console.debug(\"MO CLICKED BLANK BODY\");\r\n                            mediaOverlayPlayer.touchInit();\r\n                            return true;\r\n                        }\r\n\r\n                        mediaOverlayPlayer.playUserPar(par);\r\n                        return true;\r\n                    }\r\n                    else\r\n                    {\r\n                        var readaloud = $(elem).attr(\"ibooks:readaloud\");\r\n                        if (!readaloud)\r\n                        {\r\n                            readaloud = $(elem).attr(\"epub:readaloud\");\r\n                        }\r\n                        if (readaloud)\r\n                        {\r\nconsole.debug(\"MO readaloud attr: \" + readaloud);\r\n\r\n                            var isPlaying = mediaOverlayPlayer.isPlaying();\r\n                            if (readaloud === \"start\" && !isPlaying ||\r\n                                readaloud === \"stop\" && isPlaying ||\r\n                                readaloud === \"startstop\")\r\n                            {\r\n                                mediaOverlayPlayer.toggleMediaOverlay();\r\n                                return true;\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    mediaOverlayPlayer.touchInit();\r\n                    return true;\r\n                };\r\n\r\n                var touchClickMOEventHandler_ = _.debounce(touchClickMOEventHandler, 200);\r\n                \r\n                if ('ontouchstart' in document.documentElement)\r\n                {\r\n                  $body[0].addEventListener(\"touchstart\", touchClickMOEventHandler_, false);\r\n                }\r\n                $body[0].addEventListener(\"mousedown\", touchClickMOEventHandler_, false);\r\n\r\n                //var clickEvent = 'ontouchstart' in document.documentElement ? 'touchstart' : 'click';\r\n                //$body.bind(clickEvent, touchClickMOEventHandler);\r\n            }\r\n        }\r\n\r\n        var smil = mediaOverlay.getSmilBySpineItem(spineItem);\r\n        if (!smil)\r\n        {\r\n            console.error(\"NO SMIL?? \" + spineItem.idref + \" /// \" + spineItem.media_overlay_id);\r\n            return;\r\n        }\r\n\r\n        var traverseSmilSeqs = function(root)\r\n        {\r\n            if (!root) return;\r\n            \r\n            if (root.nodeType && root.nodeType === \"seq\")\r\n            {\r\n               // if (root.element)\r\n               // {\r\n               //     console.error(\"WARN: seq.element already set: \" + root.textref);\r\n               // }\r\n                   \r\n               if (root.textref)\r\n               {\r\n                   var parts = root.textref.split('#');\r\n                   var file = parts[0];\r\n                   var fragmentId = (parts.length === 2) ? parts[1] : \"\";\r\n                   // \r\n                   // console.debug(root.textref);\r\n                   // console.debug(fragmentId);\r\n                   // console.log(\"---- SHOULD BE EQUAL:\");\r\n                   // console.debug(file);\r\n                   // console.debug(par.text.srcFile);\r\n                   // \r\n                   // if (file !== par.text.srcFile)\r\n                   // {\r\n                   //     console.error(\"adjustParToSeqSyncGranularity textref.file !== par.text.srcFile ???\");\r\n                   //     return par;\r\n                   // }\r\n                   // \r\n                   // if (!fragmentId)\r\n                   // {\r\n                   //     console.error(\"adjustParToSeqSyncGranularity !fragmentId ???\");\r\n                   //     return par;\r\n                   // }\r\n\r\n                   if (file && fragmentId)\r\n                   {\r\n                       var textRelativeRef = Helpers.ResolveContentRef(file, smil.href);\r\n                       var same = textRelativeRef === spineItem.href;\r\n                       if (same)\r\n                       {                       \r\n                           root.element = $iframe[0].contentDocument.getElementById(fragmentId);\r\n                   \r\n                           if (!root.element)\r\n                           {\r\n                               console.error(\"seq.textref !element? \" + root.textref);\r\n                           }\r\n\r\n                           // var selector = \"#\" + Helpers.escapeJQuerySelector(fragmentId);\r\n                           // var $element = $(selector, element.ownerDocument.documentElement);\r\n                           // if ($element)\r\n                           // {\r\n                           //     seq.element = $element[0];\r\n                           // }\r\n                       }\r\n                   }\r\n               }\r\n            }\r\n            \r\n            if (root.children && root.children.length)\r\n            {\r\n                for (var i = 0; i < root.children.length; i++)\r\n                {\r\n                    var child = root.children[i];\r\n                    traverseSmilSeqs(child);\r\n                }\r\n            }\r\n        };\r\n        traverseSmilSeqs(smil);\r\n\r\n//console.debug(\"[[MO ATTACH]] \" + spineItem.idref + \" /// \" + spineItem.media_overlay_id + \" === \" + smil.id);\r\n\r\n        var iter = new SmilIterator(smil);\r\n        \r\n        var fakeOpfRoot = \"/99!\";\r\n        var epubCfiPrefix = \"epubcfi\";\r\n        \r\n        while (iter.currentPar) {\r\n            iter.currentPar.element = undefined;\r\n            iter.currentPar.cfi = undefined;\r\n\r\n            if (true) { //iter.currentPar.text.srcFragmentId (includes empty frag ID)\r\n\r\n                var textRelativeRef = Helpers.ResolveContentRef(iter.currentPar.text.srcFile, iter.smil.href);\r\n\r\n                var same = textRelativeRef === spineItem.href;\r\n                if (same) {\r\n                    var selectBody = !iter.currentPar.text.srcFragmentId || iter.currentPar.text.srcFragmentId.length == 0;\r\n                    var selectId = iter.currentPar.text.srcFragmentId.indexOf(epubCfiPrefix) == 0 ? undefined : iter.currentPar.text.srcFragmentId;\r\n\r\n                    var $element = undefined;\r\n                    var isCfiTextRange = false;\r\n                    if (!selectBody && !selectId)\r\n                    {\r\n                        if (iter.currentPar.text.srcFragmentId.indexOf(epubCfiPrefix) === 0)\r\n                        {\r\n                            var partial = iter.currentPar.text.srcFragmentId.substr(epubCfiPrefix.length + 1, iter.currentPar.text.srcFragmentId.length - epubCfiPrefix.length - 2);\r\n                            \r\n                            if (partial.indexOf(fakeOpfRoot) === 0)\r\n                            {\r\n                                partial = partial.substr(fakeOpfRoot.length, partial.length - fakeOpfRoot.length);\r\n                            }\r\n//console.log(partial);\r\n                            var parts = partial.split(\",\");\r\n                            if (parts && parts.length === 3)\r\n                            {\r\n                                try\r\n                                {\r\n                                    var partialStartCfi = parts[0] + parts[1];\r\n                                    var startCFI = \"epubcfi(\" + partialStartCfi + \")\";\r\n                                    var infoStart = EPUBcfi.getTextTerminusInfoWithPartialCFI(startCFI, $iframe[0].contentDocument,\r\n                [\"cfi-marker\", \"mo-cfi-highlight\"],\r\n                [],\r\n                [\"MathJax_Message\"]);\r\n//console.log(infoStart);\r\n\r\n                                    var partialEndCfi = parts[0] + parts[2];\r\n                                    var endCFI = \"epubcfi(\" + partialEndCfi + \")\";\r\n                                    var infoEnd = EPUBcfi.getTextTerminusInfoWithPartialCFI(endCFI, $iframe[0].contentDocument,\r\n                [\"cfi-marker\", \"mo-cfi-highlight\"],\r\n                [],\r\n                [\"MathJax_Message\"]);\r\n//console.log(infoEnd);\r\n\r\n                                    var cfiTextParent = infoStart.textNode.parentNode;\r\n\r\n                                    iter.currentPar.cfi = {\r\n                                        smilTextSrcCfi: iter.currentPar.text.srcFragmentId,\r\n                                        partialRangeCfi: partial,\r\n                                        partialStartCfi: partialStartCfi,\r\n                                        partialEndCfi: partialEndCfi,\r\n                                        \r\n                                        cfiTextParent: cfiTextParent\r\n                                        \r\n                                        // textNode becomes invalid after highlighting! (dynamic span insertion/removal changes DOM)\r\n                                        // cfiRangeStart: infoStart,\r\n                                        // cfiRangeEnd: infoEnd\r\n                                    };\r\n                                    \r\n                                    // TODO: not just start textNode, but all of them between start and end...\r\n                                    // ...that being said, CFI text ranges likely to be used only within a single common parent,\r\n                                    // so this is an acceptable implementation shortcut for this CFI experimentation (word-level text/audio synchronisation).\r\n                                    isCfiTextRange = true;\r\n                                    $element = $(cfiTextParent);\r\n                                    var modata = $element.data(\"mediaOverlayData\");\r\n                                    if (!modata)\r\n                                    {\r\n                                        modata = {pars: [iter.currentPar]};\r\n                                        $element.data(\"mediaOverlayData\", modata);\r\n                                    }\r\n                                    else\r\n                                    {\r\n                                        if (modata.par)\r\n                                        {\r\n                                            console.error(\"[WARN] non-CFI MO DATA already exists!\");\r\n                                            modata.par = undefined;\r\n                                        }\r\n\r\n                                        var found = false;\r\n                                        if (modata.pars)\r\n                                        {\r\n                                            for (var iPars = 0; iPars < modata.pars.length; iPars++)\r\n                                            {\r\n                                                var par = modata.pars[iPars];\r\n\r\n                                                if (par === iter.currentPar)\r\n                                                {\r\n                                                    found = true;\r\n                                                    console.error(\"[WARN] mediaOverlayData CFI PAR already registered!\");\r\n                                                }\r\n                                            }\r\n                                        }\r\n                                        else\r\n                                        {\r\n                                            modata.pars = [];\r\n                                        }\r\n\r\n                                        if (!found)\r\n                                        {\r\n                                            modata.pars.push(iter.currentPar);\r\n                                        }\r\n                                    }\r\n\r\n                                }\r\n                                catch (error)\r\n                                {\r\n                                    console.error(error);\r\n                                }\r\n                            }\r\n                            else\r\n                            {\r\n                                try\r\n                                {\r\n                                    var cfi = \"epubcfi(\" + partial + \")\";\r\n                                    $element = EPUBcfi.getTargetElementWithPartialCFI(cfi, $iframe[0].contentDocument,\r\n                [\"cfi-marker\", \"mo-cfi-highlight\"],\r\n                [],\r\n                [\"MathJax_Message\"]);\r\n                                }\r\n                                catch (error)\r\n                                {\r\n                                    console.error(error);\r\n                                }\r\n                            }\r\n                        }\r\n                        else \r\n                        {\r\n                            console.error(\"SMIL text@src CFI fragment identifier scheme not supported: \" + iter.currentPar.text.srcFragmentId);\r\n                        }\r\n                    }\r\n                    else\r\n                    {\r\n                        if (selectBody)\r\n                        {\r\n                            $element = $body; //$(\"body\", contentDocElement);\r\n                        }\r\n                        else\r\n                        {\r\n                            $element = $($iframe[0].contentDocument.getElementById(selectId));\r\n                            //$element = $(\"#\" + Helpers.escapeJQuerySelector(iter.currentPar.text.srcFragmentId), contentDocElement);\r\n                        }\r\n                    }\r\n\r\n                    if ($element && $element.length > 0) {\r\n\r\n                        if (!isCfiTextRange)\r\n                        {\r\n                            if (iter.currentPar.element && iter.currentPar.element !== $element[0]) {\r\n                                console.error(\"DIFFERENT ELEMENTS??! \" + iter.currentPar.text.srcFragmentId + \" /// \" + iter.currentPar.element.id);\r\n                            }\r\n\r\n                            var name = $element[0].nodeName ? $element[0].nodeName.toLowerCase() : undefined;\r\n                            if (name === \"audio\" || name === \"video\") {\r\n                                $element.attr(\"preload\", \"auto\");\r\n                            }\r\n\r\n                            iter.currentPar.element = $element[0];\r\n\r\n                            var modata = $element.data(\"mediaOverlayData\");\r\n                            if (modata) {\r\n                                console.error(\"[WARN] MO DATA already exists.\");\r\n\r\n                                if (modata.par && modata.par !== iter.currentPar) {\r\n                                    console.error(\"DIFFERENT PARS??!\");\r\n                                }\r\n                            }\r\n\r\n                            $element.data(\"mediaOverlayData\", {par: iter.currentPar});\r\n\r\n                            /*\r\n                             $element.click(function() {\r\n                             var elem = $(this)[0];\r\n                             console.debug(\"MO CLICK (ELEM): \" + elem.id);\r\n\r\n                             var par = $(this).data(\"mediaOverlayData\").par;\r\n                             mediaOverlayPlayer.playUserPar(par);\r\n                             });\r\n                             */\r\n                        }\r\n                    }\r\n                    else {\r\n                        console.error(\"!! CANNOT FIND ELEMENT: \" + iter.currentPar.text.srcFragmentId + \" == \" + iter.currentPar.text.srcFile + \" /// \" + spineItem.href);\r\n                    }\r\n                }\r\n                else {\r\n//console.debug(\"[INFO] \" + spineItem.href + \" != \" + textRelativeRef + \" # \" + iter.currentPar.text.srcFragmentId);\r\n                }\r\n            }\r\n\r\n            iter.next();\r\n        }\r\n    }\r\n};\r\n\r\nreturn MediaOverlayDataInjector;\r\n});\r\n\n",
    "//  LauncherOSX\r\n//\r\n//  Created by Boris Schneiderman.\r\n// Modified by Daniel Weck, Andrey Kavarma\r\n//  Copyright (c) 2014 Readium Foundation and/or its licensees. All rights reserved.\r\n//  \r\n//  Redistribution and use in source and binary forms, with or without modification, \r\n//  are permitted provided that the following conditions are met:\r\n//  1. Redistributions of source code must retain the above copyright notice, this \r\n//  list of conditions and the following disclaimer.\r\n//  2. Redistributions in binary form must reproduce the above copyright notice, \r\n//  this list of conditions and the following disclaimer in the documentation and/or \r\n//  other materials provided with the distribution.\r\n//  3. Neither the name of the organization nor the names of its contributors may be \r\n//  used to endorse or promote products derived from this software without specific \r\n//  prior written permission.\r\n//  \r\n//  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND \r\n//  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED \r\n//  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. \r\n//  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, \r\n//  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, \r\n//  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, \r\n//  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF \r\n//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE \r\n//  OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED \r\n//  OF THE POSSIBILITY OF SUCH DAMAGE.\r\n\r\n\r\ndefine('readium_shared_js/views/audio_player',['jquery'],function($) {\r\n\r\n    /**\r\n     *\r\n     * @param onStatusChanged\r\n     * @param onPositionChanged\r\n     * @param onAudioEnded\r\n     * @param onAudioPlay\r\n     * @param onAudioPause\r\n     * @constructor\r\n     */\r\n    var AudioPlayer = function(onStatusChanged, onPositionChanged, onAudioEnded, onAudioPlay, onAudioPause)\r\n    {\r\n        var _iOS = navigator.userAgent.match(/(iPad|iPhone|iPod)/g) ? true : false;\r\n        var _Android = navigator.userAgent.toLowerCase().indexOf('android') > -1;\r\n        var _isMobile = _iOS || _Android;\r\n\r\n        //var _isReadiumJS = typeof window.requirejs !== \"undefined\";\r\n\r\n        var DEBUG = false;\r\n\r\n        var _audioElement = new Audio();\r\n        \r\n        if (DEBUG)\r\n        {\r\n            _audioElement.addEventListener(\"load\", function()\r\n                {\r\n                    console.debug(\"0) load\");\r\n                }\r\n            );\r\n\r\n            _audioElement.addEventListener(\"loadstart\", function()\r\n                {\r\n                    console.debug(\"1) loadstart\");\r\n                }\r\n            );\r\n\r\n            _audioElement.addEventListener(\"durationchange\", function()\r\n                {\r\n                    console.debug(\"2) durationchange\");\r\n                }\r\n            );\r\n\r\n            _audioElement.addEventListener(\"loadedmetadata\", function()\r\n                {\r\n                    console.debug(\"3) loadedmetadata\");\r\n                }\r\n            );\r\n\r\n            _audioElement.addEventListener(\"loadeddata\", function()\r\n                {\r\n                    console.debug(\"4) loadeddata\");\r\n                }\r\n            );\r\n\r\n            _audioElement.addEventListener(\"progress\", function()\r\n                {\r\n                    console.debug(\"5) progress\");\r\n                }\r\n            );\r\n\r\n            _audioElement.addEventListener(\"canplay\", function()\r\n                {\r\n                    console.debug(\"6) canplay\");\r\n                }\r\n            );\r\n\r\n            _audioElement.addEventListener(\"canplaythrough\", function()\r\n                {\r\n                    console.debug(\"7) canplaythrough\");\r\n                }\r\n            );\r\n\r\n            _audioElement.addEventListener(\"play\", function()\r\n                {\r\n                    console.debug(\"8) play\");\r\n                }\r\n            );\r\n\r\n            _audioElement.addEventListener(\"pause\", function()\r\n                {\r\n                    console.debug(\"9) pause\");\r\n                }\r\n            );\r\n\r\n            _audioElement.addEventListener(\"ended\", function()\r\n                {\r\n                    console.debug(\"10) ended\");\r\n                }\r\n            );\r\n\r\n            _audioElement.addEventListener(\"seeked\", function()\r\n                {\r\n                    console.debug(\"X) seeked\");\r\n                }\r\n            );\r\n\r\n            _audioElement.addEventListener(\"timeupdate\", function()\r\n                {\r\n                    console.debug(\"Y) timeupdate\");\r\n                }\r\n            );\r\n\r\n            _audioElement.addEventListener(\"seeking\", function()\r\n                {\r\n                    console.debug(\"Z) seeking\");\r\n                }\r\n            );\r\n        }\r\n\r\n        var self = this;\r\n     \r\n        //_audioElement.setAttribute(\"preload\", \"auto\");\r\n    \r\n        var _currentEpubSrc = undefined;\r\n    \r\n        var _currentSmilSrc = undefined;\r\n        this.currentSmilSrc = function() {\r\n            return _currentSmilSrc;\r\n        };\r\n\r\n        var _rate = 1.0;\r\n        this.setRate = function(rate)\r\n        {\r\n            _rate = rate;\r\n            if (_rate < 0.5)\r\n            {\r\n                _rate = 0.5;\r\n            }\r\n            if (_rate > 4.0)\r\n            {\r\n                _rate = 4.0;\r\n            }\r\n    \r\n            _audioElement.playbackRate = _rate;\r\n        }\r\n        self.setRate(_rate);\r\n        this.getRate = function()\r\n        {\r\n            return _rate;\r\n        }\r\n    \r\n    \r\n        var _volume = 1.0;\r\n        this.setVolume = function(volume)\r\n        {\r\n            _volume = volume;\r\n            if (_volume < 0.0)\r\n            {\r\n                _volume = 0.0;\r\n            }\r\n            if (_volume > 1.0)\r\n            {\r\n                _volume = 1.0;\r\n            }\r\n            _audioElement.volume = _volume;\r\n        }\r\n        self.setVolume(_volume);\r\n        this.getVolume = function()\r\n        {\r\n            return _volume;\r\n        }\r\n    \r\n        this.play = function()\r\n        {\r\n            if (DEBUG)\r\n            {\r\n                console.error(\"this.play()\");\r\n            }\r\n    \r\n            if(!_currentEpubSrc)\r\n            {\r\n                return false;\r\n            }\r\n    \r\n            startTimer();\r\n    \r\n            self.setVolume(_volume);\r\n            self.setRate(_rate);\r\n    \r\n            _audioElement.play();\r\n    \r\n            return true;\r\n        };\r\n    \r\n        this.pause = function()\r\n        {\r\n            if (DEBUG)\r\n            {\r\n                console.error(\"this.pause()\");\r\n            }\r\n    \r\n            stopTimer();\r\n    \r\n            _audioElement.pause();\r\n        };\r\n    \r\n        _audioElement.addEventListener('play', onPlay, false);\r\n        _audioElement.addEventListener('pause', onPause, false);\r\n        _audioElement.addEventListener('ended', onEnded, false);\r\n    \r\n        function onPlay()\r\n        {\r\n            onStatusChanged({isPlaying: true});\r\n            onAudioPlay();\r\n        }\r\n    \r\n        function onPause()\r\n        {\r\n            onAudioPause();\r\n            onStatusChanged({isPlaying: false});\r\n        }\r\n    \r\n        function onEnded()\r\n        {\r\n            if (_audioElement.moSeeking)\r\n            {\r\n                if (DEBUG)\r\n                {\r\n                    console.debug(\"onEnded() skipped (still seeking...)\");\r\n                }\r\n    \r\n                return;\r\n            }\r\n    \r\n            stopTimer();\r\n    \r\n            onAudioEnded();\r\n            onStatusChanged({isPlaying: false});\r\n        }\r\n        \r\n        var _intervalTimerSkips = 0;\r\n        \r\n        var _intervalTimer = undefined;\r\n        function startTimer()\r\n        {\r\n            if(_intervalTimer)\r\n            {\r\n                return;\r\n            }\r\n    \r\n            _intervalTimer = setInterval(\r\n                function()\r\n                {\r\n                    if (_audioElement.moSeeking)\r\n                    {\r\n                        if (DEBUG)\r\n                        {\r\n//console.debug(\"interval timer skipped (still seeking...)\");\r\n                        }\r\n                                         \r\n                        _intervalTimerSkips++;\r\n                        if (_intervalTimerSkips > 1000)\r\n                        {\r\n                            _intervalTimerSkips = 0;\r\n                            stopTimer();\r\n                        }\r\n                        return;\r\n                    }\r\n                    \r\n                    var currentTime = undefined;\r\n                    try\r\n                    {\r\n                        currentTime = _audioElement.currentTime;\r\n                    }\r\n                    catch (ex)\r\n                    {\r\n                        console.error(ex.message);\r\n                    }\r\n    \r\n    //                if (DEBUG)\r\n    //                {\r\n    //                    console.debug(\"currentTime: \" + currentTime);\r\n    //                }\r\n    \r\n                    if (currentTime)\r\n                    {\r\n                        onPositionChanged(currentTime, 1);\r\n                    }\r\n                }, 20);\r\n        }\r\n    \r\n        function stopTimer()\r\n        {\r\n            if (_intervalTimer)\r\n            {\r\n                clearInterval(_intervalTimer);\r\n            }\r\n            _intervalTimer = undefined;\r\n        }\r\n    \r\n        this.isPlaying = function()\r\n        {\r\n            return _intervalTimer !== undefined;\r\n        };\r\n    \r\n        this.reset = function()\r\n        {\r\n            if (DEBUG)\r\n            {\r\n                console.error(\"this.reset()\");\r\n            }\r\n    \r\n            this.pause();\r\n    \r\n            _audioElement.moSeeking = undefined;\r\n    \r\n            _currentSmilSrc = undefined;\r\n            _currentEpubSrc = undefined;\r\n    \r\n            setTimeout(function()\r\n            {\r\n                _audioElement.setAttribute(\"src\", \"\");\r\n            }, 1);\r\n        };\r\n    \r\n\r\n        _audioElement.addEventListener(\"loadstart\", function()\r\n            {\r\n                _touchInited = true;\r\n            }\r\n        );\r\n        var _touchInited = false;\r\n        this.touchInit = function()\r\n        {\r\n            if (!_iOS)\r\n            {\r\n                return false;\r\n            }\r\n    \r\n            if (_touchInited)\r\n            {\r\n                return false;\r\n            }\r\n    \r\n            _touchInited = true;\r\n    \r\n            _audioElement.setAttribute(\"src\", \"touch/init/html5/audio.mp3\");\r\n            _audioElement.load();\r\n    \r\n            return true;\r\n        };\r\n    \r\n        var _playId = 0;\r\n    \r\n        var _seekQueuing = 0;\r\n        \r\n        this.playFile = function(smilSrc, epubSrc, seekBegin) //element\r\n        {\r\n            _playId++;\r\n            if (_playId > 99999)\r\n            {\r\n                _playId = 0;\r\n            }\r\n    \r\n            var playId = _playId;\r\n    \r\n            if (_audioElement.moSeeking)\r\n            {\r\n                _seekQueuing++;\r\n                if (_seekQueuing > MAX_SEEK_RETRIES)\r\n                {\r\n                    _seekQueuing = 0;\r\n                    return;\r\n                }\r\n                \r\n                if (DEBUG)\r\n                {\r\n                    console.debug(\"this.playFile(\" + epubSrc + \")\" + \" @\" + seekBegin + \" (POSTPONE, SEEKING...)\");\r\n                }\r\n    \r\n                setTimeout(function()\r\n                {\r\n                    self.playFile(smilSrc, epubSrc, seekBegin);\r\n                }, 20);\r\n                \r\n                return;\r\n            }\r\n    \r\n            _audioElement.moSeeking = {};\r\n    \r\n            if (DEBUG)\r\n            {\r\n                console.debug(\"this.playFile(\" + epubSrc + \")\" + \" @\" + seekBegin + \" #\" + playId);\r\n            }\r\n    \r\n            var audioNeedsNewSrc = !_currentEpubSrc || _currentEpubSrc !== epubSrc;\r\n    \r\n            if (!audioNeedsNewSrc)\r\n            {\r\n                if (DEBUG)\r\n                {\r\n                    console.debug(\"this.playFile() SAME SRC\");\r\n                }\r\n    \r\n                this.pause();\r\n    \r\n                _currentSmilSrc = smilSrc;\r\n                _currentEpubSrc = epubSrc;\r\n    \r\n                playSeekCurrentTime(seekBegin, playId, false);\r\n    \r\n                return;\r\n            }\r\n    \r\n            if (DEBUG)\r\n            {\r\n                console.debug(\"this.playFile() NEW SRC\");\r\n                console.debug(\"_currentEpubSrc: \" + _currentEpubSrc);\r\n                console.debug(\"epubSrc: \" + epubSrc);\r\n            }\r\n    \r\n            this.reset();\r\n            _audioElement.moSeeking = {};\r\n    \r\n            _currentSmilSrc = smilSrc;\r\n            _currentEpubSrc = epubSrc;\r\n    \r\n            //element.parentNode.insertBefore(_audioElement, element); //element.parentNode.childNodes[0]);\r\n            \r\n            if (!_Android)\r\n            {\r\n                _audioElement.addEventListener('play', onPlayToForcePreload, false);\r\n            }\r\n    \r\n            $(_audioElement).on(_readyEvent, {seekBegin: seekBegin, playId: playId}, onReadyToSeek);\r\n            \r\n            setTimeout(function()\r\n            {\r\n                   _audioElement.setAttribute(\"src\", _currentEpubSrc);\r\n                   // _audioElement.src = _currentEpubSrc;\r\n                   // $(_audioElement).attr(\"src\", _currentEpubSrc);\r\n    \r\n                   // if (_Android)\r\n                   // {\r\n                   //     _audioElement.addEventListener('loadstart', onReadyToPlayToForcePreload, false);\r\n                   // }\r\n                   \r\n                   _audioElement.load();\r\n    \r\n                   if (!_Android)\r\n                   {\r\n                       playToForcePreload();\r\n                   }\r\n            }, 1);\r\n        };\r\n    \r\n        // var onReadyToPlayToForcePreload = function ()\r\n        // {\r\n        //     _audioElement.removeEventListener('loadstart', onReadyToPlayToForcePreload, false);\r\n        //     \r\n        //     if (DEBUG)\r\n        //     {\r\n        //         console.debug(\"onReadyToPlayToForcePreload\");\r\n        //     }\r\n        //     \r\n        //     playToForcePreload();\r\n        // };\r\n        \r\n        var playToForcePreload = function()\r\n        {\r\n            if (DEBUG)\r\n            {\r\n                console.debug(\"playToForcePreload\");\r\n            }\r\n            \r\n            //_audioElement.volume = 0;\r\n            //_audioElement.play();\r\n            var vol = _volume;\r\n            _volume = 0;\r\n            self.play();\r\n            _volume = vol;\r\n        };\r\n    \r\n        var onPlayToForcePreload = function ()\r\n        {\r\n            _audioElement.removeEventListener('play', onPlayToForcePreload, false);\r\n            \r\n            if (DEBUG)\r\n            {\r\n                console.debug(\"onPlayToForcePreload\");\r\n            }\r\n            _audioElement.pause(); // note: interval timer continues (immediately follows self.play())\r\n        };\r\n    \r\n        var _readyEvent = _Android ? \"canplaythrough\" : \"canplay\";\r\n        function onReadyToSeek_(event)\r\n        {\r\n            if (DEBUG)\r\n            {\r\n                console.debug(\"onReadyToSeek #\" + event.data.playId);\r\n            }\r\n            playSeekCurrentTime(event.data.seekBegin, event.data.playId, true);\r\n        }\r\n        function onReadyToSeek(event)\r\n        {\r\n            $(_audioElement).off(_readyEvent, onReadyToSeek);\r\n            \r\n            if (!_Android)\r\n            {\r\n                onReadyToSeek_(event);\r\n            }\r\n            else\r\n            {\r\n                if (DEBUG)\r\n                {\r\n                    console.debug(\"onReadyToSeek ANDROID ... waiting a bit ... #\" + event.data.playId);\r\n                }\r\n                \r\n                //self.play();\r\n                playToForcePreload();\r\n                \r\n                setTimeout(function() {\r\n                    onReadyToSeek_(event);\r\n                }, 1000);\r\n            }\r\n        }\r\n    \r\n        function playSeekCurrentTime(newCurrentTime, playId, isNewSrc)\r\n        {\r\n            if (DEBUG)\r\n            {\r\n                console.debug(\"playSeekCurrentTime() #\" + playId);\r\n            }\r\n    \r\n            if (newCurrentTime == 0)\r\n            {\r\n                newCurrentTime = 0.01;\r\n            }\r\n    \r\n            if(Math.abs(newCurrentTime - _audioElement.currentTime) < 0.3)\r\n            {\r\n                if (DEBUG)\r\n                {\r\n                    console.debug(\"playSeekCurrentTime() CONTINUE\");\r\n                }\r\n    \r\n                _audioElement.moSeeking = undefined;\r\n                self.play();\r\n                return;\r\n            }\r\n    \r\n            var ev = isNewSrc ? _seekedEvent1 : _seekedEvent2;\r\n    \r\n            if (DEBUG)\r\n            {\r\n                console.debug(\"playSeekCurrentTime() NEED SEEK, EV: \" + ev);\r\n            }\r\n    \r\n            self.pause();\r\n    \r\n            $(_audioElement).on(ev, {newCurrentTime: newCurrentTime, playId: playId, isNewSrc: isNewSrc}, onSeeked);\r\n    \r\n            try\r\n            {\r\n                _audioElement.currentTime = newCurrentTime;\r\n            }\r\n            catch (ex)\r\n            {\r\n                console.error(ex.message);\r\n    \r\n                setTimeout(function()\r\n                {\r\n                    try\r\n                    {\r\n                        _audioElement.currentTime = newCurrentTime;\r\n                    }\r\n                    catch (ex)\r\n                    {\r\n                        console.error(ex.message);\r\n                    }\r\n                }, 5);\r\n            }\r\n        }\r\n        \r\n        var MAX_SEEK_RETRIES = 10;\r\n        var _seekedEvent1 = _iOS ? \"canplaythrough\" : \"seeked\"; //\"progress\"\r\n        var _seekedEvent2 = _iOS ? \"timeupdate\" : \"seeked\";\r\n        function onSeeked(event)\r\n        {\r\n            var ev = event.data.isNewSrc ? _seekedEvent1 : _seekedEvent2;\r\n    \r\n            var notRetry = event.data.seekRetries == undefined;\r\n    \r\n            if (notRetry || event.data.seekRetries == MAX_SEEK_RETRIES) // first retry\r\n            {\r\n                $(_audioElement).off(ev, onSeeked);\r\n            }\r\n    \r\n            if (DEBUG)\r\n            {\r\n                console.debug(\"onSeeked() #\" + event.data.playId + \" FIRST? \" + notRetry + \" EV: \" + ev);\r\n            }\r\n    \r\n            var curTime = _audioElement.currentTime;\r\n            var diff = Math.abs(event.data.newCurrentTime - curTime);\r\n    \r\n            if((notRetry || event.data.seekRetries >= 0) &&\r\n                diff >= 1)\r\n            {\r\n                if (DEBUG)\r\n                {\r\n                    console.debug(\"onSeeked() time diff: \" + event.data.newCurrentTime + \" vs. \" + curTime + \" (\"+diff+\")\");\r\n                }\r\n                \r\n                if (notRetry)\r\n                {\r\n                    event.data.seekRetries = MAX_SEEK_RETRIES;\r\n    \r\n                    // if (DEBUG)\r\n                    // {\r\n                    //     console.debug(\"onSeeked() fail => first retry, EV: \" + _seekedEvent2);\r\n                    // }\r\n    \r\n                    event.data.isNewSrc = false;\r\n                    //$(_audioElement).on(_seekedEvent2, event.data, onSeeked);\r\n                }\r\n                \r\n                //else\r\n                {\r\n                    event.data.seekRetries--;\r\n    \r\n                    if (DEBUG)\r\n                    {\r\n                        console.debug(\"onSeeked() FAIL => retry again (timeout)\");\r\n                    }\r\n    \r\n                    setTimeout(function()\r\n                    {\r\n                        onSeeked(event);\r\n                    }, _Android ? 1000 : 200);\r\n                }\r\n    \r\n                setTimeout(function()\r\n                {\r\n                    _audioElement.pause();\r\n                    try\r\n                    {\r\n                        _audioElement.currentTime = event.data.newCurrentTime;\r\n                    }\r\n                    catch (ex)\r\n                    {\r\n                        console.error(ex.message);\r\n    \r\n                        setTimeout(function()\r\n                        {\r\n                            try\r\n                            {\r\n                                _audioElement.currentTime = event.data.newCurrentTime;\r\n                            }\r\n                            catch (ex)\r\n                            {\r\n                                console.error(ex.message);\r\n                            }\r\n                        }, 4);\r\n                    }\r\n                }, 5);\r\n            }\r\n            else\r\n            {\r\n                if (DEBUG)\r\n                {\r\n                    console.debug(\"onSeeked() STATE:\");\r\n                    console.debug(notRetry);\r\n                    console.debug(event.data.seekRetries);\r\n                    console.debug(diff);\r\n                }\r\n    \r\n                if (diff >= 1)\r\n                {\r\n                    if (DEBUG)\r\n                    {\r\n                        console.debug(\"onSeeked() ABORT, TRY AGAIN FROM SCRATCH!\");\r\n                    }\r\n                    \r\n                    var smilSrc = _currentSmilSrc;\r\n                    var epubSrc = _currentEpubSrc;\r\n                    var seekBegin = event.data.newCurrentTime;\r\n                    \r\n                    self.reset();\r\n                    \r\n                    setTimeout(function()\r\n                    {\r\n                        self.playFile(smilSrc, epubSrc, seekBegin);\r\n                    }, 10);\r\n                    \r\n                    return;\r\n                }\r\n\r\n                if (DEBUG)\r\n                {\r\n                    console.debug(\"onSeeked() OKAY => play!\");\r\n                }\r\n                \r\n                event.data.seekRetries = undefined;\r\n    \r\n                self.play();\r\n    \r\n                _audioElement.moSeeking = undefined;\r\n            }\r\n        }\r\n    };\r\n\r\n    return AudioPlayer;\r\n});\r\n\n",
    "//  LauncherOSX\r\n//\r\n//  Created by Boris Schneiderman.\r\n// Modified by Daniel Weck\r\n//  Copyright (c) 2014 Readium Foundation and/or its licensees. All rights reserved.\r\n//  \r\n//  Redistribution and use in source and binary forms, with or without modification, \r\n//  are permitted provided that the following conditions are met:\r\n//  1. Redistributions of source code must retain the above copyright notice, this \r\n//  list of conditions and the following disclaimer.\r\n//  2. Redistributions in binary form must reproduce the above copyright notice, \r\n//  this list of conditions and the following disclaimer in the documentation and/or \r\n//  other materials provided with the distribution.\r\n//  3. Neither the name of the organization nor the names of its contributors may be \r\n//  used to endorse or promote products derived from this software without specific \r\n//  prior written permission.\r\n//  \r\n//  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND \r\n//  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED \r\n//  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. \r\n//  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, \r\n//  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, \r\n//  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, \r\n//  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF \r\n//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE \r\n//  OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED \r\n//  OF THE POSSIBILITY OF SUCH DAMAGE.\r\n\r\ndefine('readium_shared_js/views/media_overlay_element_highlighter',['jquery', 'rangy', 'readium_cfi_js'], function($, rangy, epubCfi) {\r\n/**\r\n *\r\n * @param reader\r\n * @constructor\r\n */\r\nvar MediaOverlayElementHighlighter = function(reader) {\r\n\r\n    this.includeParWhenAdjustingToSeqSyncGranularity = true;\r\n\r\n    var DEFAULT_MO_ACTIVE_CLASS = \"mo-active-default\";\r\n    var DEFAULT_MO_SUB_SYNC_CLASS = \"mo-sub-sync\";\r\n    \r\n    //var BACK_COLOR = \"#99CCCC\";\r\n\r\n    var _highlightedElementPar = undefined;\r\n    this.isElementHighlighted = function(par)\r\n    {\r\n        return _highlightedElementPar && par === _highlightedElementPar;\r\n    };\r\n    \r\n    var _highlightedCfiPar = undefined;\r\n    this.isCfiHighlighted = function(par)\r\n    {\r\n        return _highlightedCfiPar && par === _highlightedCfiPar;\r\n    };\r\n\r\n    var _activeClass = \"\";\r\n    var _playbackActiveClass = \"\";\r\n\r\n    var _reader = reader;\r\n    \r\n    var USE_RANGY = true && (typeof rangy !== \"undefined\");\r\n    var _rangyCSS = undefined;\r\n    var _rangyRange = undefined;\r\n    \r\n    var HIGHLIGHT_ID = \"MO_SPEAK\";\r\n    \r\n    var self = this;\r\n\r\n    var $userStyle = undefined;\r\n    \r\n    this.reDo = function()\r\n    {\r\n        //this.reset();\r\n        \r\n        if ($userStyle)\r\n        {\r\n            $userStyle.remove();\r\n        }\r\n        $userStyle = undefined;\r\n\r\n        var he = _highlightedElementPar;\r\n        var hc = _highlightedCfiPar;\r\n        var c1 = _activeClass;\r\n        var c2 = _playbackActiveClass;\r\n        \r\n        if (_highlightedElementPar)\r\n        {\r\n            this.reset();\r\n\r\n            this.highlightElement(he, c1, c2);\r\n        }\r\n        else if (_highlightedCfiPar)\r\n        {\r\n            this.reset();\r\n\r\n            this.highlightCfi(hc, c1, c2);\r\n        }\r\n    };\r\n\r\n    function ensureUserStyle($element, hasAuthorStyle, overrideWithUserStyle)\r\n    {\r\n        if ($userStyle)\r\n        {\r\n            try\r\n            {\r\n                if ($userStyle[0].ownerDocument === $element[0].ownerDocument)\r\n                {\r\n                    return;\r\n                }\r\n            }\r\n            catch (e)\r\n            {\r\n                \r\n            }\r\n        }\r\n\r\n\r\n        $head = $(\"head\", $element[0].ownerDocument.documentElement);\r\n\r\n        $userStyle = $(\"<style type='text/css'> </style>\");\r\n\r\n        $userStyle.append(\".\" + DEFAULT_MO_ACTIVE_CLASS + \" {\");\r\n        \r\n        var fallbackUserStyle = \"background-color: yellow !important; color: black !important; border-radius: 0.4em;\";\r\n        \r\n        var style = overrideWithUserStyle; //_reader.userStyles().findStyle(\".\" + DEFAULT_MO_ACTIVE_CLASS);\r\n        if (style)\r\n        {\r\n            var atLeastOne = false;\r\n            for(var prop in style.declarations)\r\n            {\r\n                if(!style.declarations.hasOwnProperty(prop))\r\n                {\r\n                    continue;\r\n                }\r\n\r\n                atLeastOne = true;\r\n                $userStyle.append(prop + \": \" + style.declarations[prop] + \"; \");\r\n            }\r\n            \r\n            if (!atLeastOne && !hasAuthorStyle)\r\n            {\r\n                $userStyle.append(fallbackUserStyle);\r\n            }\r\n        }\r\n        else if (!hasAuthorStyle)\r\n        {\r\n            $userStyle.append(fallbackUserStyle);\r\n        }\r\n        \r\n        $userStyle.append(\"}\");\r\n        \r\n        \r\n        // ---- CFI\r\n        //$userStyle.append(\" .highlight {background-color: blue; border: 2x solid green;}\"); //.hover-highlight\r\n        \r\n        \r\n        $userStyle.appendTo($head);\r\n\r\n//console.debug($userStyle[0].textContent);\r\n    };\r\n    \r\n    this.highlightElement = function(par, activeClass, playbackActiveClass) {\r\n\r\n        if(!par || par === _highlightedElementPar) {\r\n            return;\r\n        }\r\n\r\n        this.reset();\r\n\r\n        _highlightedElementPar = par;\r\n        _highlightedCfiPar = undefined;\r\n        \r\n        _activeClass = activeClass;\r\n        _playbackActiveClass = playbackActiveClass;\r\n\r\n        var seq = this.adjustParToSeqSyncGranularity(_highlightedElementPar);\r\n        var element = seq.element;\r\n        \r\n        if (_playbackActiveClass && _playbackActiveClass !== \"\")\r\n        {\r\n            //console.debug(\"MO playbackActiveClass: \" + _playbackActiveClass);\r\n            $(element.ownerDocument.documentElement).addClass(_playbackActiveClass);\r\n            //console.debug(\"MO playbackActiveClass 2: \" + element.ownerDocument.documentElement.classList);\r\n        }\r\n\r\n        var $hel = $(element);\r\n\r\n        var hasAuthorStyle = _activeClass && _activeClass !== \"\";\r\n        var overrideWithUserStyle = _reader.userStyles().findStyle(\".\" + DEFAULT_MO_ACTIVE_CLASS);\r\n\r\n        ensureUserStyle($hel, hasAuthorStyle, overrideWithUserStyle);\r\n                \r\n        if (overrideWithUserStyle || !hasAuthorStyle)\r\n        {\r\n            //console.debug(\"MO active NO CLASS: \" + _activeClass);\r\n\r\n            if (hasAuthorStyle)\r\n            {\r\n                $hel.addClass(_activeClass);\r\n            }\r\n            \r\n            $hel.addClass(DEFAULT_MO_ACTIVE_CLASS);\r\n\r\n            //$(element).css(\"background\", BACK_COLOR);\r\n        }\r\n        else\r\n        {\r\n            //console.debug(\"MO activeClass: \" + _activeClass);\r\n            $hel.addClass(_activeClass);\r\n        }\r\n        \r\n        if (this.includeParWhenAdjustingToSeqSyncGranularity || _highlightedElementPar !== seq)\r\n        {\r\n            $(_highlightedElementPar.element).addClass(DEFAULT_MO_SUB_SYNC_CLASS);\r\n        }\r\n        \r\n// ---- CFI\r\n//         try\r\n//         {\r\n//             // //noinspection JSUnresolvedVariable\r\n//             // var cfi = EPUBcfi.Generator.generateElementCFIComponent(element); //$hel[0]\r\n//             // if(cfi[0] == \"!\") {\r\n//             //     cfi = cfi.substring(1);\r\n//             // }\r\n// \r\n// //console.log(element);\r\n//         \r\n//             var firstTextNode = getFirstTextNode(element);\r\n//             var txtFirst = firstTextNode.textContent;\r\n// //console.log(txtFirst);\r\n// \r\n//             var lastTextNode = getLastTextNode(element);\r\n//             var txtLast = lastTextNode.textContent;\r\n// //console.log(txtLast);\r\n//         \r\n//             var cfi = EPUBcfi.Generator.generateCharOffsetRangeComponent(\r\n//                     firstTextNode, \r\n//                     0, \r\n//                     lastTextNode, \r\n//                     txtLast.length,\r\n//                     [\"cfi-marker\"],\r\n//                     [],\r\n//                     [\"MathJax_Message\"]\r\n//                     );\r\n//             \r\n//             var id = $hel.data(\"mediaOverlayData\").par.getSmil().spineItemId;\r\n//             _reader.addHighlight(id, cfi, HIGHLIGHT_ID,\r\n//             \"highlight\", //\"underline\"\r\n//             undefined // styles\r\n//                         );\r\n//         }\r\n//         catch(error)\r\n//         {\r\n//             console.error(error);\r\n//         \r\n//             removeHighlight();\r\n//         }\r\n    };\r\n    \r\n    this.highlightCfi = function(par, activeClass, playbackActiveClass) {\r\n\r\n        if(!par || par === _highlightedCfiPar) {\r\n            return;\r\n        }\r\n\r\n        this.reset();\r\n\r\n        _highlightedElementPar = undefined;\r\n        _highlightedCfiPar = par;\r\n        \r\n        _activeClass = activeClass;\r\n        _playbackActiveClass = playbackActiveClass;\r\n\r\n        var $hel = $(_highlightedCfiPar.cfi.cfiTextParent);\r\n\r\n        var hasAuthorStyle = _activeClass && _activeClass !== \"\";\r\n        var overrideWithUserStyle = _reader.userStyles().findStyle(\".\" + DEFAULT_MO_ACTIVE_CLASS); // TODO: performance issue?\r\n\r\n        ensureUserStyle($hel, hasAuthorStyle, overrideWithUserStyle);\r\n\r\n        var clazz = (overrideWithUserStyle || !hasAuthorStyle) ? ((hasAuthorStyle ? (_activeClass + \" \") : \"\") + DEFAULT_MO_ACTIVE_CLASS) : _activeClass;\r\n\r\n        if (USE_RANGY)\r\n        {\r\n            var doc = _highlightedCfiPar.cfi.cfiTextParent.ownerDocument;\r\n\r\n            _rangyRange = rangy.createRange(doc); //createNativeRange\r\n\r\n            var startCFI = \"epubcfi(\" + _highlightedCfiPar.cfi.partialStartCfi + \")\";\r\n            var infoStart = EPUBcfi.getTextTerminusInfoWithPartialCFI(startCFI, doc,\r\n                [\"cfi-marker\", \"mo-cfi-highlight\"],\r\n                [],\r\n                [\"MathJax_Message\"]);\r\n//console.log(infoStart);\r\n\r\n            var endCFI = \"epubcfi(\" + _highlightedCfiPar.cfi.partialEndCfi + \")\";\r\n            var infoEnd = EPUBcfi.getTextTerminusInfoWithPartialCFI(endCFI, doc,\r\n                [\"cfi-marker\", \"mo-cfi-highlight\"],\r\n                [],\r\n                [\"MathJax_Message\"]);\r\n//console.log(infoEnd);\r\n            \r\n            _rangyRange.setStartAndEnd(\r\n                infoStart.textNode, infoStart.textOffset,\r\n                infoEnd.textNode, infoEnd.textOffset\r\n            );\r\n            \r\n            if (false && // we use CssClassApplier instead, because surroundContents() has no trivial undoSurroundContents() function (inc. text nodes normalisation, etc.)\r\n                _rangyRange.canSurroundContents())\r\n            {\r\n                _rangyRange.MO_createCssClassApplier = false;\r\n                \r\n                var span = doc.createElementNS(\"http://www.w3.org/1999/xhtml\", 'span');\r\n                span.id = HIGHLIGHT_ID;\r\n                span.setAttribute(\"id\", span.id);\r\n                span.setAttribute(\"class\", clazz + \" mo-cfi-highlight\");\r\n            \r\n                _rangyRange.surroundContents(span);\r\n            }\r\n            else\r\n            {\r\n                _rangyRange.MO_createCssClassApplier = true;\r\n                \r\n                if (!_rangyCSS || _rangyCSS.cssClass !== clazz)\r\n                {\r\n                    _rangyCSS = rangy.createCssClassApplier(clazz,\r\n                    {\r\n                        elementTagName: \"span\",\r\n                        elementProperties: {className: \"mo-cfi-highlight\"},\r\n                        ignoreWhiteSpace: true,\r\n                        applyToEditableOnly: false,\r\n                        normalize: true\r\n                    },\r\n                    [\"span\"]);\r\n                }\r\n\r\n                _rangyCSS.applyToRange(_rangyRange);\r\n            }\r\n        }\r\n        else if (_reader.plugins.highlights) // same API, newer implementation\r\n        {\r\n            try\r\n            {\r\n                //var id = $hel.data(\"mediaOverlayData\").par.getSmil().spineItemId;\r\n                var id = par.getSmil().spineItemId;\r\n                _reader.plugins.highlights.addHighlight(id, par.cfi.partialRangeCfi, HIGHLIGHT_ID,\r\n                \"highlight\", //\"underline\"\r\n                undefined // styles\r\n                            );\r\n            }\r\n            catch(error)\r\n            {\r\n                console.error(error);\r\n            }\r\n        }\r\n        else if (_reader.plugins.annotations) // legacy\r\n        {\r\n            try\r\n            {\r\n                //var id = $hel.data(\"mediaOverlayData\").par.getSmil().spineItemId;\r\n                var id = par.getSmil().spineItemId;\r\n                _reader.plugins.annotations.addHighlight(id, par.cfi.partialRangeCfi, HIGHLIGHT_ID,\r\n                \"highlight\", //\"underline\"\r\n                undefined // styles\r\n                            );\r\n            }\r\n            catch(error)\r\n            {\r\n                console.error(error);\r\n            }\r\n        }\r\n    };\r\n    \r\n// ---- CFI\r\n//     \r\n//     function getFirstTextNode(node)\r\n//     {\r\n//         if (node.nodeType === Node.TEXT_NODE)\r\n//         {\r\n//             if (node.textContent.trim().length > 0)\r\n//                 return node;\r\n//         }\r\n//         \r\n//         for (var i = 0; i < node.childNodes.length; i++)\r\n//         {\r\n//             var child = node.childNodes[i];\r\n//             var first = getFirstTextNode(child);\r\n//             if (first)\r\n//             {\r\n//                 return first;\r\n//             }\r\n//         }\r\n//         \r\n//         return undefined;\r\n//     }\r\n//     \r\n//     function getLastTextNode(node)\r\n//     {\r\n//         if (node.nodeType === Node.TEXT_NODE)\r\n//         {\r\n//             if (node.textContent.trim().length > 0)\r\n//                 return node;\r\n//         }\r\n//         \r\n//         for (var i = node.childNodes.length-1; i >= 0; i--)\r\n//         {\r\n//             var child = node.childNodes[i];\r\n//             var last = getLastTextNode(child);\r\n//             if (last)\r\n//             {\r\n//                 return last;\r\n//             }\r\n//         }\r\n//         \r\n//         return undefined;\r\n//     }\r\n//     \r\n\r\n    this.reset = function() {\r\n        \r\n        if (_highlightedCfiPar)\r\n        {\r\n            var doc = _highlightedCfiPar.cfi.cfiTextParent.ownerDocument;\r\n            if (USE_RANGY)\r\n            {\r\n                if (_rangyCSS && _rangyRange.MO_createCssClassApplier)\r\n                {\r\n                    _rangyCSS.undoToRange(_rangyRange);\r\n                }\r\n                else\r\n                {\r\n                    var toRemove = undefined;\r\n                    while ((toRemove = doc.getElementById(HIGHLIGHT_ID)) !== null)\r\n                    {\r\n                        var txt = toRemove.textContent; // TODO: innerHTML? or better: hasChildNodes loop + detach and re-attach\r\n                        var txtNode = doc.createTextNode(txt);\r\n                        \r\n                        toRemove.parentNode.replaceChild(txtNode, toRemove);\r\n                        txtNode.parentNode.normalize();\r\n                    }\r\n                }\r\n        \r\n                //_rangyCSS = undefined;\r\n                _rangyRange = undefined;\r\n            }\r\n            else if (_reader.plugins.highlights) // same API, new implementation\r\n            {\r\n                try\r\n                {\r\n                    _reader.plugins.highlights.removeHighlight(HIGHLIGHT_ID);\r\n        \r\n                    var toRemove = undefined;\r\n                    while ((toRemove = doc.getElementById(\"start-\" + HIGHLIGHT_ID)) !== null)\r\n                    {\r\n            console.log(\"toRemove START\");\r\n            console.log(toRemove);\r\n                        toRemove.parentNode.removeChild(toRemove);\r\n                    }\r\n                    while ((toRemove = doc.getElementById(\"end-\" + HIGHLIGHT_ID)) !== null)\r\n                    {\r\n            console.log(\"toRemove END\");\r\n            console.log(toRemove);\r\n                        toRemove.parentNode.removeChild(toRemove);\r\n                    }\r\n                }\r\n                catch(error)\r\n                {\r\n                    console.error(error);\r\n                }\r\n            }\r\n            else if (_reader.plugins.annotations) // legacy\r\n            {\r\n                try\r\n                {\r\n                    _reader.plugins.annotations.removeHighlight(HIGHLIGHT_ID);\r\n        \r\n                    var toRemove = undefined;\r\n                    while ((toRemove = doc.getElementById(\"start-\" + HIGHLIGHT_ID)) !== null)\r\n                    {\r\n            console.log(\"toRemove START\");\r\n            console.log(toRemove);\r\n                        toRemove.parentNode.removeChild(toRemove);\r\n                    }\r\n                    while ((toRemove = doc.getElementById(\"end-\" + HIGHLIGHT_ID)) !== null)\r\n                    {\r\n            console.log(\"toRemove END\");\r\n            console.log(toRemove);\r\n                        toRemove.parentNode.removeChild(toRemove);\r\n                    }\r\n                }\r\n                catch(error)\r\n                {\r\n                    console.error(error);\r\n                }\r\n            }\r\n            \r\n            _highlightedCfiPar = undefined;\r\n        }\r\n        \r\n        \r\n        \r\n\r\n        if(_highlightedElementPar) {\r\n\r\n            var seq = this.adjustParToSeqSyncGranularity(_highlightedElementPar);\r\n            var element = seq.element;\r\n            if (this.includeParWhenAdjustingToSeqSyncGranularity || _highlightedElementPar !== seq)\r\n            {\r\n                $(_highlightedElementPar.element).removeClass(DEFAULT_MO_SUB_SYNC_CLASS);\r\n            }\r\n            \r\n            if (_playbackActiveClass && _playbackActiveClass !== \"\")\r\n            {\r\n                //console.debug(\"MO RESET playbackActiveClass: \" + _playbackActiveClass);\r\n                $(element.ownerDocument.documentElement).removeClass(_playbackActiveClass);\r\n            }\r\n\r\n            if (_activeClass && _activeClass !== \"\")\r\n            {\r\n                //console.debug(\"MO RESET activeClass: \" + _activeClass);\r\n                $(element).removeClass(_activeClass);\r\n            }\r\n            //else\r\n            //{\r\n                //console.debug(\"MO RESET active NO CLASS: \" + _activeClass);\r\n                $(element).removeClass(DEFAULT_MO_ACTIVE_CLASS);\r\n                //$(element).css(\"background\", '');\r\n            //}\r\n\r\n            _highlightedElementPar = undefined;\r\n        }\r\n\r\n        _activeClass = \"\";\r\n        _playbackActiveClass = \"\";\r\n    };\r\n\r\n    this.adjustParToSeqSyncGranularity = function(par)\r\n    {\r\n        if (!par) return undefined;\r\n        \r\n        var sync = _reader.viewerSettings().mediaOverlaysSynchronizationGranularity;\r\n        if (sync && sync.length > 0)\r\n        {\r\n            var element = par.element || (par.cfi ? par.cfi.cfiTextParent : undefined);\r\n            if (!element)\r\n            {\r\n                console.error(\"adjustParToSeqSyncGranularity !element ???\");\r\n                return par; // should never happen!\r\n            }\r\n\r\n            var seq = par.getFirstSeqAncestorWithEpubType(sync, this.includeParWhenAdjustingToSeqSyncGranularity);\r\n            if (seq && seq.element)\r\n            {\r\n                return seq;\r\n            }\r\n        }\r\n        \r\n        return par;\r\n    };\r\n};\r\n    return MediaOverlayElementHighlighter;\r\n});\r\n\n",
    "//  Created by Boris Schneiderman.\r\n// Modified by Daniel Weck\r\n//  Copyright (c) 2014 Readium Foundation and/or its licensees. All rights reserved.\r\n//\r\n//  Redistribution and use in source and binary forms, with or without modification,\r\n//  are permitted provided that the following conditions are met:\r\n//  1. Redistributions of source code must retain the above copyright notice, this\r\n//  list of conditions and the following disclaimer.\r\n//  2. Redistributions in binary form must reproduce the above copyright notice,\r\n//  this list of conditions and the following disclaimer in the documentation and/or\r\n//  other materials provided with the distribution.\r\n//  3. Neither the name of the organization nor the names of its contributors may be\r\n//  used to endorse or promote products derived from this software without specific\r\n//  prior written permission.\r\n//\r\n//  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\r\n//  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n//  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\r\n//  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\r\n//  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\r\n//  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\r\n//  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\r\n//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE\r\n//  OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\r\n//  OF THE POSSIBILITY OF SUCH DAMAGE.\r\ndefine('readium_shared_js/views/scroll_view',[\"../globals\", \"jquery\", \"underscore\", \"eventEmitter\", \"../models/bookmark_data\", \"../models/current_pages_info\", \"../helpers\",\r\n        \"./one_page_view\", \"../models/page_open_request\", \"../models/viewer_settings\"],\r\n    function (Globals, $, _, EventEmitter, BookmarkData, CurrentPagesInfo, Helpers,\r\n              OnePageView, PageOpenRequest, ViewerSettings) {\r\n/**\r\n * Renders content inside a scrollable view port\r\n * @param options\r\n * @param isContinuousScroll\r\n * @param reader\r\n * @constructor\r\n */\r\nvar ScrollView = function (options, isContinuousScroll, reader) {\r\n\r\n    var _DEBUG = false;\r\n\r\n    //https://github.com/jquery/jquery/commit/2d715940b9b6fdeed005cd006c8bf63951cf7fb2\r\n    //https://github.com/jquery/jquery/commit/49833f7795d665ff1d543c4f71f29fca95b567e9\r\n    //https://github.com/jquery/jquery/compare/2.1.4...2.2.0\r\n    var _jQueryPositionNeedsFix = false; // v2.2.0 only\r\n    try {\r\n        var vs = $.fn.jquery.split(\".\");\r\n        if (parseInt(vs[0]) == 2 && parseInt(vs[1]) == 2 && parseInt(vs[2]) == 0) {\r\n            _jQueryPositionNeedsFix = true;\r\n        }\r\n    } catch(err) {\r\n        console.error(err);\r\n    }\r\n    \r\n    $.extend(this, new EventEmitter());\r\n\r\n    var SCROLL_MARGIN_TO_SHOW_LAST_VISBLE_LINE = 5;\r\n    var ITEM_LOAD_SCROLL_BUFFER = 2000;\r\n    var ON_SCROLL_TIME_DALAY = 300;\r\n\r\n    var self = this;\r\n\r\n    var _$viewport = options.$viewport;\r\n    var _spine = options.spine;\r\n    var _userStyles = options.userStyles;\r\n    var _deferredPageRequest;\r\n    var _currentPageRequest;\r\n    var _$contentFrame;\r\n    var _$el;\r\n\r\n    var _stopTransientViewUpdate = false;\r\n\r\n    //this flags used to prevent onScroll event triggering pagination changed when internal layout modifications happens\r\n    //if we trigger pagination change without reference to the original request that started the change - we brake the\r\n    //Media Overlay bechaviyour\r\n    //We can't reuse same flag for all of this action because this actions mey happen in parallel\r\n    var _isPerformingLayoutModifications = false; //performing asynch  actions that may trigger onScroll;\r\n    var _isSettingScrollPosition = false; //this happens when we set scroll position based on open element request\r\n    var _isLoadingNewSpineItemOnPageRequest = false; //\r\n\r\n    this.isContinuousScroll = function () {\r\n        return isContinuousScroll;\r\n    };\r\n\r\n    this.render = function () {\r\n\r\n        var template = Helpers.loadTemplate(\"scrolled_book_frame\", {});\r\n\r\n        _$el = $(template);\r\n        _$viewport.append(_$el);\r\n\r\n        _$contentFrame = $(\"#scrolled-content-frame\", _$el);\r\n        _$contentFrame.css(\"overflow\", \"\");\r\n        _$contentFrame.css(\"overflow-y\", \"auto\");\r\n        _$contentFrame.css(\"overflow-x\", \"hidden\");\r\n        _$contentFrame.css(\"-webkit-overflow-scrolling\", \"touch\");\r\n        _$contentFrame.css(\"width\", \"100%\");\r\n        _$contentFrame.css(\"height\", \"100%\");\r\n        _$contentFrame.css(\"position\", \"relative\");\r\n\r\n        var settings = reader.viewerSettings();\r\n        if (!settings || typeof settings.enableGPUHardwareAccelerationCSS3D === \"undefined\")\r\n        {\r\n            //defaults\r\n            settings = new ViewerSettings({});\r\n        }\r\n        if (settings.enableGPUHardwareAccelerationCSS3D) {\r\n            // This is a necessary counterpart for the same CSS GPU hardware acceleration trick in one_page_view.js\r\n            // This affects the stacking order and re-enables the scrollbar in Safari (works fine in Chrome otherwise)\r\n            _$contentFrame.css(\"transform\", \"translateZ(0)\");\r\n        }\r\n\r\n        // _$contentFrame.css(\"box-sizing\", \"border-box\");\r\n        // _$contentFrame.css(\"border\", \"20px solid red\");\r\n\r\n        self.applyStyles();\r\n\r\n        var lazyScroll = _.debounce(onScroll, ON_SCROLL_TIME_DALAY);\r\n\r\n        _$contentFrame.on('scroll', function (e) {\r\n            lazyScroll(e);\r\n            onScrollDirect();\r\n        });\r\n\r\n        return self;\r\n    };\r\n\r\n    function updateLoadedViewsTop(callback, assertScrollPosition) {\r\n\r\n        if (_stopTransientViewUpdate) {\r\n            callback();\r\n            return;\r\n        }\r\n\r\n        var viewPage = firstLoadedView();\r\n        if (!viewPage) {\r\n            callback();\r\n            return;\r\n        }\r\n\r\n        var viewPortRange = getVisibleRange(0);\r\n        var firstViewRange = getPageViewRange(viewPage);\r\n\r\n        if ((viewPortRange.top - firstViewRange.bottom) > ITEM_LOAD_SCROLL_BUFFER) {\r\n            var scrollPos = scrollTop();\r\n            removePageView(viewPage);\r\n            scrollTo(scrollPos - (firstViewRange.bottom - firstViewRange.top), undefined);\r\n            assertScrollPosition(\"updateLoadedViewsTop 1\");\r\n            updateLoadedViewsTop(callback, assertScrollPosition); //recursion\r\n        }\r\n        else if ((viewPortRange.top - firstViewRange.top) < ITEM_LOAD_SCROLL_BUFFER) {\r\n            addToTopOf(viewPage, function (isElementAdded) {\r\n                if (isElementAdded) {\r\n                    assertScrollPosition(\"updateLoadedViewsTop 2\");\r\n                    updateLoadedViewsTop(callback, assertScrollPosition); //recursion\r\n                }\r\n                else {\r\n                    callback();\r\n                }\r\n            });\r\n        }\r\n        else {\r\n            callback();\r\n        }\r\n\r\n    }\r\n\r\n    function updateLoadedViewsBottom(callback, assertScrollPosition) {\r\n\r\n        if (_stopTransientViewUpdate) {\r\n            callback();\r\n            return;\r\n        }\r\n\r\n        var viewPage = lastLoadedView();\r\n        if (!viewPage) {\r\n            callback();\r\n            return;\r\n        }\r\n\r\n        var viewPortRange = getVisibleRange(0);\r\n        var lastViewRange = getPageViewRange(viewPage);\r\n\r\n        if ((lastViewRange.top - viewPortRange.bottom) > ITEM_LOAD_SCROLL_BUFFER) {\r\n            removePageView(viewPage);\r\n            assertScrollPosition(\"updateLoadedViewsBottom 1\");\r\n            updateLoadedViewsBottom(callback, assertScrollPosition); //recursion\r\n        }\r\n        else if ((lastViewRange.bottom - viewPortRange.bottom) < ITEM_LOAD_SCROLL_BUFFER) {\r\n            addToBottomOf(viewPage, function (newPageLoaded) {\r\n                assertScrollPosition(\"updateLoadedViewsBottom 2\");\r\n                if (newPageLoaded) {\r\n                    updateLoadedViewsBottom(callback, assertScrollPosition); //recursion\r\n                }\r\n                else {\r\n                    callback();\r\n                }\r\n            });\r\n        }\r\n        else {\r\n            callback();\r\n        }\r\n\r\n    }\r\n\r\n    function updateTransientViews(pageView) {\r\n\r\n        if (!isContinuousScroll) {\r\n            return;\r\n        }\r\n\r\n        var scrollPosBefore = undefined;\r\n        if (_DEBUG)\r\n        {\r\n            if (pageView)\r\n            {\r\n                var offset = pageView.offset();\r\n                if (offset) scrollPosBefore = offset.top;\r\n            }\r\n        }\r\n\r\n        // This function double-checks whether the browser has shifted the scroll position because of unforeseen rendering issues.\r\n        // (this should never happen because we handle scroll adjustments during iframe height resizes explicitely in this code)\r\n        var assertScrollPosition = function(msg)\r\n        {\r\n            if (_DEBUG)\r\n            {\r\n                if (!scrollPosBefore) return;\r\n                var scrollPosAfter = undefined;\r\n\r\n                var offset = pageView.offset();\r\n                if (offset) scrollPosAfter = offset.top;\r\n\r\n                if (!scrollPosAfter) return;\r\n\r\n                var diff = scrollPosAfter - scrollPosBefore;\r\n                if (Math.abs(diff) > 1)\r\n                {\r\n                    console.debug(\"@@@@@@@@@@@@@@@ SCROLL ADJUST (\" + msg + \") \" + diff + \" -- \" + pageView.currentSpineItem().href);\r\n                    //_$contentFrame[0].scrollTop = _$contentFrame[0].scrollTop + diff;\r\n                }\r\n            }\r\n        };\r\n\r\n        _isPerformingLayoutModifications = true;\r\n        updateLoadedViewsBottom(function () {\r\n            updateLoadedViewsTop(function () {\r\n                setTimeout(function () {\r\n                    _isPerformingLayoutModifications = false;\r\n                }, ON_SCROLL_TIME_DALAY + 100);\r\n            }, assertScrollPosition);\r\n        }, assertScrollPosition);\r\n    }\r\n\r\n    var _mediaOverlaysWasPlayingLastTimeScrollStarted = false;\r\n\r\n    function onScrollDirect(e)\r\n    {\r\n        var settings = reader.viewerSettings();\r\n        if (!settings.mediaOverlaysPreservePlaybackWhenScroll)\r\n        {\r\n            if (!_mediaOverlaysWasPlayingLastTimeScrollStarted && reader.isMediaOverlayAvailable())\r\n            {\r\n                _mediaOverlaysWasPlayingLastTimeScrollStarted = reader.isPlayingMediaOverlay();\r\n                if (_mediaOverlaysWasPlayingLastTimeScrollStarted)\r\n                {\r\n                    reader.pauseMediaOverlay();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function onScroll(e)\r\n    {\r\n        if (   !_isPerformingLayoutModifications\r\n            && !_isSettingScrollPosition\r\n            && !_isLoadingNewSpineItemOnPageRequest) {\r\n\r\n            self.resetCurrentPosition();\r\n\r\n            updateTransientViews();\r\n            onPaginationChanged(self);\r\n\r\n            _.defer(function() {\r\n                if (!_currentPageRequest) {\r\n                    self.saveCurrentPosition();\r\n                }\r\n            })\r\n\r\n            var settings = reader.viewerSettings();\r\n            if (!settings.mediaOverlaysPreservePlaybackWhenScroll)\r\n            {\r\n                if (_mediaOverlaysWasPlayingLastTimeScrollStarted)\r\n                {\r\n                    setTimeout(function()\r\n                    {\r\n                        reader.playMediaOverlay();\r\n                        _mediaOverlaysWasPlayingLastTimeScrollStarted = false;\r\n                    }, 100);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function scrollTo(offset, pageRequest) {\r\n\r\n        _$contentFrame[0].scrollTop = offset;\r\n\r\n        if (pageRequest) {\r\n            onPaginationChanged(pageRequest.initiator, pageRequest.spineItem, pageRequest.elementId);\r\n        }\r\n    }\r\n\r\n    function updatePageViewSizeAndAdjustScroll(pageView)\r\n    {\r\n        var scrollPos = scrollTop();\r\n        var rangeBeforeResize = getPageViewRange(pageView);\r\n\r\n        updatePageViewSize(pageView);\r\n\r\n        var rangeAfterResize = getPageViewRange(pageView);\r\n\r\n        var heightAfter = rangeAfterResize.bottom - rangeAfterResize.top;\r\n        var heightBefore = rangeBeforeResize.bottom - rangeBeforeResize.top;\r\n\r\n        var delta = heightAfter - heightBefore;\r\n\r\n        if (Math.abs(delta) > 0)\r\n        {\r\n            if (_DEBUG)\r\n            {\r\n                console.debug(\"IMMEDIATE SCROLL ADJUST: \" + pageView.currentSpineItem().href + \" == \" + delta);\r\n            }\r\n            scrollTo(scrollPos + delta);\r\n        }\r\n    }\r\n\r\n    function addToTopOf(topView, callback) {\r\n\r\n        var prevSpineItem = _spine.prevItem(topView.currentSpineItem(), true);\r\n        if (!prevSpineItem) {\r\n            callback(false);\r\n            return;\r\n        }\r\n\r\n        var tmpView = createPageViewForSpineItem(true);\r\n\r\n        // add to the end first to avoid scrolling during load\r\n        var lastView = lastLoadedView();\r\n        tmpView.element().insertAfter(lastView.element());\r\n\r\n        tmpView.loadSpineItem(prevSpineItem, function (success, $iframe, spineItem, isNewlyLoaded, context) {\r\n            if (success) {\r\n\r\n                updatePageViewSize(tmpView);\r\n                var range = getPageViewRange(tmpView);\r\n\r\n                removePageView(tmpView);\r\n\r\n\r\n                var scrollPos = scrollTop();\r\n\r\n                var newView = createPageViewForSpineItem();\r\n                var originalHeight = range.bottom - range.top;\r\n\r\n\r\n                newView.setHeight(originalHeight);\r\n                // iframe is loaded hidden here\r\n                //this.showIFrame();\r\n                //===> not necessary here (temporary iframe)\r\n\r\n                newView.element().insertBefore(topView.element());\r\n\r\n                scrollPos = scrollPos + originalHeight;\r\n\r\n                scrollTo(scrollPos, undefined);\r\n\r\n                newView.loadSpineItem(prevSpineItem, function (success, $iframe, spineItem, isNewlyLoaded, context) {\r\n                    if (success) {\r\n\r\n                        updatePageViewSizeAndAdjustScroll(newView);\r\n                        onPageViewLoaded(newView, success, $iframe, spineItem, isNewlyLoaded, context);\r\n                        callback(success);\r\n                        // No need for complicated reachStableContentHeight any more\r\n                        // Remove this\r\n                        //reachStableContentHeight(0, newView, $iframe[0], spineItem.href, spineItem.isFixedLayout(), spineItem.isFixedLayout() ? newView.meta_width() : 0, \"addToTopOf\", continueCallback); // //onIFrameLoad called before this callback, so okay.\r\n                    }\r\n                    else {\r\n                        console.error(\"Unable to open 2 \" + prevSpineItem.href);\r\n                        removePageView(newView);\r\n                        callback(false);\r\n                    }\r\n\r\n                });\r\n            }\r\n            else {\r\n                console.error(\"Unable to open 1 \" + prevSpineItem.href);\r\n                removePageView(tmpView);\r\n                callback(false);\r\n            }\r\n\r\n        });\r\n    }\r\n\r\n    function updatePageViewSize(pageView) {\r\n\r\n        if (pageView.currentSpineItem().isFixedLayout()) {\r\n            pageView.scaleToWidth(_$contentFrame.width());\r\n        }\r\n        else {\r\n            pageView.resizeIFrameToContent();\r\n        }\r\n    }\r\n\r\n    function addToBottomOf(bottomView, callback) {\r\n\r\n        var nexSpineItem = _spine.nextItem(bottomView.currentSpineItem(), true);\r\n        if (!nexSpineItem) {\r\n            callback(false);\r\n            return;\r\n        }\r\n\r\n        var scrollPos = scrollTop();\r\n\r\n        var newView = createPageViewForSpineItem();\r\n        newView.element().insertAfter(bottomView.element());\r\n\r\n        newView.loadSpineItem(nexSpineItem, function (success, $iframe, spineItem, isNewlyLoaded, context) {\r\n            if (success) {\r\n\r\n                updatePageViewSize(newView);\r\n                onPageViewLoaded(newView, success, $iframe, spineItem, isNewlyLoaded, context);\r\n                callback(success);\r\n                // No need for complicated reachStableContentHeight any more\r\n                //reachStableContentHeight(2, newView, $iframe[0], spineItem.href, spineItem.isFixedLayout(), spineItem.isFixedLayout() ? newView.meta_width() : 0, \"addToBottomOf\", continueCallback); // //onIFrameLoad called before this callback, so okay.\r\n            }\r\n            else {\r\n                console.error(\"Unable to load \" + nexSpineItem.href);\r\n                callback(false);\r\n            }\r\n\r\n        });\r\n    }\r\n\r\n    function removeLoadedItems() {\r\n\r\n        var loadedPageViews = [];\r\n\r\n        forEachItemView(function (pageView) {\r\n            loadedPageViews.push(pageView);\r\n        }, false);\r\n\r\n        for (var i = 0, count = loadedPageViews.length; i < count; i++) {\r\n            removePageView(loadedPageViews[i]);\r\n        }\r\n    }\r\n\r\n    function removePageView(pageView) {\r\n\r\n        pageView.onUnload();\r\n        pageView.element().remove();\r\n\r\n    }\r\n\r\n\r\n    function setFrameSizesToRectangle(rectangle) {\r\n\r\n        _$contentFrame.css(\"left\", rectangle.left);\r\n        _$contentFrame.css(\"top\", rectangle.top);\r\n        _$contentFrame.css(\"right\", rectangle.right);\r\n        _$contentFrame.css(\"bottom\", rectangle.bottom);\r\n\r\n    }\r\n\r\n    this.remove = function () {\r\n        _$el.remove();\r\n    };\r\n\r\n    this.onViewportResize = function () {\r\n\r\n        if (!_$contentFrame) {\r\n            return;\r\n        }\r\n    };\r\n\r\n    this.resetCurrentPosition = function() {\r\n        _currentPageRequest = undefined;\r\n    };\r\n\r\n    this.saveCurrentPosition = function() {\r\n        // If there's a deferred page request, there's no point in saving the current position\r\n        // as it's going to change soon\r\n        if (_deferredPageRequest) {\r\n            return;\r\n        }\r\n\r\n        var _firstVisibleCfi = self.getFirstVisibleCfi();\r\n        var spineItem = _spine.getItemById(_firstVisibleCfi.idref);\r\n        if (spineItem) {\r\n            _currentPageRequest = new PageOpenRequest(spineItem, self);\r\n            _currentPageRequest.setElementCfi(_firstVisibleCfi.contentCFI);\r\n        }\r\n    };\r\n\r\n    this.restoreCurrentPosition = function() {\r\n        if (_currentPageRequest) {\r\n            this.openPageInternal(_currentPageRequest);            \r\n        }\r\n    };\r\n\r\n    var _viewSettings = undefined;\r\n    this.setViewSettings = function (settings) {\r\n\r\n        _viewSettings = settings;\r\n\r\n        forEachItemView(function (pageView) {\r\n\r\n            pageView.setViewSettings(settings);\r\n\r\n        }, false);\r\n    };\r\n\r\n    function createPageViewForSpineItem(isTemporaryView) {\r\n\r\n        options.disablePageTransitions = true; // force\r\n\r\n        var pageView = new OnePageView(\r\n            options,\r\n            [\"content-doc-frame\"],\r\n            true, //enableBookStyleOverrides\r\n            reader);\r\n\r\n        pageView.on(OnePageView.Events.SPINE_ITEM_OPEN_START, function($iframe, spineItem) {\r\n            \r\n            Globals.logEvent(\"OnePageView.Events.SPINE_ITEM_OPEN_START\", \"ON\", \"scroll_view.js [ \" + spineItem.href + \" ]\");\r\n\r\n            Globals.logEvent(\"CONTENT_DOCUMENT_LOAD_START\", \"EMIT\", \"scroll_view.js [ \" + spineItem.href + \" ]\");\r\n            self.emit(Globals.Events.CONTENT_DOCUMENT_LOAD_START, $iframe, spineItem);\r\n        });\r\n\r\n        pageView.on(Globals.Events.CONTENT_DOCUMENT_UNLOADED, function($iframe, spineItem) {\r\n            Globals.logEvent(\"CONTENT_DOCUMENT_UNLOADED\", \"ON\", \"scroll_view.js [ \" + spineItem.href + \" ]\");\r\n            self.emit(Globals.Events.CONTENT_DOCUMENT_UNLOADED, $iframe, spineItem);\r\n        });\r\n\r\n        function updatePageViewSizeAndPagination_() {\r\n            // Resize the PageView to fit its content and update the pagination\r\n            // and the adjacent views\r\n            updatePageViewSize(pageView);\r\n            onPaginationChanged(self);\r\n            updateTransientViews();\r\n            if (_currentPageRequest && !_deferredPageRequest) {\r\n                self.restoreCurrentPosition();                \r\n            }\r\n        }\r\n        var updatePageViewSizeAndPagination = _.debounce(updatePageViewSizeAndPagination_, 100);\r\n\r\n        // Observe the CONTENT_SIZE_CHANGED from the page view so the ScrollView\r\n        // is notified when the size of the content of the view changes, because\r\n        // the font or the viewport size has changed\r\n        pageView.on(OnePageView.Events.CONTENT_SIZE_CHANGED, function($iframe, spineItem) {\r\n            \r\n            Globals.logEvent(\"OnePageView.Events.CONTENT_SIZE_CHANGED\", \"ON\", \"scroll_view.js [ \" + spineItem.href + \" ]\");\r\n            updatePageViewSizeAndPagination();\r\n        });\r\n\r\n        pageView.render();\r\n        if (_viewSettings) pageView.setViewSettings(_viewSettings);\r\n\r\n        if (!isTemporaryView) {\r\n            pageView.element().data(\"pageView\", pageView);\r\n        }\r\n\r\n\r\n        if (isContinuousScroll)\r\n        {\r\n            pageView.decorateIframe();\r\n        }\r\n\r\n        return pageView;\r\n    }\r\n\r\n    function findPageViewForSpineItem(spineItem, reverse) {\r\n\r\n        var retView = undefined;\r\n\r\n        forEachItemView(function (pageView) {\r\n            if (pageView.currentSpineItem() == spineItem) {\r\n                retView = pageView;\r\n                //brake the iteration\r\n                return false;\r\n            }\r\n            else {\r\n                return true;\r\n            }\r\n\r\n        }, reverse);\r\n\r\n        return retView;\r\n    }\r\n\r\n    function forEachItemView(func, reverse) {\r\n\r\n        var pageNodes = _$contentFrame.children();\r\n\r\n        var count = pageNodes.length;\r\n        var iter = reverse ? function(ix) { return ix - 1}\r\n                           : function(ix) { return ix + 1};\r\n\r\n        var compare = reverse ? function(ix) { return ix >= 0}\r\n                              : function(ix) { return ix < count };\r\n\r\n        var start = reverse ? count - 1 : 0;\r\n\r\n        for (var i = start; compare(i); i = iter(i)) {\r\n\r\n            var $element = pageNodes.eq(i);\r\n            var curView = $element.data(\"pageView\");\r\n\r\n            if (curView) {\r\n\r\n                if (func(curView) === false) {\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function firstLoadedView() {\r\n\r\n        var firstView = undefined;\r\n\r\n        forEachItemView(function (pageView) {\r\n\r\n            firstView = pageView;\r\n            return false;\r\n\r\n        }, false);\r\n\r\n        return firstView;\r\n    }\r\n\r\n    function lastLoadedView() {\r\n\r\n        var lastView = undefined;\r\n\r\n        forEachItemView(function (pageView) {\r\n            lastView = pageView;\r\n            return false;\r\n\r\n        }, true);\r\n\r\n        return lastView;\r\n    }\r\n\r\n    function onPageViewLoaded(pageView, success, $iframe, spineItem, isNewlyLoaded, context) {\r\n\r\n        if (success && isNewlyLoaded) {\r\n            Globals.logEvent(\"CONTENT_DOCUMENT_LOADED\", \"EMIT\", \"scroll_view.js [ \" + spineItem.href + \" ]\");\r\n            self.emit(Globals.Events.CONTENT_DOCUMENT_LOADED, $iframe, spineItem);\r\n        }\r\n\r\n    }\r\n\r\n    function loadSpineItem(spineItem, callback) {\r\n\r\n        removeLoadedItems();\r\n\r\n        var scrollPos = scrollTop();\r\n\r\n        var loadedView = createPageViewForSpineItem();\r\n\r\n        _$contentFrame.append(loadedView.element());\r\n\r\n        loadedView.loadSpineItem(spineItem, function (success, $iframe, spineItem, isNewlyLoaded, context) {\r\n\r\n            if (success) {\r\n\r\n                updatePageViewSize(loadedView);\r\n                onPageViewLoaded(loadedView, success, $iframe, spineItem, isNewlyLoaded, context);\r\n                //callback(loadedView);\r\n                // No need for complicated reachStableContentHeight any more\r\n                //reachStableContentHeight(1, loadedView, $iframe[0], spineItem.href, spineItem.isFixedLayout(), spineItem.isFixedLayout() ? loadedView.meta_width() : 0, \"openPage\", continueCallback); // //onIFrameLoad called before this callback, so okay.\r\n            }\r\n            else {\r\n                console.error(\"Unable to load \" + spineItem.href);\r\n\r\n                removePageView(loadedView);\r\n                loadedView = undefined;\r\n            }\r\n\r\n            callback(loadedView);\r\n\r\n        });\r\n\r\n    }\r\n\r\n    this.applyStyles = function () {\r\n\r\n        Helpers.setStyles(_userStyles.getStyles(), _$el.parent());\r\n\r\n        //because left, top, bottom, right setting ignores padding of parent container\r\n        //we have to take it to account manually\r\n        var elementMargins = Helpers.Margins.fromElement(_$el);\r\n\r\n        setFrameSizesToRectangle(elementMargins.padding);\r\n\r\n    };\r\n\r\n    this.applyBookStyles = function () {\r\n\r\n        forEachItemView(function (pageView) {\r\n            pageView.applyBookStyles();\r\n        }, false);\r\n    };\r\n\r\n\r\n    this.openPageInternal = function (pageRequest) {\r\n\r\n        _stopTransientViewUpdate = true;\r\n\r\n        //local helper function\r\n        var doneLoadingSpineItem = function (pageView, pageRequest) {\r\n\r\n            _deferredPageRequest = undefined;\r\n            openPageViewElement(pageView, pageRequest);\r\n            _stopTransientViewUpdate = false;\r\n            updateTransientViews(pageView);\r\n        };\r\n\r\n        if (pageRequest.spineItem) {\r\n\r\n            var pageView = findPageViewForSpineItem(pageRequest.spineItem);\r\n            if (pageView) {\r\n                doneLoadingSpineItem(pageView, pageRequest);\r\n            }\r\n            else {\r\n                _deferredPageRequest = pageRequest;\r\n                _isLoadingNewSpineItemOnPageRequest = true;\r\n\r\n                loadSpineItem(pageRequest.spineItem, function (pageView) {\r\n\r\n                    setTimeout(function () {\r\n                        _isLoadingNewSpineItemOnPageRequest = false;\r\n                    }, ON_SCROLL_TIME_DALAY + 100);\r\n\r\n                    if (pageView && _deferredPageRequest) {\r\n                        if (pageView.currentSpineItem() === _deferredPageRequest.spineItem) {\r\n                            doneLoadingSpineItem(pageView, _deferredPageRequest);\r\n                        }\r\n                        else { //while we where waiting for load new request come\r\n                            self.openPage(_deferredPageRequest); //recursion\r\n                        }\r\n                    }\r\n                    else {\r\n                        onPaginationChanged(pageRequest.initiator, pageRequest.spineItem, pageRequest.elementId);\r\n                    }\r\n\r\n                });\r\n            }\r\n        }\r\n        else {\r\n            doneLoadingSpineItem(undefined, pageRequest);\r\n        }\r\n    };\r\n\r\n    this.openPage = function(pageRequest) {\r\n        this.resetCurrentPosition();\r\n        _currentPageRequest = pageRequest;\r\n        this.openPageInternal(pageRequest);\r\n    }\r\n\r\n    function openPageViewElement(pageView, pageRequest) {\r\n\r\n        var topOffset = 0;\r\n        var pageCount;\r\n        var $element;\r\n        var sfiNav;\r\n        var pageRange;\r\n\r\n        if (pageRequest.scrollTop !== undefined) {\r\n\r\n            topOffset = pageRequest.scrollTop;\r\n        }\r\n        else if (pageRequest.spineItemPageIndex !== undefined) {\r\n\r\n            var pageIndex;\r\n            pageCount = calculatePageCount();\r\n            if (pageRequest.spineItemPageIndex < 0) {\r\n                pageIndex = 0;\r\n            }\r\n            else if (pageRequest.spineItemPageIndex >= pageCount) {\r\n                pageIndex = pageCount - 1;\r\n            }\r\n            else {\r\n                pageIndex = pageRequest.spineItemPageIndex;\r\n            }\r\n\r\n            topOffset = pageIndex * viewHeight();\r\n        }\r\n        else if (pageView && pageRequest.elementId) {\r\n\r\n            pageRange = getPageViewRange(pageView);\r\n            sfiNav = pageView.getNavigator();\r\n            $element = sfiNav.getElementById(pageRequest.elementId);\r\n\r\n            if (!$element || !$element.length) {\r\n                console.warn(\"Element id=\" + pageRequest.elementId + \" not found!\");\r\n                return;\r\n            }\r\n\r\n            if (isElementVisibleOnScreen(pageView, $element, 60)) {\r\n                //TODO refactoring required\r\n                // this is artificial call because MO player waits for this event to continue playing.\r\n                onPaginationChanged(pageRequest.initiator, pageRequest.spineItem, pageRequest.elementId);\r\n                return;\r\n            }\r\n\r\n            var elementRange = getElementRange(pageView, $element);\r\n            topOffset = elementRange.top + pageRange.top;\r\n\r\n        }\r\n        else if (pageView && pageRequest.elementCfi) {\r\n\r\n            pageRange = getPageViewRange(pageView);\r\n            sfiNav = pageView.getNavigator();\r\n\r\n            var domRange = sfiNav.getDomRangeFromRangeCfi(pageRequest.elementCfi);            \r\n            if (!domRange) {\r\n                console.warn(\"Range for cfi=\" + pageRequest.elementCfi + \" not found!\");\r\n                return;\r\n            }\r\n            \r\n            var domRangeAsRange = getDomRangeAsRange(pageView, domRange);\r\n            if (isRangeIsVisibleOnScreen(pageView, domRangeAsRange, 60)) {\r\n                //TODO refactoring required\r\n                // this is artificial call because MO player waits for this event to continue playing.\r\n                onPaginationChanged(pageRequest.initiator, pageRequest.spineItem, pageRequest.elementId);\r\n                return;\r\n            }\r\n\r\n            topOffset = domRangeAsRange.top;\r\n\r\n        }\r\n        else if (pageRequest.firstPage) {\r\n\r\n            topOffset = 0;\r\n        }\r\n        else if (pageRequest.lastPage) {\r\n            pageCount = calculatePageCount();\r\n\r\n            if (pageCount === 0) {\r\n                return;\r\n            }\r\n\r\n            topOffset = scrollHeight() - viewHeight() - 5;\r\n        }\r\n        else if (pageView) {\r\n\r\n            pageRange = getPageViewRange(pageView);\r\n            topOffset = pageRange.top;\r\n        }\r\n        else {\r\n            topOffset = 0;\r\n        }\r\n\r\n        if (scrollTop() != topOffset) {\r\n\r\n            _isSettingScrollPosition = true;\r\n            scrollTo(topOffset, pageRequest);\r\n\r\n            setTimeout(function () {\r\n                _isSettingScrollPosition = false;\r\n            }, ON_SCROLL_TIME_DALAY + 100); //we have to wait more than scroll delay to make sure that we don't react on onScroll\r\n\r\n        }\r\n        else {\r\n            onPaginationChanged(pageRequest.initiator, pageRequest.spineItem, pageRequest.elementId);\r\n        }\r\n    }\r\n\r\n    function calculatePageCount() {\r\n\r\n        return Math.ceil(scrollHeight() / viewHeight());\r\n    }\r\n\r\n    function onPaginationChanged(initiator, paginationRequest_spineItem, paginationRequest_elementId) {\r\n        \r\n        Globals.logEvent(\"InternalEvents.CURRENT_VIEW_PAGINATION_CHANGED\", \"EMIT\", \"scroll_view.js\");\r\n        self.emit(Globals.InternalEvents.CURRENT_VIEW_PAGINATION_CHANGED, {\r\n            paginationInfo: self.getPaginationInfo(),\r\n            initiator: initiator,\r\n            spineItem: paginationRequest_spineItem,\r\n            elementId: paginationRequest_elementId\r\n        });\r\n    }\r\n\r\n    function scrollTop() {\r\n        return _$contentFrame[0].scrollTop;\r\n    }\r\n\r\n    function scrollBottom() {\r\n        return scrollHeight() - (scrollTop() + viewHeight());\r\n    }\r\n\r\n    function viewHeight() {\r\n        return _$contentFrame.height();\r\n    }\r\n\r\n    function scrollHeight() {\r\n        return _$contentFrame[0].scrollHeight;\r\n    }\r\n\r\n    this.openPageNext = function (initiator) {\r\n\r\n        var pageRequest;\r\n\r\n        if (scrollBottom() > 0) {\r\n\r\n            pageRequest = new PageOpenRequest(undefined, initiator);\r\n            pageRequest.scrollTop = scrollTop() + Math.min(scrollBottom(), viewHeight() - SCROLL_MARGIN_TO_SHOW_LAST_VISBLE_LINE);\r\n            openPageViewElement(undefined, pageRequest);\r\n        }\r\n\r\n    };\r\n\r\n    this.openPagePrev = function (initiator) {\r\n\r\n        var pageRequest;\r\n\r\n        if (scrollTop() > 0) {\r\n\r\n            pageRequest = new PageOpenRequest(undefined, initiator);\r\n            pageRequest.scrollTop = scrollTop() - (viewHeight() - SCROLL_MARGIN_TO_SHOW_LAST_VISBLE_LINE);\r\n            if (pageRequest.scrollTop < 0) {\r\n                pageRequest.scrollTop = 0;\r\n            }\r\n\r\n            openPageViewElement(undefined, pageRequest);\r\n        }\r\n    };\r\n\r\n    function getVisiblePageViews() {\r\n\r\n        var views = [];\r\n\r\n        var range = getVisibleRange(-SCROLL_MARGIN_TO_SHOW_LAST_VISBLE_LINE);\r\n\r\n        forEachItemView(function (pageView) {\r\n\r\n            if (isPageViewVisibleInRange(pageView, range)) {\r\n\r\n                views.push(pageView);\r\n            }\r\n            else if (views.length > 0) {\r\n\r\n                return false;\r\n            }\r\n\r\n            return true;\r\n\r\n        }, false);\r\n\r\n        return views;\r\n\r\n    }\r\n\r\n\r\n    function getFirstVisiblePageView() {\r\n\r\n        var visibleViews = getVisiblePageViews();\r\n\r\n        return visibleViews[0];\r\n    }\r\n\r\n    function isPageViewVisibleInRange(pageView, range) {\r\n        var pageViewRange = getPageViewRange(pageView);\r\n        return rangeLength(intersectRanges(pageViewRange, range)) > 0;\r\n    }\r\n\r\n    function getPageViewRange(pageView) {\r\n        var range = {top: 0, bottom: 0};\r\n\r\n        var el = pageView.element();\r\n        var pos = el.position();\r\n        \r\n        if (_jQueryPositionNeedsFix) {\r\n            var offsetParent = el.offsetParent();\r\n            pos.top -= offsetParent.scrollTop();\r\n            pos.left -= offsetParent.scrollLeft();\r\n        }\r\n\r\n        range.top = pos.top + scrollTop();\r\n        range.bottom = range.top + pageView.getCalculatedPageHeight();\r\n\r\n        return range;\r\n    }\r\n\r\n    this.getPaginationInfo = function () {\r\n        var spineItem;\r\n        var pageCount;\r\n        var pageView;\r\n        var pageViewRange;\r\n        var heightAboveViewport;\r\n        var heightBelowViewport;\r\n        var pageCountAbove;\r\n        var pageCountBelow;\r\n\r\n        var viewPortRange = getVisibleRange();\r\n        var viewPortHeight = viewPortRange.bottom - viewPortRange.top;\r\n\r\n        var paginationInfo = new CurrentPagesInfo(_spine, false);\r\n\r\n        var visibleViews = getVisiblePageViews();\r\n\r\n        for (var i = 0, count = visibleViews.length; i < count; i++) {\r\n\r\n            pageView = visibleViews[i];\r\n            spineItem = pageView.currentSpineItem();\r\n            pageViewRange = getPageViewRange(pageView);\r\n\r\n            heightAboveViewport = Math.max(viewPortRange.top - pageViewRange.top, 0);\r\n            heightBelowViewport = Math.max(pageViewRange.bottom - viewPortRange.bottom, 0);\r\n\r\n            pageCountAbove = Math.ceil(heightAboveViewport / viewPortHeight);\r\n            pageCountBelow = Math.ceil(heightBelowViewport / viewPortHeight);\r\n            pageCount = pageCountAbove + pageCountBelow + 1;\r\n\r\n            paginationInfo.addOpenPage(pageCountAbove, pageCount, spineItem.idref, spineItem.index);\r\n        }\r\n\r\n        return paginationInfo;\r\n    };\r\n\r\n    this.bookmarkCurrentPage = function () {\r\n        \r\n        return self.getFirstVisibleCfi();\r\n    };\r\n\r\n\r\n    this.getLoadedSpineItems = function () {\r\n        var spineItems = [];\r\n\r\n        forEachItemView(function (pageView) {\r\n            spineItems.push(pageView.currentSpineItem());\r\n        }, false);\r\n\r\n        return spineItems;\r\n    };\r\n\r\n    this.getElement = function (spineItemIdref, selector) {\r\n        var element = undefined;\r\n\r\n        forEachItemView(function (pageView) {\r\n            if(pageView.currentSpineItem().idref == spineItemIdref) {\r\n\r\n                element = pageView.getNavigator().getElement(selector);\r\n\r\n                return false;\r\n            }\r\n\r\n            return true;\r\n\r\n        }, false);\r\n\r\n        return element;\r\n    };\r\n\r\n    this.getElementById = function(spineItemIdref, id) {\r\n        var found = undefined;\r\n\r\n        forEachItemView(function (pageView) {\r\n            if (pageView.currentSpineItem().idref == spineItemIdref) {\r\n\r\n                found = pageView.getNavigator().getElementById(id);\r\n                return false;\r\n            }\r\n\r\n            return true;\r\n\r\n        }, false);\r\n\r\n        if (!found) {\r\n            console.error(\"spine item is not loaded\");\r\n            return undefined;\r\n        }\r\n\r\n        return found;\r\n    };\r\n\r\n    this.getElementByCfi = function (spineItemIdref, cfi, classBlacklist, elementBlacklist, idBlacklist) {\r\n        var found = undefined;\r\n\r\n        forEachItemView(function (pageView) {\r\n            if (pageView.currentSpineItem().idref == spineItemIdref) {\r\n\r\n                found = pageView.getNavigator().getElementByCfi(cfi, classBlacklist, elementBlacklist, idBlacklist);\r\n                return false;\r\n            }\r\n\r\n            return true;\r\n\r\n        }, false);\r\n\r\n        if (!found) {\r\n            console.error(\"spine item is not loaded\");\r\n            return undefined;\r\n        }\r\n\r\n        return found;\r\n\r\n    };\r\n\r\n    function callOnVisiblePageView(iterator) {\r\n        var viewPortRange = getVisibleRange();\r\n\r\n        var result = undefined;\r\n        var normalizedRange = {top: 0, bottom: 0};\r\n        var pageViewRange;\r\n\r\n        var steppedToVisiblePage = false;\r\n\r\n        forEachItemView(function (pageView) {\r\n            pageViewRange = getPageViewRange(pageView);\r\n\r\n            normalizedRange.top = Math.max(pageViewRange.top, viewPortRange.top) - pageViewRange.top;\r\n            normalizedRange.bottom = Math.min(pageViewRange.bottom, viewPortRange.bottom) - pageViewRange.top;\r\n\r\n            if (rangeLength(normalizedRange) > 0) {\r\n                steppedToVisiblePage = true;\r\n\r\n                result = iterator(pageView, normalizedRange);\r\n                if (result) {\r\n                    return false;\r\n                }\r\n            }\r\n            else if (steppedToVisiblePage) {\r\n                return false;\r\n            }\r\n\r\n            return true; //continue iteration\r\n\r\n        }, false);\r\n\r\n        return result;\r\n    }\r\n\r\n    this.getFirstVisibleMediaOverlayElement = function () {\r\n        return callOnVisiblePageView(function (pageView, pageRange) {\r\n            return pageView.getNavigator().getFirstVisibleMediaOverlayElement(pageRange);\r\n        });\r\n    };\r\n\r\n    // /**\r\n    //  * @deprecated\r\n    //  */\r\n    // this.getVisibleMediaOverlayElements = function() {\r\n    //     var viewPortRange = getVisibleRange();\r\n    //\r\n    //     var pageMoElements;\r\n    //     var moElements = [];\r\n    //     var normalizedRange = {top: 0, bottom: 0};\r\n    //     var pageViewRange;\r\n    //\r\n    //     forEachItemView(function(pageView){\r\n    //         pageViewRange = getPageViewRange(pageView);\r\n    //\r\n    //         normalizedRange.top = Math.max(pageViewRange.top, viewPortRange.top) - pageViewRange.top;\r\n    //         normalizedRange.bottom = Math.min(pageViewRange.bottom, viewPortRange.bottom) - pageViewRange.top;\r\n    //\r\n    //         if(rangeLength(normalizedRange) > 0) {\r\n    //             pageMoElements = pageView.getNavigator().getVisibleMediaOverlayElements(normalizedRange);\r\n    //             moElements.push.apply(moElements, pageMoElements);\r\n    //         }\r\n    //     }, false);\r\n    //\r\n    //     return moElements;\r\n    // };\r\n\r\n    function getVisibleRange(expand) {\r\n        if (expand !== 0 && !expand) {\r\n            expand = 0;\r\n        }\r\n\r\n        var range = {\r\n\r\n            top: scrollTop() - expand,\r\n            bottom: scrollTop() + viewHeight() + expand\r\n        };\r\n\r\n        if (range.top < 0) {\r\n            range.top = 0;\r\n        }\r\n\r\n        if (range.bottom > scrollHeight()) {\r\n            range.bottom = scrollHeight();\r\n        }\r\n\r\n        return range;\r\n\r\n    }\r\n\r\n    function intersectRanges(r1, r2) {\r\n        return {\r\n\r\n            top: Math.max(r1.top, r2.top),\r\n            bottom: Math.min(r1.bottom, r2.bottom)\r\n        };\r\n    }\r\n\r\n    function rangeLength(range) {\r\n        if (range.bottom < range.top) {\r\n            return 0;\r\n        }\r\n\r\n        return range.bottom - range.top;\r\n    }\r\n\r\n    function isElementVisibleOnScreen(pageView, $element, percentVisible) {\r\n\r\n        var elementRange = getElementRange(pageView, $element);\r\n\r\n        return isRangeIsVisibleOnScreen(elementRange, percentVisible);\r\n    }\r\n\r\n    function isRangeIsVisibleOnScreen(range, percentVisible) {\r\n\r\n        var visibleRange = getVisibleRange();\r\n\r\n        var smallestVisibleLength = Math.min(rangeLength(visibleRange), rangeLength(range));\r\n        if (smallestVisibleLength === 0) {\r\n            smallestVisibleLength = 5; // if element is 0 height we will set it to arbitrary 5 pixels - not to divide by 0\r\n        }\r\n\r\n        var intersectionRange = intersectRanges(visibleRange, range);\r\n\r\n        var visiblePercent = (rangeLength(intersectionRange) / smallestVisibleLength) * 100;\r\n\r\n        return visiblePercent >= percentVisible;\r\n    }\r\n\r\n    function getElementRange(pageView, $element) {\r\n\r\n        var pageRange = getPageViewRange(pageView);\r\n\r\n        var elementRange = {top: 0, bottom: 0};\r\n        elementRange.top = $element.offset().top + pageRange.top;\r\n        elementRange.bottom = elementRange.top + $element.height();\r\n\r\n        return elementRange;\r\n    }\r\n    \r\n    function getDomRangeAsRange(pageView, domRange) {\r\n\r\n        var pageRange = getPageViewRange(pageView);\r\n\r\n        var elementRange = {top: 0, bottom: 0};\r\n        var boundingClientRect = domRange.getBoundingClientRect();\r\n        elementRange.top = boundingClientRect.top + pageRange.top;\r\n        elementRange.bottom = elementRange.top + boundingClientRect.height;\r\n\r\n        return elementRange;\r\n    }\r\n\r\n    this.insureElementVisibility = function (spineItemId, element, initiator) {\r\n        var pageView = undefined;\r\n\r\n        forEachItemView(function (pv) {\r\n            if (pv.currentSpineItem().idref === spineItemId) {\r\n\r\n                pageView = pv;\r\n                return false;\r\n            }\r\n\r\n            return true;\r\n        }, false);\r\n\r\n        if (!pageView) {\r\n            console.warn(\"Page for element \" + element + \" not found\");\r\n            return;\r\n        }\r\n\r\n        var $element = $(element);\r\n\r\n        var elementRange = getElementRange(pageView, $element);\r\n\r\n        if (!isRangeIsVisibleOnScreen(elementRange, 60)) {\r\n\r\n            var spineItem = _spine.getItemById(spineItemId);\r\n            var openPageRequest = new PageOpenRequest(spineItem, initiator);\r\n            openPageRequest.scrollTop = elementRange.top;\r\n\r\n            self.openPage(openPageRequest);\r\n        }\r\n\r\n    };\r\n\r\n    this.getVisibleElements = function(selector, includeSpineItem) {\r\n        var elements = [];\r\n        forEachItemView(function (pageView) {\r\n            if (includeSpineItem) {\r\n                elements.push({elements: pageView.getVisibleElements(selector), spineItem: pageView.currentSpineItem()});\r\n            } else {\r\n                elements = _.flatten([elements, pageView.getVisibleElements(selector)], true);\r\n            }\r\n        });\r\n        return elements;\r\n    };\r\n\r\n    this.getVisibleElementsWithFilter = function(filterFunction) {\r\n\r\n        console.warn('getVisibleElementsWithFilter: Not implemented yet for scroll_view');\r\n    };\r\n\r\n    this.isElementVisible = function($element){\r\n\r\n        console.warn('isElementVisible: Not implemented yet for scroll_view');\r\n    };\r\n\r\n    this.getElements = function(spineItemIdref, selector) {\r\n        var pageView = findPageViewForSpineItem(spineItemIdref);\r\n        if (pageView) {\r\n            return pageView.getElements(spineItemIdref, selector);\r\n        }\r\n    };\r\n\r\n    this.isNodeFromRangeCfiVisible = function (spineIdref, partialCfi) {\r\n        var pageView = findPageViewForSpineItem(spineIdRef);\r\n        if (pageView) {\r\n            return pageView.isNodeFromRangeCfiVisible(spineIdRef, partialCfi);\r\n        }\r\n    };\r\n\r\n    this.isVisibleSpineItemElementCfi = function (spineIdRef, partialCfi) {\r\n        var pageView = findPageViewForSpineItem(spineIdRef);\r\n        if (pageView) {\r\n            return pageView.isVisibleSpineItemElementCfi(spineIdRef, partialCfi);\r\n        }\r\n    };\r\n\r\n    this.getNodeRangeInfoFromCfi = function(spineIdRef, partialCfi){\r\n        var pageView = findPageViewForSpineItem(spineIdRef);\r\n        if (pageView) {\r\n            return pageView.isVisibleSpineItemElementCfi(spineIdRef, partialCfi);\r\n        }\r\n    };\r\n    \r\n    function getFirstOrLastVisibleCfi(pickerFunc) {\r\n        var pageViews = getVisiblePageViews();\r\n        var selectedPageView = pickerFunc(pageViews);\r\n        var pageViewTopOffset = selectedPageView.element().position().top;\r\n        var visibleContentOffsets, frameDimensions;\r\n        \r\n        var setupFunctions = [\r\n            function () {\r\n                visibleContentOffsets = {\r\n                    top: pageViewTopOffset,\r\n                    left: 0\r\n                };\r\n            },\r\n            function() {\r\n                var height = selectedPageView.element().height();\r\n                \r\n                if (pageViewTopOffset >= 0) {\r\n                    height = viewHeight() - pageViewTopOffset;\r\n                }\r\n\r\n                frameDimensions = {\r\n                    width: selectedPageView.element().width(),\r\n                    height: height\r\n                };\r\n                \r\n                visibleContentOffsets = {\r\n                    top: 0,\r\n                    left: 0\r\n                };\r\n            }\r\n        ];\r\n        \r\n        //invoke setup function\r\n        pickerFunc(setupFunctions)();\r\n        \r\n        var cfiFunctions = [\r\n            selectedPageView.getFirstVisibleCfi,\r\n            selectedPageView.getLastVisibleCfi\r\n        ];\r\n        \r\n        return pickerFunc(cfiFunctions)(visibleContentOffsets, frameDimensions);\r\n    }\r\n    \r\n    this.getFirstVisibleCfi = function () {\r\n        \r\n        return getFirstOrLastVisibleCfi(_.first);\r\n    };\r\n\r\n    this.getLastVisibleCfi = function () {\r\n        \r\n        return getFirstOrLastVisibleCfi(_.last);\r\n    };\r\n\r\n    this.getDomRangeFromRangeCfi = function (rangeCfi, rangeCfi2, inclusive) {\r\n        if (rangeCfi2 && rangeCfi.idref !== rangeCfi2.idref) {\r\n            console.error(\"getDomRangeFromRangeCfi: both CFIs must be scoped under the same spineitem idref\");\r\n            return undefined;\r\n        }\r\n\r\n        rangeCfi = rangeCfi || {};\r\n        rangeCfi2 = rangeCfi2 || {};\r\n\r\n        return callOnVisiblePageView(function (pageView) {\r\n            if (pageView.currentSpineItem().idref === rangeCfi.idref) {\r\n                return pageView.getDomRangeFromRangeCfi(rangeCfi.contentCFI, rangeCfi2.contentCFI, inclusive);\r\n            }\r\n        });\r\n    };\r\n\r\n    this.getRangeCfiFromDomRange = function (domRange) {\r\n        return callOnVisiblePageView(function (pageView) {\r\n            return pageView.getRangeCfiFromDomRange(domRange);\r\n        });\r\n    };\r\n\r\n    this.getVisibleCfiFromPoint = function (x, y, precisePoint) {\r\n        return callOnVisiblePageView(function (pageView) {\r\n            return createBookmark(pageView.currentSpineItem(), pageView.getVisibleCfiFromPoint(x, y, precisePoint));\r\n        });\r\n    };\r\n\r\n    this.getRangeCfiFromPoints = function (startX, startY, endX, endY) {\r\n        return callOnVisiblePageView(function (pageView) {\r\n            return createBookmark(pageView.currentSpineItem(), pageView.getRangeCfiFromPoints(startX, startY, endX, endY));\r\n        });\r\n    };\r\n\r\n    this.getCfiForElement = function(element) {\r\n        return callOnVisiblePageView(function (pageView) {\r\n            return createBookmark(pageView.currentSpineItem(), pageView.getCfiForElement(element));\r\n        });\r\n    };\r\n\r\n    this.getElementFromPoint = function (x, y) {\r\n        return callOnVisiblePageView(function (pageView) {\r\n            return pageView.getElementFromPoint(x, y);\r\n        });\r\n    };\r\n};\r\n\r\nreturn ScrollView;\r\n});\r\n\n",
    "//  LauncherOSX\r\n//\r\n//  Created by Boris Schneiderman.\r\n// Modified by Daniel Weck\r\n//  Copyright (c) 2014 Readium Foundation and/or its licensees. All rights reserved.\r\n//  \r\n//  Redistribution and use in source and binary forms, with or without modification, \r\n//  are permitted provided that the following conditions are met:\r\n//  1. Redistributions of source code must retain the above copyright notice, this \r\n//  list of conditions and the following disclaimer.\r\n//  2. Redistributions in binary form must reproduce the above copyright notice, \r\n//  this list of conditions and the following disclaimer in the documentation and/or \r\n//  other materials provided with the distribution.\r\n//  3. Neither the name of the organization nor the names of its contributors may be \r\n//  used to endorse or promote products derived from this software without specific \r\n//  prior written permission.\r\n//  \r\n//  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND \r\n//  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED \r\n//  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. \r\n//  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, \r\n//  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, \r\n//  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, \r\n//  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF \r\n//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE \r\n//  OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED \r\n//  OF THE POSSIBILITY OF SUCH DAMAGE.\r\n\r\ndefine('readium_shared_js/views/media_overlay_player',[\"../globals\", \"jquery\", \"../helpers\", \"./audio_player\", \"./media_overlay_element_highlighter\", \"../models/smil_iterator\", \"rangy\", 'readium_cfi_js', './scroll_view'],\r\n    function(Globals, $, Helpers, AudioPlayer, MediaOverlayElementHighlighter, SmilIterator, rangy, epubCfi, ScrollView) {\r\n/**\r\n *\r\n * @param reader\r\n * @param onStatusChanged\r\n * @constructor\r\n */\r\nvar MediaOverlayPlayer = function(reader, onStatusChanged) {\r\n\r\n\r\n    var _smilIterator = undefined;\r\n\r\n    var _audioPlayer = new AudioPlayer(onStatusChanged, onAudioPositionChanged, onAudioEnded, onPlay, onPause);\r\n\r\n    var _ttsIsPlaying = false;\r\n    var _currentTTS = undefined;\r\n    var _enableHTMLSpeech = true && typeof window.speechSynthesis !== \"undefined\" && speechSynthesis != null; // set to false to force \"native\" platform TTS engine, rather than HTML Speech API\r\n    \r\n    var _SpeechSynthesisUtterance = undefined;\r\n    //var _skipTTSEndEvent = false;\r\n    var TOKENIZE_TTS = false;\r\n\r\n    var _embeddedIsPlaying = false;\r\n    var _currentEmbedded = undefined;\r\n\r\n\r\n    this.isPlaying = function()\r\n    {\r\n        return _audioPlayer.isPlaying() || _ttsIsPlaying || _embeddedIsPlaying || _blankPagePlayer;\r\n    }\r\n\r\n    //var _currentPagination = undefined;\r\n    var _package = reader.package();\r\n    var _settings = reader.viewerSettings();\r\n    var self = this;\r\n    var _elementHighlighter = new MediaOverlayElementHighlighter(reader);\r\n\r\n    reader.on(Globals.Events.READER_VIEW_DESTROYED, function(){\r\n        Globals.logEvent(\"READER_VIEW_DESTROYED\", \"ON\", \"media_overlay_player.js\");\r\n        \r\n        self.reset();\r\n    });\r\n\r\n\r\n    this.applyStyles = function()\r\n    {\r\n        _elementHighlighter.reDo();\r\n    };\r\n\r\n//\r\n// should use this.onSettingsApplied() instead!\r\n//    this.setRate = function(rate) {\r\n//        _audioPlayer.setRate(rate);\r\n//    };\r\n//    this.setVolume = function(volume) {\r\n//        _audioPlayer.setVolume(volume);\r\n//    };\r\n\r\n\r\n    this.onSettingsApplied = function() {\r\n//console.debug(_settings);\r\n        _audioPlayer.setRate(_settings.mediaOverlaysRate);\r\n        _audioPlayer.setVolume(_settings.mediaOverlaysVolume / 100.0);\r\n    };\r\n    self.onSettingsApplied();\r\n    \r\n    reader.on(Globals.Events.SETTINGS_APPLIED, function() {\r\n        \r\n        Globals.logEvent(\"SETTINGS_APPLIED\", \"ON\", \"media_overlay_player.js\");\r\n        this.onSettingsApplied();\r\n    }, this);\r\n\r\n    /*\r\n    var lastElement = undefined;\r\n    var lastElementColor = \"\";\r\n    */\r\n\r\n    var _wasPlayingAtDocLoadStart = false;\r\n    this.onDocLoadStart = function() {\r\n        // 1) Globals.Events.CONTENT_DOCUMENT_LOAD_START\r\n        // (maybe 2-page fixed-layout or reflowable spread == 2 documents == 2x events)\r\n        // MOPLayer.onDocLoad()\r\n        \r\n        // 2) Globals.Events.CONTENT_DOCUMENT_LOADED\r\n        // (maybe 2-page fixed-layout or reflowable spread == 2 documents == 2x events)\r\n        //_mediaOverlayDataInjector.attachMediaOverlayData($iframe, spineItem, _viewerSettings);\r\n        \r\n        // 3) Globals.Events.PAGINATION_CHANGED (layout finished, notified before rest of app, just once)\r\n        // MOPLayer.onPageChanged()\r\n\r\n        var wasPlaying = self.isPlaying();\r\n        if (wasPlaying)\r\n        {\r\n            _wasPlayingAtDocLoadStart = true;\r\n            self.pause();\r\n        }\r\n    };\r\n    \r\n    var _lastPaginationData = undefined;\r\n    \r\n    this.onPageChanged = function(paginationData) {\r\n        \r\n        _lastPaginationData = paginationData;\r\n        \r\n        var wasPausedBecauseNoAutoNextSmil = _wasPausedBecauseNoAutoNextSmil;\r\n        _wasPausedBecauseNoAutoNextSmil = false;\r\n        \r\n        var wasPlayingAtDocLoadStart = _wasPlayingAtDocLoadStart;\r\n        _wasPlayingAtDocLoadStart = false;\r\n\r\n        if(!paginationData) {\r\n            self.reset();\r\n            return;\r\n        }\r\n\r\n//        if (paginationData.paginationInfo)\r\n//        {\r\n//            _currentPagination = paginationData.paginationInfo;\r\n//        }\r\n\r\n        /*\r\n        if (lastElement)\r\n        {\r\n            $(lastElement).css(\"background-color\", lastElementColor);\r\n            lastElement = undefined;\r\n        }\r\n        */\r\n\r\n        var element = undefined;\r\n        var isCfiTextRange = false;\r\n        \r\n        var fakeOpfRoot = \"/99!\";\r\n        var epubCfiPrefix = \"epubcfi\";\r\n        \r\n        if (paginationData.elementId || paginationData.initiator == self)\r\n        {\r\n            var spineItems = reader.getLoadedSpineItems();\r\n\r\n            var rtl = reader.spine().isRightToLeft();\r\n\r\n            for(var i = (rtl ? (spineItems.length - 1) : 0); rtl && i >=0 || !rtl && i < spineItems.length; i += (rtl ? -1: 1))\r\n            {\r\n                var spineItem = spineItems[i];\r\n                if (paginationData.spineItem && paginationData.spineItem != spineItem)\r\n                {\r\n                    continue;\r\n                }\r\n                \r\n                if (paginationData.elementId && paginationData.elementId.indexOf(epubCfiPrefix) === 0)\r\n                {\r\n                    _elementHighlighter.reset(); // ensure clean DOM (no CFI span markers)\r\n                    \r\n                    var partial = paginationData.elementId.substr(epubCfiPrefix.length + 1, paginationData.elementId.length - epubCfiPrefix.length - 2);\r\n                    \r\n                    if (partial.indexOf(fakeOpfRoot) === 0)\r\n                    {\r\n                        partial = partial.substr(fakeOpfRoot.length, partial.length - fakeOpfRoot.length);\r\n                    }\r\n//console.log(partial);\r\n                    var parts = partial.split(\",\");\r\n                    if (parts && parts.length === 3)\r\n                    {\r\n                        try\r\n                        {\r\n                            var cfi = parts[0] + parts[1];\r\n                            var $element = reader.getElementByCfi(spineItem.idref, cfi,\r\n                [\"cfi-marker\", \"mo-cfi-highlight\"],\r\n                [],\r\n                [\"MathJax_Message\"]);\r\n\r\n                            element = ($element && $element.length > 0) ? $element[0] : undefined;\r\n                            if (element)\r\n                            {\r\n                                if (element.nodeType === Node.TEXT_NODE)\r\n                                {\r\n                                    element = element.parentNode;\r\n                                }\r\n                                break;\r\n                            }\r\n                        }\r\n                        catch (error)\r\n                        {\r\n                            console.error(error);\r\n                        }\r\n                    }\r\n                    else\r\n                    {\r\n                        try\r\n                        {\r\n                            //var cfi = \"epubcfi(\" + partial + \")\";\r\n                            //var $element = EPUBcfi.getTargetElementWithPartialCFI(cfi, DOC);\r\n                            var $element = reader.getElementByCfi(spineItem.idref, partial,\r\n                [\"cfi-marker\", \"mo-cfi-highlight\"],\r\n                [],\r\n                [\"MathJax_Message\"]);\r\n                                \r\n                            element = ($element && $element.length > 0) ? $element[0] : undefined;\r\n                            if (element)\r\n                            {\r\n                                if (element.nodeType === Node.TEXT_NODE)\r\n                                {\r\n                                    element = element.parentNode;\r\n                                }\r\n                                break;\r\n                            }\r\n                        }\r\n                        catch (error)\r\n                        {\r\n                            console.error(error);\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (!element)\r\n                {\r\n                    if (paginationData.initiator == self && !paginationData.elementId)\r\n                    {\r\n                        var $element = reader.getElement(spineItem.idref, \"body\");\r\n                        element = ($element && $element.length > 0) ? $element[0] : undefined;\r\n                    }\r\n                    else\r\n                    {\r\n                        var $element = reader.getElementById(spineItem.idref, paginationData.elementId);\r\n                        element = ($element && $element.length > 0) ? $element[0] : undefined;\r\n                        //(\"#\" + Globals.Helpers.escapeJQuerySelector(paginationData.elementId))\r\n                    }\r\n                    \r\n                    if (element)\r\n                    {\r\n                        /*\r\n                        console.error(\"GREEN: \" + paginationData.elementId);\r\n                        lastElement = element;\r\n                        lastElementColor = $(element).css(\"background-color\");\r\n                        $(element).css(\"background-color\", \"green\");\r\n                         */\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (!element)\r\n            {\r\n                console.error(\"paginationData.elementId BUT !element: \" + paginationData.elementId);\r\n            }\r\n        }\r\n\r\n        var wasPlaying = self.isPlaying() || wasPlayingAtDocLoadStart;\r\n\r\n        if(!_smilIterator || !_smilIterator.currentPar) {\r\n            if(paginationData.initiator !== self) {\r\n                clipBeginOffset = 0.0;\r\n                self.reset();\r\n\r\n                if (paginationData.elementId && element)\r\n                {\r\n                    if (wasPlaying || wasPausedBecauseNoAutoNextSmil)\r\n                    {\r\n                        paginationData.elementIdResolved = element;\r\n                        self.toggleMediaOverlayRefresh(paginationData);\r\n                    }\r\n                }\r\n                else if (wasPlaying || wasPausedBecauseNoAutoNextSmil)\r\n                {\r\n                    self.toggleMediaOverlay();\r\n                }\r\n                return;\r\n            }\r\n\r\n            //paginationData.initiator === self\r\n//\r\n//            if (!paginationData.elementId)\r\n//            {\r\n//                console.error(\"!paginationData.elementId\");\r\n//                clipBeginOffset = 0.0;\r\n//                return;\r\n//            }\r\n\r\n            if(!element)\r\n            {\r\n                console.error(\"!element: \" + paginationData.elementId);\r\n                clipBeginOffset = 0.0;\r\n                return;\r\n            }\r\n\r\n            var moData = $(element).data(\"mediaOverlayData\");\r\n            if(!moData) {\r\n                console.error(\"!moData: \" + paginationData.elementId);\r\n                clipBeginOffset = 0.0;\r\n                return;\r\n            }\r\n\r\n            var parToPlay = moData.par ? moData.par : moData.pars[0];\r\n\r\n            if (moData.pars)\r\n            {\r\n                for (var iPar = 0; iPar < moData.pars.length; iPar++)\r\n                {\r\n                    var p = moData.pars[iPar];\r\n                    \r\n                    if (paginationData.elementId === p.cfi.smilTextSrcCfi)\r\n                    {\r\n                        parToPlay = p;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            \r\n            playPar(parToPlay);\r\n            return;\r\n        }\r\n\r\n        var noReverseData = !_smilIterator.currentPar.element && !_smilIterator.currentPar.cfi;\r\n        if(noReverseData) {\r\n            console.error(\"!! _smilIterator.currentPar.element ??\");\r\n        }\r\n\r\n//console.debug(\"+++> paginationData.elementId: \" + paginationData.elementId + \" /// \" + _smilIterator.currentPar.text.srcFile + \" # \" + _smilIterator.currentPar.text.srcFragmentId); //PageOpenRequest.elementId\r\n\r\n\r\n        if(paginationData.initiator == self)\r\n        {\r\n            var notSameTargetID = paginationData.elementId && paginationData.elementId !== _smilIterator.currentPar.text.srcFragmentId;\r\n\r\n            if(notSameTargetID) {\r\n                console.error(\"!! paginationData.elementId !== _smilIterator.currentPar.text.srcFragmentId\");\r\n            }\r\n\r\n            if(notSameTargetID || noReverseData) {\r\n                clipBeginOffset = 0.0;\r\n                return;\r\n            }\r\n\r\n            if(wasPlaying)\r\n            {\r\n                highlightCurrentElement();\r\n            }\r\n            else\r\n            {\r\n                playCurrentPar();\r\n            }\r\n        }\r\n        else\r\n        {\r\n            if(!wasPlaying && !wasPausedBecauseNoAutoNextSmil)\r\n            {\r\n                self.reset();\r\n                return;\r\n            }\r\n\r\n            if(!paginationData.elementId)\r\n            {\r\n                //self.reset();\r\n            }\r\n\r\n            if(paginationData.elementId && !element)\r\n            {\r\n                //self.reset();\r\n                return;\r\n            }\r\n\r\n            if(paginationData.elementId)\r\n            {\r\n                paginationData.elementIdResolved = element;\r\n            }\r\n            \r\n            self.toggleMediaOverlayRefresh(paginationData);\r\n        }\r\n    };\r\n\r\n    function playPar(par) {\r\n\r\n        var parSmil = par.getSmil();\r\n        if(!_smilIterator || _smilIterator.smil != parSmil)\r\n        {\r\n            _smilIterator = new SmilIterator(parSmil);\r\n        }\r\n        else {\r\n            _smilIterator.reset();\r\n        }\r\n\r\n        _smilIterator.goToPar(par);\r\n\r\n        if(!_smilIterator.currentPar) {\r\n            console.error(\"playPar !_smilIterator.currentPar\");\r\n            return;\r\n        }\r\n\r\n        playCurrentPar();\r\n    }\r\n\r\n    var clipBeginOffset = 0.0;\r\n\r\n    var _blankPagePlayer = undefined;\r\n\r\n    function initBlankPagePlayer()\r\n    {\r\n        self.resetBlankPage();\r\n\r\n        _blankPagePlayer = setTimeout(function() {\r\n\r\n            if (!_blankPagePlayer)\r\n            {\r\n                return;\r\n            }\r\n\r\n            self.resetBlankPage();\r\n\r\n            if (!_smilIterator || !_smilIterator.currentPar)\r\n            {\r\n                self.reset();\r\n                return;\r\n            }\r\n\r\n            audioCurrentTime = 0.0;\r\n//console.log(\"BLANK END.\");\r\n            //nextSmil(true);\r\n            onAudioPositionChanged(_smilIterator.currentPar.audio.clipEnd + 0.1, 2);\r\n\r\n        }, 2000);\r\n\r\n        onStatusChanged({isPlaying: true});\r\n    }\r\n\r\n    function playCurrentPar() {\r\n        _wasPlayingScrolling = false;\r\n        \r\n        if (!_smilIterator || !_smilIterator.currentPar)\r\n        {\r\n            console.error(\"playCurrentPar !_smilIterator || !_smilIterator.currentPar ???\");\r\n            return;\r\n        }\r\n\r\n        if (!_smilIterator.smil.id)\r\n        {\r\n            _audioPlayer.reset();\r\n\r\n            self.resetTTS();\r\n            self.resetEmbedded();\r\n\r\n            setTimeout(function()\r\n            {\r\n                initBlankPagePlayer();\r\n            }, 100);\r\n\r\n            return;\r\n        }\r\n        else if (!_smilIterator.currentPar.audio.src)\r\n        {\r\n            clipBeginOffset = 0.0;\r\n\r\n//            if (_currentTTS)\r\n//            {\r\n//                _skipTTSEnded = true;\r\n//            }\r\n\r\n            _audioPlayer.reset();\r\n\r\n            var element = _smilIterator.currentPar.element;\r\n            if (element)\r\n            {\r\n                audioCurrentTime = 0.0;\r\n\r\n                var name = element.nodeName ? element.nodeName.toLowerCase() : undefined;\r\n\r\n                if (name === \"audio\" || name === \"video\")\r\n                {\r\n                    self.resetTTS();\r\n                    self.resetBlankPage();\r\n\r\n                    if (_currentEmbedded)\r\n                    {\r\n                        self.resetEmbedded();\r\n                    }\r\n\r\n                    _currentEmbedded = element;\r\n\r\n                    _currentEmbedded.pause();\r\n\r\n                    // DONE at reader_view.attachMO()\r\n                    //$(_currentEmbedded).attr(\"preload\", \"auto\");\r\n\r\n                    _currentEmbedded.currentTime = 0;\r\n\r\n                    _currentEmbedded.play();\r\n\r\n                    $(_currentEmbedded).on(\"ended\", self.onEmbeddedEnd);\r\n\r\n                    _embeddedIsPlaying = true;\r\n                    \r\n                    // gives the audio player some dispatcher time to raise the onPause event\r\n                    setTimeout(function(){\r\n                        onStatusChanged({isPlaying: true});\r\n                    }, 80);\r\n\r\n//                    $(element).on(\"seeked\", function()\r\n//                    {\r\n//                        $(element).off(\"seeked\", onSeeked);\r\n//                    });\r\n                }\r\n                else\r\n                {\r\n                    self.resetEmbedded();\r\n                    self.resetBlankPage();\r\n\r\n                    _currentTTS = element.textContent; //.innerText (CSS display sensitive + script + style tags)\r\n                    if (!_currentTTS || _currentTTS == \"\")\r\n                    {\r\n                        _currentTTS = undefined;\r\n                    }\r\n                    else\r\n                    {\r\n                        speakStart(_currentTTS);\r\n                    }\r\n                }\r\n            }\r\n            \r\n            var cfi = _smilIterator.currentPar.cfi;\r\n            if (cfi)\r\n            {\r\n                audioCurrentTime = 0.0;\r\n                self.resetEmbedded();\r\n                self.resetBlankPage();\r\n\r\n                _elementHighlighter.reset(); // ensure clean DOM (no CFI span markers)\r\n                \r\n                var doc = cfi.cfiTextParent.ownerDocument;\r\n\r\n                var startCFI = \"epubcfi(\" + cfi.partialStartCfi + \")\";\r\n                var infoStart = EPUBcfi.getTextTerminusInfoWithPartialCFI(startCFI, doc,\r\n                [\"cfi-marker\", \"mo-cfi-highlight\"],\r\n                [],\r\n                [\"MathJax_Message\"]);\r\n//console.log(infoStart);\r\n\r\n                var endCFI = \"epubcfi(\" + cfi.partialEndCfi + \")\";\r\n                var infoEnd = EPUBcfi.getTextTerminusInfoWithPartialCFI(endCFI, doc,\r\n                [\"cfi-marker\", \"mo-cfi-highlight\"],\r\n                [],\r\n                [\"MathJax_Message\"]);\r\n//console.log(infoEnd);\r\n\r\n                if (rangy)\r\n                {\r\n                    //infoStart.textNode.parentNode.ownerDocument\r\n                    var range = rangy.createRange(doc); //createNativeRange\r\n                    range.setStartAndEnd(\r\n                        infoStart.textNode, infoStart.textOffset,\r\n                        infoEnd.textNode, infoEnd.textOffset\r\n                    );\r\n                    _currentTTS = range.toString(); //.text()\r\n                }\r\n                else\r\n                {\r\n                    _currentTTS = undefined;\r\n                }\r\n\r\n                if (!_currentTTS || _currentTTS == \"\")\r\n                {\r\n                    _currentTTS = undefined;\r\n                }\r\n                else\r\n                {\r\n                    speakStart(_currentTTS);\r\n                }\r\n            }\r\n        }\r\n        else\r\n        {\r\n            self.resetTTS();\r\n            self.resetEmbedded();\r\n            self.resetBlankPage();\r\n\r\n            var dur = _smilIterator.currentPar.audio.clipEnd - _smilIterator.currentPar.audio.clipBegin;\r\n            if (dur <= 0 || clipBeginOffset > dur)\r\n            {\r\n                console.error(\"### MO XXX PAR OFFSET: \" + clipBeginOffset + \" / \" + dur);\r\n                clipBeginOffset = 0.0;\r\n            }\r\n            else\r\n            {\r\n//console.debug(\"### MO PAR OFFSET: \" + clipBeginOffset);\r\n            }\r\n\r\n            var audioContentRef = Helpers.ResolveContentRef(_smilIterator.currentPar.audio.src, _smilIterator.smil.href);\r\n\r\n            var audioSource = _package.resolveRelativeUrlMO(audioContentRef);\r\n\r\n            var startTime = _smilIterator.currentPar.audio.clipBegin + clipBeginOffset;\r\n\r\n//console.debug(\"PLAY START TIME: \" + startTime + \"(\"+_smilIterator.currentPar.audio.clipBegin+\" + \"+clipBeginOffset+\")\");\r\n\r\n            _audioPlayer.playFile(_smilIterator.currentPar.audio.src, audioSource, startTime); //_smilIterator.currentPar.element ? _smilIterator.currentPar.element : _smilIterator.currentPar.cfi.cfiTextParent\r\n        }\r\n\r\n        clipBeginOffset = 0.0;\r\n\r\n        highlightCurrentElement();\r\n    }\r\n\r\n    function nextSmil(goNext)\r\n    {\r\n        self.pause();\r\n\r\n//console.debug(\"current Smil: \" + _smilIterator.smil.href + \" /// \" + _smilIterator.smil.id);\r\n\r\n        var nextSmil = goNext ? _package.media_overlay.getNextSmil(_smilIterator.smil) : _package.media_overlay.getPreviousSmil(_smilIterator.smil);\r\n        if(nextSmil) {\r\n\r\n//console.debug(\"nextSmil: \" + nextSmil.href + \" /// \" + nextSmil.id);\r\n\r\n            _smilIterator = new SmilIterator(nextSmil);\r\n            if(_smilIterator.currentPar) {\r\n                if (!goNext)\r\n                {\r\n                    while (!_smilIterator.isLast())\r\n                    {\r\n                        _smilIterator.next();\r\n                    }\r\n                }\r\n\r\n//console.debug(\"openContentUrl (nextSmil): \" + _smilIterator.currentPar.text.src + \" -- \" + _smilIterator.smil.href);\r\n\r\n                reader.openContentUrl(_smilIterator.currentPar.text.src, _smilIterator.smil.href, self);\r\n            }\r\n        }\r\n        else\r\n        {\r\n            console.log(\"No more SMIL\");\r\n            self.reset();\r\n        }\r\n    }\r\n\r\n\r\n    var _skipAudioEnded = false;\r\n//    var _skipTTSEnded = false;\r\n\r\n    var audioCurrentTime = 0.0;\r\n\r\n    var DIRECTION_MARK = -999;\r\n\r\n//    var _letPlay = false;\r\n\r\n//from\r\n//1 = audio player\r\n//2 = blank page\r\n//3 = video/audio embbeded\r\n//4 = TTS\r\n//5 = audio end\r\n//6 = user previous/next/escape\r\n    function onAudioPositionChanged(position, from, skipping) { //noLetPlay\r\n\r\n        audioCurrentTime = position;\r\n\r\n//        if (_letPlay)\r\n//        {\r\n//            return;\r\n//        }\r\n\r\n        _skipAudioEnded = false;\r\n//        _skipTTSEnded = false;\r\n\r\n        if (!_smilIterator || !_smilIterator.currentPar)\r\n        {\r\n            return;\r\n        }\r\n\r\n        var parFrom = _smilIterator.currentPar;\r\n        \r\n        var audio = _smilIterator.currentPar.audio;\r\n\r\n        //var TOLERANCE = 0.05;\r\n        if(\r\n            //position >= (audio.clipBegin - TOLERANCE) &&\r\n        position > DIRECTION_MARK &&\r\n            position <= audio.clipEnd) {\r\n\r\n//console.debug(\"onAudioPositionChanged: \" + position);\r\n            return;\r\n        }\r\n\r\n        _skipAudioEnded = true;\r\n\r\n//console.debug(\"PLAY NEXT: \" + \"(\" + audio.clipBegin + \" -- \" + audio.clipEnd + \") [\" + from + \"] \" +  position);\r\n//console.debug(_smilIterator.currentPar.text.srcFragmentId);\r\n\r\n        var isPlaying = _audioPlayer.isPlaying();\r\n        if (isPlaying && from === 6)\r\n        {\r\n            console.debug(\"from userNav _audioPlayer.isPlaying() ???\");\r\n        }\r\n\r\n        var goNext = position > audio.clipEnd;\r\n\r\n        var doNotNextSmil = !_autoNextSmil && from !== 6 && goNext;\r\n\r\n        var spineItemIdRef = (_smilIterator && _smilIterator.smil && _smilIterator.smil.spineItemId) ? _smilIterator.smil.spineItemId : ((_lastPaginationData && _lastPaginationData.spineItem && _lastPaginationData.spineItem.idref) ? _lastPaginationData.spineItem.idref : undefined);\r\n        if (doNotNextSmil && spineItemIdRef && _lastPaginationData && _lastPaginationData.paginationInfo && _lastPaginationData.paginationInfo.openPages && _lastPaginationData.paginationInfo.openPages.length > 1)\r\n        {\r\n            //var iPage = _lastPaginationData.paginationInfo.isRightToLeft ? _lastPaginationData.paginationInfo.openPages.length - 1 : 0;\r\n            var iPage = 0;\r\n            \r\n            var openPage = _lastPaginationData.paginationInfo.openPages[iPage];\r\n            if (spineItemIdRef === openPage.idref)\r\n            {\r\n                doNotNextSmil = false;\r\n            }\r\n        }\r\n        \r\n        if (goNext)\r\n        {\r\n            _smilIterator.next();\r\n        }\r\n        else //position <= DIRECTION_MARK\r\n        {\r\n            _smilIterator.previous();\r\n        }\r\n\r\n        if(!_smilIterator.currentPar)\r\n        {\r\n            //\r\n            //        if (!noLetPlay)\r\n            //        {\r\n            //            _letPlay = true;\r\n            //            setTimeout(function()\r\n            //            {\r\n            //                _letPlay = false;\r\n            //                nextSmil(goNext);\r\n            //            }, 200);\r\n            //        }\r\n            //        else\r\n            //        {\r\n            //            nextSmil(goNext);\r\n            //        }\r\n\r\n//console.debug(\"NEXT SMIL ON AUDIO POS\");\r\n        \r\n            if (doNotNextSmil)\r\n            {\r\n                _wasPausedBecauseNoAutoNextSmil = true;\r\n                self.reset();\r\n                //self.pause();\r\n            }\r\n            else\r\n            {\r\n                nextSmil(goNext);\r\n            }\r\n            return;\r\n        }\r\n\r\n//console.debug(\"ITER: \" + _smilIterator.currentPar.text.srcFragmentId);\r\n\r\n        if(!_smilIterator.currentPar.audio) {\r\n            self.pause();\r\n            return;\r\n        }\r\n        \r\n        if(_settings.mediaOverlaysSkipSkippables)\r\n        {\r\n            var skip = false;\r\n            var parent = _smilIterator.currentPar;\r\n            while (parent)\r\n            {\r\n                if (parent.isSkippable && parent.isSkippable(_settings.mediaOverlaysSkippables))\r\n                {\r\n                    skip = true;\r\n                    break;\r\n                }\r\n                parent = parent.parent;\r\n            }\r\n\r\n            if (skip)\r\n            {\r\n                console.log(\"MO SKIP: \" + parent.epubtype);\r\n\r\n                self.pause();\r\n\r\n                var pos = goNext ? _smilIterator.currentPar.audio.clipEnd + 0.1 : DIRECTION_MARK - 1;\r\n\r\n                onAudioPositionChanged(pos, from, true); //noLetPlay\r\n                return;\r\n            }\r\n        }\r\n\r\n        // _settings.mediaOverlaysSynchronizationGranularity\r\n        if (!isPlaying && (_smilIterator.currentPar.element || _smilIterator.currentPar.cfi && _smilIterator.currentPar.cfi.cfiTextParent))\r\n        {\r\n            var scopeTo = _elementHighlighter.adjustParToSeqSyncGranularity(_smilIterator.currentPar);\r\n            if (scopeTo && scopeTo !== _smilIterator.currentPar)\r\n            {\r\n                var scopeFrom = _elementHighlighter.adjustParToSeqSyncGranularity(parFrom);\r\n                if (scopeFrom && (scopeFrom === scopeTo || !goNext))\r\n                {\r\n                    if (scopeFrom === scopeTo)\r\n                    {\r\n                        do\r\n                        {\r\n                            if (goNext) _smilIterator.next();\r\n                            else  _smilIterator.previous();\r\n                        } while (_smilIterator.currentPar && _smilIterator.currentPar.hasAncestor(scopeFrom));\r\n\r\n                        if (!_smilIterator.currentPar)\r\n                        {\r\n    //console.debug(\"adjustParToSeqSyncGranularity nextSmil(goNext)\");\r\n\r\n                            if (doNotNextSmil)\r\n                            {\r\n                                _wasPausedBecauseNoAutoNextSmil = true;\r\n                                self.reset();\r\n                                //self.pause();\r\n                            }\r\n                            else\r\n                            {\r\n                                nextSmil(goNext);\r\n                            }\r\n                            \r\n                            return;\r\n                        }\r\n                    }\r\n                    \r\n//console.debug(\"ADJUSTED: \" + _smilIterator.currentPar.text.srcFragmentId);\r\n                    if (!goNext)\r\n                    {\r\n                        var landed = _elementHighlighter.adjustParToSeqSyncGranularity(_smilIterator.currentPar);\r\n                        if (landed && landed !== _smilIterator.currentPar)\r\n                        {\r\n                            var backup = _smilIterator.currentPar;\r\n                    \r\n                            var innerPar = undefined;\r\n                            do\r\n                            {\r\n                                innerPar = _smilIterator.currentPar;\r\n                                _smilIterator.previous();\r\n                            }\r\n                            while (_smilIterator.currentPar && _smilIterator.currentPar.hasAncestor(landed));\r\n                        \r\n                            if (_smilIterator.currentPar)\r\n                            {\r\n                                _smilIterator.next();\r\n                                \r\n                                if (!_smilIterator.currentPar.hasAncestor(landed))\r\n                                {\r\n                                    console.error(\"adjustParToSeqSyncGranularity !_smilIterator.currentPar.hasAncestor(landed) ???\");\r\n                                }\r\n                                //assert \r\n                            }\r\n                            else\r\n                            {\r\n//console.debug(\"adjustParToSeqSyncGranularity reached begin\");\r\n\r\n                                _smilIterator.reset();\r\n                                \r\n                                if (_smilIterator.currentPar !== innerPar)\r\n                                {\r\n                                    console.error(\"adjustParToSeqSyncGranularity _smilIterator.currentPar !=== innerPar???\");\r\n                                }\r\n                            }\r\n\r\n                            if (!_smilIterator.currentPar)\r\n                            {\r\n                                console.error(\"adjustParToSeqSyncGranularity !_smilIterator.currentPar ?????\");\r\n                                _smilIterator.goToPar(backup);\r\n                            }\r\n                            \r\n//console.debug(\"ADJUSTED PREV: \" + _smilIterator.currentPar.text.srcFragmentId);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        \r\n        if(_audioPlayer.isPlaying()\r\n            && _smilIterator.currentPar.audio.src\r\n            && _smilIterator.currentPar.audio.src == _audioPlayer.currentSmilSrc()\r\n                && position >= _smilIterator.currentPar.audio.clipBegin\r\n                && position <= _smilIterator.currentPar.audio.clipEnd)\r\n        {\r\n//console.debug(\"ONLY highlightCurrentElement\");\r\n            highlightCurrentElement();\r\n            return;\r\n        }\r\n\r\n        //position <= DIRECTION_MARK goes here (goto previous):\r\n\r\n//            if (!noLetPlay && position > DIRECTION_MARK\r\n//                && _audioPlayer.isPlaying() && _audioPlayer.srcRef() != _smilIterator.currentPar.audio.src)\r\n//            {\r\n//                _letPlay = true;\r\n//                setTimeout(function()\r\n//                {\r\n//                    _letPlay = false;\r\n//                    playCurrentPar();\r\n//                }, 100);\r\n//\r\n//                playCurrentPar();\r\n//\r\n//                return;\r\n//            }\r\n\r\n        playCurrentPar();\r\n    }\r\n\r\n    this.touchInit = function()\r\n    {\r\n        var todo = _audioPlayer.touchInit();\r\n        if (todo)\r\n        {\r\n            if (_enableHTMLSpeech)\r\n            {\r\n                speakStart(\"o\", 0);\r\n            }\r\n        }\r\n    };\r\n\r\n    var tokeniseTTS = function(element)\r\n    {\r\n        var BLOCK_DELIMITERS = ['p', 'div', 'pagenum', 'td', 'table', 'li', 'ul', 'ol'];\r\n        var BOUNDARY_PUNCTUATION = [',', ';', '.', '-', '??', '??', '?', '!'];\r\n        var IGNORABLE_PUNCTUATION = ['\"', '\\'', '??', '??', '??', '??'];\r\n\r\n        var flush = function(t, r)\r\n        {\r\n            if (t.word.length <= 0)\r\n            {\r\n                return;\r\n            }\r\n\r\n            var pos = t.text.length;\r\n            r.spanMap[pos] = t.counter;\r\n            t.text += t.word;\r\n            t.markup += t.html.substring(0, t.wordStart) +\r\n                '<span class=\"tts_off\" id=\"tts_' + t.counter + '\">' +\r\n                t.html.substring(t.wordStart, t.wordEnd) +\r\n                '</span>' + t.html.substring(t.wordEnd, t.html.length);\r\n            t.word = \"\";\r\n            t.html = \"\";\r\n            t.wordStart = -1;\r\n            t.wordEnd = -1;\r\n            t.counter++;\r\n        };\r\n\r\n        var r =\r\n        {\r\n            element : element,\r\n            innerHTML_tts : \"\",\r\n            spanMap : {},\r\n            text : \"\",\r\n            lastCharIndex : undefined\r\n        };\r\n        r.element.innerHTML_original = element.innerHTML;\r\n\r\n        var t =\r\n        {\r\n            inTag : false,\r\n            counter : 0,\r\n            wordStart : -1,\r\n            wordEnd : -1,\r\n            text : '',\r\n            markup : '',\r\n            word : '',\r\n            html : ''\r\n        };\r\n\r\n        var limit = r.element.innerHTML_original.length;\r\n        var i = 0;\r\n        while (i <= limit)\r\n        {\r\n            if (t.inTag)\r\n            {\r\n                t.html += r.element.innerHTML_original[i];\r\n                if (r.element.innerHTML_original[i] == \">\") {\r\n                    t.inTag = false;\r\n                    // if it's a block element delimiter, flush\r\n                    var blockCheck = t.html.match(/<\\/(.*?)>$/);\r\n                    if (blockCheck && BLOCK_DELIMITERS.indexOf(blockCheck[1]) > -1)\r\n                    {\r\n                        flush(t, r);\r\n                        t.text += ' ';\r\n                    }\r\n                }\r\n            }\r\n            else\r\n            {\r\n                if (i == limit || r.element.innerHTML_original[i].match(/\\s/))\r\n                {\r\n                    flush(t, r);\r\n\r\n                    // append the captured whitespace\r\n                    if (i < limit)\r\n                    {\r\n                        t.text += r.element.innerHTML_original[i];\r\n                        t.markup += r.element.innerHTML_original[i];\r\n                    }\r\n                }\r\n                else if (BOUNDARY_PUNCTUATION.indexOf(r.element.innerHTML_original[i]) > -1)\r\n                {\r\n                    flush(t, r);\r\n\r\n                    t.wordStart = t.html.length;\r\n                    t.wordEnd = t.html.length + 1;\r\n                    t.word += r.element.innerHTML_original[i];\r\n                    t.html += r.element.innerHTML_original[i];\r\n\r\n                    flush(t, r);\r\n                }\r\n                else if (r.element.innerHTML_original[i] == \"<\")\r\n                {\r\n                    t.inTag = true;\r\n                    t.html += r.element.innerHTML_original[i];\r\n                }\r\n                else\r\n                {\r\n                    if (t.word.length == 0)\r\n                    {\r\n                        t.wordStart = t.html.length;\r\n                    }\r\n                    t.wordEnd = t.html.length + 1;\r\n                    t.word += r.element.innerHTML_original[i];\r\n                    t.html += r.element.innerHTML_original[i];\r\n                }\r\n            }\r\n            i++;\r\n        }\r\n//\r\n//console.debug(t.text);\r\n//        console.debug(\"----\");\r\n//console.debug(t.markup);\r\n\r\n        r.text = t.text;\r\n        r.innerHTML_tts = t.markup;\r\n        r.element.innerHTML = r.innerHTML_tts;\r\n\r\n        return r;\r\n    };\r\n\r\n    var $ttsStyle = undefined;\r\n    function ensureTTSStyle($element)\r\n    {\r\n        if ($ttsStyle && $ttsStyle[0].ownerDocument === $element[0].ownerDocument)\r\n        {\r\n            return;\r\n        }\r\n\r\n        var style = \".tts_on{background-color:red;color:white;} .tts_off{}\";\r\n\r\n        $head = $(\"head\", $element[0].ownerDocument.documentElement);\r\n\r\n        $ttsStyle = $(\"<style type='text/css'> </style>\").appendTo($head);\r\n\r\n        $ttsStyle.append(style);\r\n    }\r\n\r\n    var speakStart = function(txt, volume)\r\n    {\r\n        var tokenData = undefined;\r\n        var curPar = (_smilIterator && _smilIterator.currentPar) ? _smilIterator.currentPar : undefined;\r\n        var element = curPar ? curPar.element : undefined;\r\n        var cfi = curPar ? curPar.cfi : undefined;\r\n\r\n        if (!volume || volume > 0)\r\n        {\r\n            // gives the audio player some dispatcher time to raise the onPause event\r\n            setTimeout(function(){\r\n                onStatusChanged({isPlaying: true});\r\n            }, 80);\r\n            \r\n            _ttsIsPlaying = true;\r\n\r\n            if (TOKENIZE_TTS && element)\r\n            {\r\n                var $el = $(element);\r\n                ensureTTSStyle($el);\r\n\r\n\r\n                if (element.innerHTML_original)\r\n                {\r\n                    element.innerHTML = element.innerHTML_original;\r\n                    element.innerHTML_original = undefined;\r\n                }\r\n                tokenData = tokeniseTTS(element);\r\n            }\r\n        }\r\n\r\n        if (!_enableHTMLSpeech)\r\n        {\r\n            Globals.logEvent(\"MEDIA_OVERLAY_TTS_SPEAK\", \"EMIT\", \"media_overlay_player.js\");\r\n            reader.emit(Globals.Events.MEDIA_OVERLAY_TTS_SPEAK, {tts: txt}); // resume if txt == undefined\r\n            return;\r\n        }\r\n\r\n        if (!txt && window.speechSynthesis.paused)\r\n        {\r\n//console.debug(\"TTS resume\");\r\n            window.speechSynthesis.resume();\r\n\r\n            return;\r\n        }\r\n\r\n        var text = txt || _currentTTS;\r\n\r\n        if (text)\r\n        {\r\n            if (_SpeechSynthesisUtterance)\r\n            {\r\n//console.debug(\"_SpeechSynthesisUtterance nullify\");\r\n\r\n                if (TOKENIZE_TTS)\r\n                {\r\n                    if (_SpeechSynthesisUtterance.onend)\r\n                    {\r\n                        _SpeechSynthesisUtterance.onend({forceSkipEnd: true, target: _SpeechSynthesisUtterance});\r\n                    }\r\n                    \r\n                    _SpeechSynthesisUtterance.tokenData = undefined;\r\n                    \r\n                    _SpeechSynthesisUtterance.onboundary = undefined;\r\n    //                 _SpeechSynthesisUtterance.onboundary = function(event)\r\n    //                 {\r\n    // console.debug(\"OLD TTS boundary\");\r\n    //                 \r\n    //                         event.target.tokenData = undefined;\r\n    //  \r\n    //                 };\r\n                }\r\n\r\n                _SpeechSynthesisUtterance.onend = undefined;\r\n//                 _SpeechSynthesisUtterance.onend = function(event)\r\n//                 {\r\n// console.debug(\"OLD TTS ended\");\r\n//                     if (TOKENIZE_TTS)\r\n//                     {\r\n//                         event.target.tokenData = undefined;\r\n//                     }\r\n//                 };\r\n                \r\n                _SpeechSynthesisUtterance.onerror = undefined;\r\n//                 _SpeechSynthesisUtterance.onerror = function(event)\r\n//                 {\r\n// console.debug(\"OLD TTS error\");\r\n// //console.debug(event);\r\n//                     if (TOKENIZE_TTS)\r\n//                     {\r\n//                         event.target.tokenData = undefined;\r\n//                     }\r\n//                 };\r\n\r\n                _SpeechSynthesisUtterance = undefined;\r\n            }\r\n//\r\n//            if (window.speechSynthesis.pending ||\r\n//                window.speechSynthesis.speaking)\r\n//            {\r\n//                _skipTTSEndEvent = true;\r\n//            }\r\n            \r\nconsole.debug(\"paused: \"+window.speechSynthesis.paused);\r\nconsole.debug(\"speaking: \"+window.speechSynthesis.speaking);\r\nconsole.debug(\"pending: \"+window.speechSynthesis.pending);\r\n\r\n//             if (!window.speechSynthesis.paused)\r\n//             {\r\n// console.debug(\"TTS pause before speak\");\r\n//                 window.speechSynthesis.pause();\r\n//             }\r\n            \r\n            function cancelTTS(first)\r\n            {\r\n                if (first || window.speechSynthesis.pending)\r\n                {\r\n    console.debug(\"TTS cancel before speak\");\r\n                    window.speechSynthesis.cancel();\r\n\r\n                    setTimeout(function()\r\n                    {\r\n                        cancelTTS(false);\r\n                    }, 5);\r\n                }\r\n                else\r\n                {\r\n                    updateTTS();\r\n                }\r\n            }\r\n            cancelTTS(true);\r\n            \r\n            function updateTTS()\r\n            {\r\n            // setTimeout(function()\r\n            // {\r\n\r\n                _SpeechSynthesisUtterance = new SpeechSynthesisUtterance();\r\n\r\n                if (TOKENIZE_TTS && tokenData)\r\n                {\r\n                    _SpeechSynthesisUtterance.tokenData = tokenData;\r\n                \r\n                    _SpeechSynthesisUtterance.onboundary = function(event)\r\n                    //_SpeechSynthesisUtterance.addEventListener(\"boundary\", function(event)\r\n                    {\r\n                        if (!_SpeechSynthesisUtterance)\r\n                        {\r\n                            return;\r\n                        }\r\n\r\n        console.debug(\"TTS boundary: \" + event.name + \" / \" + event.charIndex);\r\n        //console.debug(event);\r\n\r\n                        var tokenised = event.target.tokenData;\r\n                        if (!tokenised || !tokenised.spanMap.hasOwnProperty(event.charIndex))\r\n                        {\r\n                            return;\r\n                        }\r\n\r\n                        if (false && tokenised.lastCharIndex)\r\n                        {\r\n        //console.debug(\"TTS lastCharIndex: \" + tokenised.lastCharIndex);\r\n                            var id = 'tts_' + tokenised.spanMap[tokenised.lastCharIndex];\r\n        //console.debug(\"TTS lastCharIndex ID: \" + id);\r\n                            var spanPrevious = tokenised.element.querySelector(\"#\"+id);\r\n                            if (spanPrevious)\r\n                            {\r\n        //console.debug(\"TTS OFF\");\r\n                                spanPrevious.className = 'tts_off';\r\n                                //spanPrevious.style.backgroundColor = \"white\";\r\n                            }\r\n                        }\r\n                        else\r\n                        {\r\n                            [].forEach.call(\r\n                                tokenised.element.querySelectorAll(\".tts_on\"),\r\n                                function(el)\r\n                                {\r\n        console.debug(\"TTS OFF \" + el.id);\r\n                                    el.className = 'tts_off';\r\n                                }\r\n                            );\r\n                        }\r\n\r\n                        var id = 'tts_' + tokenised.spanMap[event.charIndex];\r\n        console.debug(\"TTS charIndex ID: \" + id);\r\n                        var spanNew = tokenised.element.querySelector(\"#\"+id);\r\n                        if (spanNew)\r\n                        {\r\n        console.debug(\"TTS ON\");\r\n                            spanNew.className = 'tts_on';\r\n                            //spanNew.style.backgroundColor = \"transparent\";\r\n                        }\r\n\r\n                        tokenised.lastCharIndex = event.charIndex;\r\n                    };\r\n                }\r\n\r\n                _SpeechSynthesisUtterance.onend = function(event)\r\n                //_SpeechSynthesisUtterance.addEventListener(\"end\", function(event)\r\n                {\r\n                    if (!_SpeechSynthesisUtterance)\r\n                    {\r\n                        //_skipTTSEndEvent = false;\r\n                        return;\r\n                    }\r\n    //\r\n    //                if (_skipTTSEndEvent)\r\n    //                {\r\n    //                    _skipTTSEndEvent = false;\r\n    //                    return;\r\n    //                }\r\n\r\nconsole.debug(\"TTS ended\");\r\n    //console.debug(event);\r\n\r\n                    if (TOKENIZE_TTS)\r\n                    {\r\n                        var tokenised = event.target.tokenData;\r\n\r\n                        var doEnd = !event.forceSkipEnd && (_SpeechSynthesisUtterance === event.target) && (!tokenised || tokenised.element.innerHTML_original);\r\n\r\n                        if (tokenised)\r\n                        {\r\n                            if (tokenised.element.innerHTML_original)\r\n                            {\r\n                                tokenised.element.innerHTML = tokenised.element.innerHTML_original;\r\n                            }\r\n                            else\r\n                            {\r\n                                [].forEach.call(\r\n                                    tokenised.element.querySelectorAll(\".tts_on\"),\r\n                                    function(el)\r\n                                    {\r\n        console.debug(\"TTS OFF (end)\" + el.id);\r\n                                        el.className = 'tts_off';\r\n                                    }\r\n                                );\r\n                            }\r\n\r\n                            tokenised.element.innerHTML_original = undefined;\r\n                        }\r\n\r\n\r\n                        if (doEnd)\r\n                        {\r\n                            self.onTTSEnd();\r\n                        }\r\n                        else\r\n                        {\r\n    console.debug(\"TTS end SKIPPED\");\r\n                        }\r\n                    }\r\n                    else\r\n                    {\r\n                        self.onTTSEnd();\r\n                    }\r\n                };\r\n\r\n                _SpeechSynthesisUtterance.onerror = function(event)\r\n                //_SpeechSynthesisUtterance.addEventListener(\"error\", function(event)\r\n                {\r\n                    if (!_SpeechSynthesisUtterance)\r\n                    {\r\n                        return;\r\n                    }\r\n\r\nconsole.error(\"TTS error\");\r\n//console.debug(event);\r\nconsole.debug(_SpeechSynthesisUtterance.text);\r\nconsole.debug(window.speechSynthesis.paused);\r\nconsole.debug(window.speechSynthesis.pending);\r\nconsole.debug(window.speechSynthesis.speaking);\r\n\r\n                    if (TOKENIZE_TTS)\r\n                    {\r\n                        var tokenised = event.target.tokenData;\r\n                        if (tokenised)\r\n                        {\r\n                            if (tokenised.element.innerHTML_original)\r\n                            {\r\n                                tokenised.element.innerHTML = tokenised.element.innerHTML_original;\r\n                            }\r\n                            else\r\n                            {\r\n                                [].forEach.call(\r\n                                    tokenised.element.ownerDocument.querySelectorAll(\".tts_on\"),\r\n                                    function(el)\r\n                                    {\r\n        console.debug(\"TTS OFF (error)\" + el.id);\r\n                                        el.className = 'tts_off';\r\n                                    }\r\n                                );\r\n                            }\r\n                            tokenised.element.innerHTML_original = undefined;\r\n                        }\r\n                    }\r\n                };\r\n\r\n                var vol = volume || _audioPlayer.getVolume();\r\n                _SpeechSynthesisUtterance.volume = vol;\r\n\r\n                _SpeechSynthesisUtterance.rate = _audioPlayer.getRate();\r\n                _SpeechSynthesisUtterance.pitch = 1;\r\n\r\n                //_SpeechSynthesisUtterance.lang = \"en-US\";\r\n\r\n                _SpeechSynthesisUtterance.text = text;\r\n\r\n    //console.debug(\"TTS speak: \" + text);\r\n                window.speechSynthesis.speak(_SpeechSynthesisUtterance);\r\n\r\n                if (window.speechSynthesis.paused)\r\n                {\r\nconsole.debug(\"TTS resume\");\r\n                    window.speechSynthesis.resume();\r\n                }\r\n\r\n           //}, 5);\r\n           }\r\n        }\r\n    };\r\n\r\n    var speakStop = function()\r\n    {\r\n        var wasPlaying = _ttsIsPlaying;\r\n\r\n        if (wasPlaying) {\r\n            onStatusChanged({isPlaying: false});\r\n        }\r\n        \r\n        _ttsIsPlaying = false;\r\n\r\n        if (!_enableHTMLSpeech)\r\n        {\r\n            if (wasPlaying) {\r\n                Globals.logEvent(\"MEDIA_OVERLAY_TTS_STOP\", \"EMIT\", \"media_overlay_player.js\");\r\n                reader.emit(Globals.Events.MEDIA_OVERLAY_TTS_STOP, undefined);\r\n            }\r\n            return;\r\n        }\r\n\r\n//console.debug(\"TTS pause\");\r\n        window.speechSynthesis.pause();\r\n    };\r\n\r\n    var _timerTick = undefined;\r\n\r\n    function onPlay() {\r\n        onPause();\r\n\r\n        var func = function() {\r\n\r\n            if (!_smilIterator || !_smilIterator.currentPar)\r\n            {\r\n                return;\r\n            }\r\n\r\n            var smil = _smilIterator.smil; //currentPar.getSmil();\r\n            if (!smil.mo)\r\n            {\r\n                return;\r\n            }\r\n\r\n//            if (!_smilIterator.currentPar.audio.src)\r\n//            {\r\n//                return;\r\n//            }\r\n\r\n            var playPosition = audioCurrentTime - _smilIterator.currentPar.audio.clipBegin;\r\n            if (playPosition <= 0)\r\n            {\r\n                return;\r\n            }\r\n\r\n            var smilIndex = smil.mo.smil_models.indexOf(smil);\r\n\r\n            var smilIterator = new SmilIterator(smil);\r\n            var parIndex = -1;\r\n            while (smilIterator.currentPar)\r\n            {\r\n                parIndex++;\r\n                if (smilIterator.currentPar == _smilIterator.currentPar)\r\n                {\r\n                    break;\r\n                }\r\n                smilIterator.next();\r\n            }\r\n\r\n            onStatusChanged({playPosition: playPosition, smilIndex: smilIndex, parIndex: parIndex});\r\n        };\r\n\r\n        setTimeout(func, 500);\r\n\r\n        _timerTick = setInterval(func, 1500);\r\n    }\r\n\r\n    function onPause() {\r\n\r\n        audioCurrentTime = 0.0;\r\n        if (_timerTick !== undefined)\r\n        {\r\n            clearInterval(_timerTick);\r\n        }\r\n        _timerTick = undefined;\r\n    }\r\n\r\n\r\n    this.onEmbeddedEnd = function()\r\n    {\r\n        audioCurrentTime = 0.0;\r\n\r\n        _embeddedIsPlaying = false;\r\n        //_currentEmbedded = undefined;\r\n\r\n        if (!_smilIterator || !_smilIterator.currentPar)\r\n        {\r\n            self.reset();\r\n            return;\r\n        }\r\n\r\n        onAudioPositionChanged(_smilIterator.currentPar.audio.clipEnd + 0.1, 3);\r\n    };\r\n\r\n    this.onTTSEnd = function()\r\n    {\r\n        audioCurrentTime = 0.0;\r\n\r\n        _ttsIsPlaying = false;\r\n        //_currentTTS = undefined;\r\n\r\n//        if(_skipTTSEnded)\r\n//        {\r\n//            _skipTTSEnded = false;\r\n//            return;\r\n//        }\r\n\r\n        if (!_smilIterator || !_smilIterator.currentPar)\r\n        {\r\n            self.reset();\r\n            return;\r\n        }\r\n\r\n        onAudioPositionChanged(_smilIterator.currentPar.audio.clipEnd + 0.1, 4);\r\n    };\r\n\r\n    function onAudioEnded() {\r\n\r\n        onPause();\r\n//\r\n//        if (_letPlay)\r\n//        {\r\n//            return;\r\n//        }\r\n\r\n        if(_skipAudioEnded)\r\n        {\r\n            _skipAudioEnded = false;\r\n            return;\r\n        }\r\n\r\n        if (!_smilIterator || !_smilIterator.currentPar)\r\n        {\r\n            self.reset();\r\n            return;\r\n        }\r\n\r\n        onAudioPositionChanged(_smilIterator.currentPar.audio.clipEnd + 0.1, 5);\r\n    }\r\n\r\n    function highlightCurrentElement() {\r\n\r\n        if(!_smilIterator) {\r\n            return;\r\n        }\r\n\r\n        if(!_smilIterator.currentPar) {\r\n            return;\r\n        }\r\n\r\n        if (_smilIterator.currentPar.text.srcFragmentId && _smilIterator.currentPar.text.srcFragmentId.length > 0)\r\n        {\r\n            if (_smilIterator.currentPar.element) {\r\n    //console.error(_smilIterator.currentPar.element.id + \": \" + _smilIterator.currentPar.audio.clipBegin + \" / \" + _smilIterator.currentPar.audio.clipEnd);\r\n\r\n                if (!_elementHighlighter.isElementHighlighted(_smilIterator.currentPar))\r\n                {\r\n                    _elementHighlighter.highlightElement(_smilIterator.currentPar, _package.media_overlay.activeClass, _package.media_overlay.playbackActiveClass);\r\n\r\n                    if (!_wasPlayingScrolling)\r\n                    {\r\n                        reader.insureElementVisibility(_smilIterator.currentPar.getSmil().spineItemId, _smilIterator.currentPar.element, self);\r\n                    }\r\n                }\r\n            \r\n                return;\r\n            \r\n            } else if (_smilIterator.currentPar.cfi) {\r\n\r\n                if (!_elementHighlighter.isCfiHighlighted(_smilIterator.currentPar))\r\n                {\r\n                    _elementHighlighter.highlightCfi(_smilIterator.currentPar, _package.media_overlay.activeClass, _package.media_overlay.playbackActiveClass);\r\n\r\n                    if (!_wasPlayingScrolling)\r\n                    {\r\n                        reader.insureElementVisibility(_smilIterator.currentPar.getSmil().spineItemId, _smilIterator.currentPar.cfi.cfiTextParent, self);\r\n                    }\r\n                }\r\n                \r\n                return;\r\n            }\r\n        }\r\n        \r\n        // body (not FRAG ID)\r\n        if (_smilIterator.currentPar.element) {\r\n            return;\r\n        }\r\n        \r\n        //else: single SMIL per multiple XHTML? ==> open new spine item\r\n        \r\n        /*\r\n        var textRelativeRef = Globals.Helpers.ResolveContentRef(_smilIterator.currentPar.text.srcFile, _smilIterator.smil.href);\r\nconsole.debug(\"textRelativeRef: \" + textRelativeRef);\r\n        if (textRelativeRef)\r\n        {\r\n            var textAbsoluteRef = _package.resolveRelativeUrl(textRelativeRef);\r\nconsole.debug(\"textAbsoluteRef: \" + textAbsoluteRef);\r\n        }\r\n        */\r\n\r\n        var src = _smilIterator.currentPar.text.src;\r\n        var base = _smilIterator.smil.href;\r\n\r\n        //self.pause();\r\n        //self.reset();\r\n        _smilIterator = undefined;\r\n\r\n        reader.openContentUrl(src, base, self);\r\n    }\r\n\r\n    this.escape = function() {\r\n        \r\n        if(!_smilIterator || !_smilIterator.currentPar) {\r\n\r\n            this.toggleMediaOverlay();\r\n            return;\r\n        }\r\n\r\n        if(!self.isPlaying())\r\n        {\r\n            //playCurrentPar();\r\n            self.play();\r\n            return;\r\n        }\r\n\r\n        if(_settings.mediaOverlaysEscapeEscapables)\r\n        {\r\n            var parent = _smilIterator.currentPar;\r\n            while (parent)\r\n            {\r\n                if (parent.isEscapable && parent.isEscapable(_settings.mediaOverlaysEscapables))\r\n                {\r\n                    do\r\n                    {\r\n                        _smilIterator.next();\r\n                    } while (_smilIterator.currentPar && _smilIterator.currentPar.hasAncestor(parent));\r\n\r\n                    if (!_smilIterator.currentPar)\r\n                    {\r\n                        nextSmil(true);\r\n                        return;\r\n                    }\r\n\r\n                    //_smilIterator.goToPar(_smilIterator.currentPar);\r\n                    playCurrentPar();\r\n                    return;\r\n                }\r\n\r\n                parent = parent.parent;\r\n            }\r\n        }\r\n\r\n        this.nextMediaOverlay(true);\r\n    };\r\n\r\n\r\n    this.playUserPar = function(par) {\r\n        if(self.isPlaying())\r\n        {\r\n            self.pause();\r\n        }\r\n\r\n        if (par.element || par.cfi && par.cfi.cfiTextParent)\r\n        {\r\n            var seq = _elementHighlighter.adjustParToSeqSyncGranularity(par);\r\n            if (seq && seq !== par)\r\n            {\r\n                var findFirstPar = function(smilNode)\r\n                {\r\n                    if (smilNode.nodeType && smilNode.nodeType === \"par\") return smilNode;\r\n                    \r\n                    if (!smilNode.children || smilNode.children.length <= 0) return undefined;\r\n                    \r\n                    for (var i = 0; i < smilNode.children.length; i++)\r\n                    {\r\n                        var child = smilNode.children[i];\r\n                        var inPar = findFirstPar(child);\r\n                        if (inPar) return inPar;\r\n                    }\r\n                };\r\n                var firstPar = findFirstPar(seq);\r\n                if (firstPar) par = firstPar;\r\n            }\r\n        }\r\n\r\n        playPar(par);\r\n    };\r\n\r\n    this.resetTTS = function() {\r\n        _currentTTS = undefined;\r\n//        _skipTTSEnded = false;\r\n        speakStop();\r\n    };\r\n\r\n    this.resetBlankPage = function() {\r\n        var wasPlaying = false;\r\n        \r\n        if (_blankPagePlayer)\r\n        {\r\n            wasPlaying = true;\r\n            \r\n            var timer = _blankPagePlayer;\r\n            _blankPagePlayer = undefined;\r\n            clearTimeout(timer);\r\n        }\r\n        _blankPagePlayer = undefined;\r\n\r\n        if (wasPlaying) {\r\n            onStatusChanged({isPlaying: false});\r\n        }\r\n    };\r\n\r\n    this.resetEmbedded = function() {\r\n        var wasPlaying = _embeddedIsPlaying;\r\n        \r\n        if (_currentEmbedded)\r\n        {\r\n            $(_currentEmbedded).off(\"ended\", self.onEmbeddedEnd);\r\n            _currentEmbedded.pause();\r\n        }\r\n        _currentEmbedded = undefined;\r\n        \r\n        if (wasPlaying) {\r\n            onStatusChanged({isPlaying: false});\r\n        }\r\n        _embeddedIsPlaying = false;\r\n    };\r\n\r\n    this.reset = function() {\r\n        clipBeginOffset = 0.0;\r\n        _audioPlayer.reset();\r\n        self.resetTTS();\r\n        self.resetEmbedded();\r\n        self.resetBlankPage();\r\n        _elementHighlighter.reset();\r\n        _smilIterator = undefined;\r\n        _skipAudioEnded = false;\r\n    };\r\n\r\n    this.play = function ()\r\n    {\r\n        if (_smilIterator && _smilIterator.smil && !_smilIterator.smil.id)\r\n        {\r\n            initBlankPagePlayer();\r\n            return;\r\n        }\r\n        else if (_currentEmbedded)\r\n        {\r\n            _embeddedIsPlaying = true;\r\n            _currentEmbedded.play();\r\n            onStatusChanged({isPlaying: true});\r\n        }\r\n        else if (_currentTTS)\r\n        {\r\n            speakStart(undefined);\r\n        }\r\n        else\r\n        {\r\n            if (!_audioPlayer.play())\r\n            {\r\n                console.log(\"Audio player was dead, reactivating...\");\r\n\r\n                this.reset();\r\n                this.toggleMediaOverlay();\r\n                return;\r\n            }\r\n        }\r\n\r\n        highlightCurrentElement();\r\n    }\r\n\r\n    this.pause = function()\r\n    {\r\n        _wasPlayingScrolling = false;\r\n        \r\n        if (_blankPagePlayer)\r\n        {\r\n            this.resetBlankPage();\r\n        }\r\n        else if (_embeddedIsPlaying)\r\n        {\r\n            _embeddedIsPlaying = false;\r\n            if (_currentEmbedded)\r\n            {\r\n                _currentEmbedded.pause();\r\n            }\r\n            onStatusChanged({isPlaying: false});\r\n        }\r\n        else if (_ttsIsPlaying)\r\n        {\r\n            speakStop();\r\n        }\r\n        else\r\n        {\r\n            _audioPlayer.pause();\r\n        }\r\n\r\n        _elementHighlighter.reset();\r\n    }\r\n\r\n    this.isMediaOverlayAvailable = function() {\r\n\r\n//        console.debug(\"isMediaOverlayAvailable()\");\r\n//\r\n//        var now1 = window.performance && window.performance.now ? window.performance.now() : Date.now();\r\n//\r\n//        if (console.time)\r\n//        {\r\n//            console.time(\"MO\");\r\n//        }\r\n\r\n        var visibleMediaElement = reader.getFirstVisibleMediaOverlayElement();\r\n\r\n//        if (console.timeEnd)\r\n//        {\r\n//            console.timeEnd(\"MO\");\r\n//        }\r\n//\r\n//        var now2 = window.performance && window.performance.now ? window.performance.now() : Date.now();\r\n//\r\n//        console.debug(now2 - now1);\r\n\r\n        return typeof visibleMediaElement !== \"undefined\";\r\n    };\r\n\r\n    this.nextOrPreviousMediaOverlay = function(previous) {\r\n        if(self.isPlaying())\r\n        {\r\n            self.pause();\r\n        }\r\n        else\r\n        {\r\n            if (_smilIterator && _smilIterator.currentPar)\r\n            {\r\n                //playCurrentPar();\r\n                self.play();\r\n                return;\r\n            }\r\n        }\r\n\r\n        if(!_smilIterator)\r\n        {\r\n            this.toggleMediaOverlay();\r\n            return;\r\n        }\r\n\r\n        var position = previous ? DIRECTION_MARK - 1 : _smilIterator.currentPar.audio.clipEnd + 0.1;\r\n\r\n        onAudioPositionChanged(position, 6);\r\n        // setTimeout(function(){\r\n        //     \r\n        // }, 1);\r\n\r\n        //self.play();\r\n        //playCurrentPar();\r\n    };\r\n\r\n    this.nextMediaOverlay = function() {\r\n        this.nextOrPreviousMediaOverlay(false);\r\n    };\r\n\r\n    this.previousMediaOverlay = function() {\r\n        this.nextOrPreviousMediaOverlay(true);\r\n    };\r\n\r\n    /*\r\n    this.setMediaOverlaySkippables = function(items) {\r\n\r\n    };\r\n\r\n    this.setMediaOverlayEscapables = function(items) {\r\n\r\n    };\r\n    */\r\n\r\n    this.mediaOverlaysOpenContentUrl = function(contentRefUrl, sourceFileHref, offset)\r\n    {\r\n        clipBeginOffset = offset;\r\n\r\n        //self.pause();\r\n        //self.reset();\r\n        _smilIterator = undefined;\r\n\r\n        reader.openContentUrl(contentRefUrl, sourceFileHref, self);\r\n\r\n        /*\r\n        if (_currentPagination && _currentPagination.isFixedLayout && _currentPagination.openPages && _currentPagination.openPages.length > 0)\r\n        {\r\n            var combinedPath = Globals.Helpers.ResolveContentRef(contentRefUrl, sourceFileHref);\r\n\r\n            var hashIndex = combinedPath.indexOf(\"#\");\r\n            var hrefPart;\r\n            var elementId;\r\n            if(hashIndex >= 0) {\r\n                hrefPart = combinedPath.substr(0, hashIndex);\r\n                elementId = combinedPath.substr(hashIndex + 1);\r\n            }\r\n            else {\r\n                hrefPart = combinedPath;\r\n                elementId = undefined;\r\n            }\r\n\r\n            var spineItem = reader.spine.getItemByHref(hrefPart);\r\n            var spineItemIndex = _currentPagination.openPages[0].spineItemIndex;\r\n\r\n            //var idref = _currentPagination.openPages[0].idref;\r\n            //spineItem.idref === idref\r\n            //var currentSpineItem = reader.spine.getItemById(idref);\r\n            //currentSpineItem == spineItem\r\n            if (spineItem.index === spineItemIndex)\r\n            {\r\n                self.onPageChanged({\r\n                    paginationInfo: _currentPagination,\r\n                    elementId: elementId,\r\n                    initiator: self\r\n                });\r\n            }\r\n        }\r\n        */\r\n    };\r\n\r\n    this.toggleMediaOverlay = function() {\r\n        if(self.isPlaying()) {\r\n            self.pause();\r\n            return;\r\n        }\r\n\r\n        //if we have position to continue from (reset wasn't called)\r\n        if(_smilIterator) {\r\n            self.play();\r\n            return;\r\n        }\r\n\r\n        this.toggleMediaOverlayRefresh(undefined);\r\n    };\r\n\r\n    var _wasPlayingScrolling = false;\r\n\r\n    this.toggleMediaOverlayRefresh = function(paginationData)\r\n    {\r\n//console.debug(\"moData SMIL: \" + moData.par.getSmil().href + \" // \" + + moData.par.getSmil().id);\r\n\r\n        var spineItems = reader.getLoadedSpineItems();\r\n\r\n        //paginationData.isRightToLeft\r\n        var rtl = reader.spine().isRightToLeft();\r\n\r\n        //paginationData.spineItemCount\r\n        //paginationData.openPages\r\n        //{spineItemPageIndex: , spineItemPageCount: , idref: , spineItemIndex: }\r\n\r\n        var playingPar = undefined;\r\n        var wasPlaying = self.isPlaying();\r\n        if(wasPlaying && _smilIterator)\r\n        {\r\n            var isScrollView = paginationData.initiator && paginationData.initiator instanceof ScrollView;\r\n            if (isScrollView && _settings.mediaOverlaysPreservePlaybackWhenScroll)\r\n            {\r\n                _wasPlayingScrolling = true;\r\n                return;\r\n            }\r\n            \r\n            playingPar = _smilIterator.currentPar;\r\n            self.pause();\r\n        }\r\n        \r\n        _wasPlayingScrolling = false;\r\n\r\n        //paginationData && paginationData.elementId\r\n        //paginationData.initiator != self\r\n\r\n        //_package.isFixedLayout()\r\n\r\n        var element = (paginationData && paginationData.elementIdResolved) ? paginationData.elementIdResolved : undefined;\r\n\r\n        var id = (paginationData && paginationData.elementId) ? paginationData.elementId : undefined;\r\n\r\n        if (!element)\r\n        {\r\n            if (id)\r\n            {\r\n                console.error(\"[WARN] id did not resolve to element?\");\r\n            }\r\n            \r\n            for(var i = (rtl ? (spineItems.length - 1) : 0); (rtl && i >=0) || (!rtl && i < spineItems.length); i += (rtl ? -1: 1))\r\n            {\r\n                var spineItem = spineItems[i];\r\n                if (!spineItem)\r\n                {\r\n                    console.error(\"spineItems[i] is undefined??\");\r\n                    continue;\r\n                }\r\n            \r\n                if (paginationData && paginationData.spineItem && paginationData.spineItem != spineItem)\r\n                {\r\n                    continue;\r\n                }\r\n\r\n                if (id)\r\n                {\r\n                    var $element = reader.getElementById(spineItem.idref, id);\r\n                    //var $element = reader.getElement(spineItem.idref, \"#\" + ReadiumSDK.Helpers.escapeJQuerySelector(id));\r\n                    element = ($element && $element.length > 0) ? $element[0] : undefined;\r\n                }\r\n                else if (spineItem.isFixedLayout())\r\n                {\r\n                    if (paginationData && paginationData.paginationInfo && paginationData.paginationInfo.openPages)\r\n                    {\r\n                        // openPages are sorted by spineItem index, so the smallest index on display is the one we need to play (page on the left in LTR, or page on the right in RTL progression)\r\n                        var index = 0; // !paginationData.paginationInfo.isRightToLeft ? 0 : paginationData.paginationInfo.openPages.length - 1;\r\n                    \r\n                        if (paginationData.paginationInfo.openPages[index] && paginationData.paginationInfo.openPages[index].idref && paginationData.paginationInfo.openPages[index].idref === spineItem.idref)\r\n                        {\r\n                            var $element = reader.getElement(spineItem.idref, \"body\");\r\n                            element = ($element && $element.length > 0) ? $element[0] : undefined;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (element)\r\n                {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (!element)\r\n        {\r\n            element = reader.getFirstVisibleMediaOverlayElement();\r\n        }\r\n\r\n        if (!element)\r\n        {\r\n            self.reset();\r\n            return;\r\n        }\r\n\r\n        var moData = $(element).data(\"mediaOverlayData\");\r\n\r\n        if (!moData)\r\n        {\r\n            var foundMe = false;\r\n            var depthFirstTraversal = function(elements)\r\n            {\r\n                if (!elements)\r\n                {\r\n                    return false;\r\n                }\r\n\r\n                for (var i = 0; i < elements.length; i++)\r\n                {\r\n                    if (element === elements[i]) foundMe = true;\r\n                    \r\n                    if (foundMe)\r\n                    {\r\n                        var d = $(elements[i]).data(\"mediaOverlayData\");\r\n                        if (d)\r\n                        {\r\n                            moData = d;\r\n                            return true;\r\n                        }\r\n                    }\r\n\r\n                    var found = depthFirstTraversal(elements[i].children);\r\n                    if (found)\r\n                    {\r\n                        return true;\r\n                    }\r\n                }\r\n\r\n                return false;\r\n            }\r\n\r\n            var root = element;\r\n            while (root && root.nodeName.toLowerCase() !== \"body\")\r\n            {\r\n                root = root.parentNode;\r\n            }\r\n\r\n            if (!root)\r\n            {\r\n                self.reset();\r\n                return;\r\n            }\r\n\r\n            depthFirstTraversal([root]);\r\n        }\r\n\r\n        if (!moData)\r\n        {\r\n            self.reset();\r\n            return;\r\n        }\r\n\r\n        var zPar = moData.par ? moData.par : moData.pars[0];\r\n        var parSmil = zPar.getSmil();\r\n        if(!_smilIterator || _smilIterator.smil != parSmil)\r\n        {\r\n            _smilIterator = new SmilIterator(parSmil);\r\n        }\r\n        else\r\n        {\r\n            _smilIterator.reset();\r\n        }\r\n        \r\n        _smilIterator.goToPar(zPar);\r\n        \r\n        if (!_smilIterator.currentPar && id)\r\n        {\r\n            _smilIterator.reset();\r\n            _smilIterator.findTextId(id);\r\n        }\r\n        \r\n        if (!_smilIterator.currentPar)\r\n        {\r\n            self.reset();\r\n            return;\r\n        }\r\n\r\n        if (wasPlaying && playingPar && playingPar === _smilIterator.currentPar)\r\n        {\r\n            self.play();\r\n        }\r\n        else\r\n        {\r\n            playCurrentPar();\r\n            //playPar(zPar);\r\n        }\r\n    };\r\n\r\n    this.isPlayingCfi = function()\r\n    {\r\n        return _smilIterator && _smilIterator.currentPar && _smilIterator.currentPar.cfi;\r\n    };\r\n    \r\n    var _wasPausedBecauseNoAutoNextSmil = false;\r\n    var _autoNextSmil = true;\r\n    this.setAutomaticNextSmil = function(autoNext)\r\n    {\r\n        _autoNextSmil = autoNext;\r\n    };\r\n};\r\n    return MediaOverlayPlayer;\r\n});\r\n\n",
    "//  Created by Boris Schneiderman.\r\n//  Copyright (c) 2016 Readium Foundation and/or its licensees. All rights reserved.\r\n//  \r\n//  Redistribution and use in source and binary forms, with or without modification, \r\n//  are permitted provided that the following conditions are met:\r\n//  1. Redistributions of source code must retain the above copyright notice, this \r\n//  list of conditions and the following disclaimer.\r\n//  2. Redistributions in binary form must reproduce the above copyright notice, \r\n//  this list of conditions and the following disclaimer in the documentation and/or \r\n//  other materials provided with the distribution.\r\n//  3. Neither the name of the organization nor the names of its contributors may be \r\n//  used to endorse or promote products derived from this software without specific \r\n//  prior written permission.\r\n//  \r\n//  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND \r\n//  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED \r\n//  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. \r\n//  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, \r\n//  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, \r\n//  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, \r\n//  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF \r\n//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE \r\n//  OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED \r\n//  OF THE POSSIBILITY OF SUCH DAMAGE.\r\n\r\ndefine('readium_shared_js/models/spine',[\"./spine_item\", \"../helpers\", \"URIjs\"], function(SpineItem, Helpers, URI) {\r\n/**\r\n *  Wrapper of the Spine object received from the host application\r\n *\r\n * @class  Models.Spine\r\n * @constructor\r\n * @param {Models.Package} epubPackage Parent package properties \r\n * @param {Object} spineDTO Spine data object, container for spine properties\r\n */\r\nvar Spine = function(epubPackage, spineDTO) {\r\n\r\n    var self = this;\r\n\r\n    /**\r\n     * The collection of spine items\r\n     *\r\n     * @property items\r\n     * @type Array\r\n     */\r\n    this.items = [];\r\n\r\n    /**\r\n     * The page progression direction ltr|rtl|default\r\n     *\r\n     * @property direction\r\n     * @type String\r\n     * @default \"ltr\"\r\n     */\r\n    this.direction = \"ltr\";\r\n\r\n    /**\r\n     * The container for parent package properties\r\n     *\r\n     * @property package  \r\n     * @type Models.Package\r\n     *\r\n     */\r\n    this.package = epubPackage;\r\n\r\n    var _handleLinear = false;\r\n\r\n    /**\r\n     * Sets a flag indicating that the app handles linear spine items\r\n     *\r\n     * @method     handleLinear\r\n     * @param      {Boolean} handleLinear  boolean flag\r\n     */\r\n    this.handleLinear = function(handleLinear) {\r\n        _handleLinear = handleLinear;\r\n    };\r\n\r\n    function isValidLinearItem(item) {\r\n        return !_handleLinear || item.linear !== \"no\";\r\n    }\r\n\r\n    /**\r\n     * Checks if a spine item is linear. \r\n     *\r\n     * @method     isValidLinearItem\r\n     * @param      {Number} index  index of a spine item\r\n     * @return     {Boolean} TRUE if the app does not handle linear items or if the item is linear.\r\n    */\r\n    this.isValidLinearItem = function(index) {\r\n        \r\n        if(!isValidIndex(index)) {\r\n            return undefined;\r\n        }\r\n\r\n        return isValidLinearItem(this.item(index));\r\n    };\r\n\r\n    /**\r\n     * Checks if the page progression direction is right to left.\r\n     *\r\n     * @method     isRightToLeft\r\n     * @return     {Boolean} \r\n     */\r\n    this.isRightToLeft = function() {\r\n\r\n        return self.direction == \"rtl\";\r\n    };\r\n\r\n    /**\r\n     * Checks if the page progression direction is left to right.\r\n     *\r\n     * @method     isLeftToRight\r\n     * @return     {Boolean} TRUE if the direction is not rtl.\r\n     */\r\n    this.isLeftToRight = function() {\r\n\r\n        return !self.isRightToLeft();\r\n    };\r\n\r\n    /**\r\n     * Checks if an spine item index is valid. \r\n     *\r\n     * @method     isValidIndex\r\n     * @param      {Number} index  the index of the expected spine item\r\n     * @return     {Boolean} TRUE is the index is valid.\r\n    */\r\n    function isValidIndex(index) {\r\n\r\n        return index >= 0 && index < self.items.length;\r\n    }\r\n\r\n    function lookForPrevValidItem(ix) {\r\n\r\n        if(!isValidIndex(ix)) {\r\n            return undefined;\r\n        }\r\n\r\n        var item = self.items[ix];\r\n\r\n        if(isValidLinearItem(item)) {\r\n            return item;\r\n        }\r\n\r\n        return lookForPrevValidItem(item.index - 1);\r\n    }\r\n\r\n    /**\r\n     * Looks for the previous spine item. \r\n     *\r\n     * @method     prevItem\r\n     * @param      {Models.SpineItem} item  a spine item\r\n     * @return     {Models.SpineItem} the previous spine item or undefined.\r\n    */\r\n    this.prevItem = function(item) {\r\n\r\n        return lookForPrevValidItem(item.index - 1);\r\n    };\r\n\r\n    function lookForNextValidItem(ix) {\r\n\r\n        if(!isValidIndex(ix)) {\r\n            return undefined;\r\n        }\r\n\r\n        var item = self.items[ix];\r\n\r\n        if(isValidLinearItem(item)) {\r\n            return item;\r\n        }\r\n\r\n        return lookForNextValidItem(item.index + 1);\r\n    }\r\n\r\n    /**\r\n     * Looks for the next spine item. \r\n     *\r\n     * @method     nextItem\r\n     * @param      {Models.SpineItem} item  a spine item\r\n     * @return     {Models.SpineItem} the next spine item or undefined.\r\n    */\r\n    this.nextItem = function(item) {\r\n\r\n        return lookForNextValidItem(item.index + 1);\r\n    };\r\n\r\n    /**\r\n     * Gets the relative URL of a spine item. \r\n     *\r\n     * @method     getItemUrl\r\n     * @param      {Models.SpineItem} item  the spine item\r\n     * @return     {String} the relative URL of the spine item.\r\n    */\r\n    this.getItemUrl = function(item) {\r\n\r\n        return self.package.resolveRelativeUrl(item.href);\r\n\r\n    };\r\n\r\n    /**\r\n     * Returns the first spine item. \r\n     *\r\n     * @method     first\r\n     * @return     {Models.SpineItem} the first spine item.\r\n    */\r\n    this.first = function() {\r\n\r\n        return lookForNextValidItem(0);\r\n    };\r\n\r\n    /**\r\n     * Returns the last spine item. \r\n     *\r\n     * @method     last\r\n     * @return     {Models.SpineItem} the last spine item.\r\n    */\r\n    this.last = function() {\r\n\r\n        return lookForPrevValidItem(this.items.length - 1);\r\n    };\r\n\r\n    /**\r\n     * Checks if a spine item is the first in the spine. \r\n     *\r\n     * @method     isFirstItem\r\n     * @param      {Models.SpineItem} item  a spine item\r\n     * @return     {Boolean} TRUE if the spine item is the first in the list.\r\n    */\r\n    this.isFirstItem = function(item) {\r\n\r\n        return self.first() === item;\r\n    };\r\n\r\n    /**\r\n     * Checks if a spine item is the last in the spine. \r\n     *\r\n     * @method     isLastItem\r\n     * @param      {Models.SpineItem} item  a spine item\r\n     * @return     {Boolean} true if the spine item is the last in the list.\r\n    */\r\n    this.isLastItem = function(item) {\r\n\r\n        return self.last() === item;\r\n    };\r\n\r\n    /**\r\n     * Returns a spine item by its index. \r\n     *\r\n     * @method     item\r\n     * @param      {Number} index  the index of the expected spine item\r\n     * @return     {Models.SpineItem} the expected spine item or undefined.\r\n    */\r\n   this.item = function(index) {\r\n        \r\n        if (isValidIndex(index))\r\n            return self.items[index];\r\n            \r\n        return undefined;\r\n    };\r\n\r\n    /**\r\n     * Returns a spine item by its id.\r\n     *\r\n     * @method     getItemById\r\n     * @param      {Number} idref  the id of the expected spine item\r\n     * @return     {Models.SpineItem} the expected spine item or undefined.\r\n     */\r\n    this.getItemById = function(idref) {\r\n\r\n        var length = self.items.length;\r\n\r\n        for(var i = 0; i < length; i++) {\r\n            if(self.items[i].idref == idref) {\r\n\r\n                return self.items[i];\r\n            }\r\n        }\r\n\r\n        return undefined;\r\n    };\r\n\r\n    /**\r\n     * Returns a spine item by its href.\r\n     *\r\n     * @method     getItemByHref\r\n     * @param      {String} href  the URL of the expected spine item\r\n     * @return     {Models.SpineItem} the expected spine item or undefined.\r\n     */\r\n    this.getItemByHref = function(href) {\r\n        \r\n        var href1 = new URI(self.package.resolveRelativeUrl(href)).normalizePathname().pathname();\r\n        \r\n        var length = self.items.length;\r\n\r\n        for(var i = 0; i < length; i++) {\r\n            \r\n            var href2 = new URI(self.package.resolveRelativeUrl(self.items[i].href)).normalizePathname().pathname();\r\n            \r\n            if(href1 == href2) {\r\n                return self.items[i];\r\n            }\r\n        }\r\n\r\n        return undefined;\r\n    };\r\n\r\n    /**\r\n     * Updates every spine item spread, if not already defined.\r\n     *\r\n     * @method     updateSpineItemsSpread\r\n     */\r\n    function updateSpineItemsSpread() {\r\n\r\n        var len = self.items.length;\r\n\r\n        var isFirstPageInSpread = false;\r\n        var baseSide = self.isLeftToRight() ? SpineItem.SPREAD_LEFT : SpineItem.SPREAD_RIGHT;\r\n\r\n        for(var i = 0; i < len; i++) {\r\n\r\n            var spineItem = self.items[i];\r\n            if( !spineItem.page_spread) {\r\n\r\n                var spread = spineItem.isRenditionSpreadAllowed() ? (isFirstPageInSpread ? baseSide : SpineItem.alternateSpread(baseSide)) : SpineItem.SPREAD_CENTER;\r\n                spineItem.setSpread(spread);\r\n            }\r\n\r\n            isFirstPageInSpread = !spineItem.isRenditionSpreadAllowed() || spineItem.page_spread != baseSide;\r\n        }\r\n    }\r\n\r\n    // initialization of the local 'direction' and 'items' array from the spineDTO structure\r\n    if(spineDTO) {\r\n\r\n        if(spineDTO.direction) {\r\n            this.direction = spineDTO.direction;\r\n        }\r\n\r\n        var length = spineDTO.items.length;\r\n        for(var i = 0; i < length; i++) {\r\n            var item = new SpineItem(spineDTO.items[i], i, this);\r\n            this.items.push(item);\r\n        }\r\n\r\n        updateSpineItemsSpread();\r\n    }\r\n\r\n};\r\n    return Spine;\r\n});\r\n\n",
    "//  LauncherOSX\r\n//\r\n//  Created by Boris Schneiderman.\r\n// Modified by Daniel Weck\r\n//  Copyright (c) 2014 Readium Foundation and/or its licensees. All rights reserved.\r\n//  \r\n//  Redistribution and use in source and binary forms, with or without modification, \r\n//  are permitted provided that the following conditions are met:\r\n//  1. Redistributions of source code must retain the above copyright notice, this \r\n//  list of conditions and the following disclaimer.\r\n//  2. Redistributions in binary form must reproduce the above copyright notice, \r\n//  this list of conditions and the following disclaimer in the documentation and/or \r\n//  other materials provided with the distribution.\r\n//  3. Neither the name of the organization nor the names of its contributors may be \r\n//  used to endorse or promote products derived from this software without specific \r\n//  prior written permission.\r\n//  \r\n//  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND \r\n//  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED \r\n//  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. \r\n//  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, \r\n//  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, \r\n//  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, \r\n//  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF \r\n//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE \r\n//  OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED \r\n//  OF THE POSSIBILITY OF SUCH DAMAGE.\r\ndefine ('readium_shared_js/models/smil_model',[\"../helpers\"], function(Helpers) {\r\n\r\nvar Smil = {};\r\n\r\n/**\r\n * Wrapper of a SmilNode object\r\n *\r\n * @class      Smil.SmilNode\r\n * @constructor\r\n * @param      {Smil.SmilNode} parent Parent node of the new smil node\r\n */\r\n\r\nSmil.SmilNode = function(parent) {\r\n\r\n    this.parent = parent;\r\n    \r\n    this.id = \"\";\r\n    \r\n    /**\r\n     * Finds the smil model object, i.e. the root node of the smil tree\r\n     *\r\n     * @method     getSmil\r\n     * @return     {Smil.SmilModel} node The smil model object\r\n     */    \r\n    this.getSmil = function() {\r\n\r\n        var node = this;\r\n        while(node.parent) {\r\n            node = node.parent;\r\n        }\r\n\r\n        return node;\r\n    };\r\n    /**\r\n     * Checks if the node given as a parameter is an ancestor of the current node \r\n     *\r\n     * @method     hasAncestor\r\n     * @param      {Smil.SmilNode} node The checked node\r\n     * @return     {Bool} true if the parameter node is an ancestor\r\n     */\r\n    this.hasAncestor = function(node)\r\n    {\r\n        var parent = this.parent;\r\n        while(parent)\r\n        {\r\n            if (parent == node)\r\n            {\r\n                return true;\r\n            }\r\n\r\n            parent = parent.parent;\r\n        }\r\n\r\n        return false;\r\n    };\r\n};\r\n\r\n////////////////////////////\r\n//TimeContainerNode\r\n\r\n/**\r\n * Wrapper of a time container (smil) node \r\n *\r\n * @class      Smil.TimeContainerNode\r\n * @constructor\r\n * @param      {Smil.SmilNode} parent Parent smil node\r\n */\r\n\r\nSmil.TimeContainerNode = function(parent) {\r\n\r\n    /**\r\n     * The parent node\r\n     *\r\n     * @property parent\r\n     * @type Smil.SmilNode\r\n     */\r\n    \r\n    this.parent = parent;\r\n    \r\n    /**\r\n     * The children nodes\r\n     *\r\n     * @property children\r\n     * @type undefined\r\n     */\r\n\r\n    this.children = undefined;\r\n    \r\n    /**\r\n     * The index\r\n     *\r\n     * @property index\r\n     * @type undefined\r\n     */\r\n\r\n    this.index = undefined;\r\n    \r\n    /**\r\n     * The epub type\r\n     *\r\n     * @property epubtype\r\n     * @type String\r\n     */\r\n\r\n    this.epubtype = \"\";\r\n\r\n\r\n    /**\r\n     * Checks if the smil node is escapable.\r\n     *\r\n     * @method     isEscapable\r\n     * @param      {Array} userEscapables\r\n     * @return     {Bool} true if the smil node is escapable \r\n     */\r\n\r\n    this.isEscapable = function(userEscapables)\r\n    {\r\n        if (this.epubtype === \"\")\r\n        {\r\n            return false;\r\n        }\r\n\r\n        var smilModel = this.getSmil();\r\n        if (!smilModel.mo)\r\n        {\r\n            return false;\r\n        }\r\n\r\n        var arr = smilModel.mo.escapables;\r\n        if (userEscapables.length > 0)\r\n        {\r\n            arr = userEscapables;\r\n        }\r\n\r\n        for (var i = 0; i < arr.length; i++)\r\n        {\r\n            if (this.epubtype.indexOf(arr[i]) >= 0)\r\n            {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    };\r\n\r\n    /**\r\n     * Checks is the smil node is skippable\r\n     *\r\n     * @method     isSkippables\r\n     * @param      {Array} userSkippables\r\n     * @return     {Bool} true s the smil node is skippable\r\n     */\r\n\r\n    this.isSkippable = function(userSkippables)\r\n    {\r\n        if (this.epubtype === \"\")\r\n        {\r\n            return false;\r\n        }\r\n        \r\n        var smilModel = this.getSmil();\r\n        if (!smilModel.mo)\r\n        {\r\n            return false;\r\n        }\r\n\r\n        var arr = smilModel.mo.skippables;\r\n        if (userSkippables.length > 0)\r\n        {\r\n            arr = userSkippables;\r\n        }\r\n\r\n        for (var i = 0; i < arr.length; i++)\r\n        {\r\n            if (this.epubtype.indexOf(arr[i]) >= 0)\r\n            {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    };\r\n};\r\n\r\nSmil.TimeContainerNode.prototype = new Smil.SmilNode();\r\n\r\n\r\n////////////////////////////\r\n//MediaNode\r\n\r\n/**\r\n * Looks for the media parent folder\r\n *\r\n * @class      Smil.MediaNode\r\n * @constructor\r\n * @param      {Smil.SmilNode} parent Parent smil node\r\n */\r\n\r\nSmil.MediaNode = function(parent) {\r\n\r\n    /**\r\n     * The parent node\r\n     *\r\n     * @property parent\r\n     * @type Smil.SmilNode\r\n     */\r\n\r\n    this.parent = parent;\r\n    \r\n    /**\r\n     * The source locator\r\n     *\r\n     * @property src\r\n     * @type String\r\n     */\r\n\r\n    this.src = \"\";\r\n};\r\n\r\nSmil.MediaNode.prototype = new Smil.SmilNode();\r\n\r\n////////////////////////////\r\n//SeqNode\r\n\r\n/**\r\n * Node Sequence\r\n *\r\n * @class      Smil.SeqNode\r\n * @constructor\r\n * @param      {Smil.SmilNode} parent Parent smil node\r\n */\r\n\r\nSmil.SeqNode = function(parent) {\r\n\r\n    /**\r\n     * The parent node\r\n     *\r\n     * @property parent\r\n     * @type Smil.SmilNode\r\n     */\r\n\r\n    this.parent = parent;\r\n\r\n    /**\r\n     * The children nodes\r\n     *\r\n     * @property children\r\n     * @type Array\r\n     */\r\n\r\n    this.children = [];\r\n\r\n    /**\r\n     * The node type (seq)\r\n     *\r\n     * @property nodeType\r\n     * @type String\r\n     */\r\n\r\n    this.nodeType = \"seq\";\r\n\r\n    /**\r\n     * The text reference\r\n     *\r\n     * @property textref\r\n     * @type String\r\n     */\r\n\r\n    this.textref = \"\";\r\n    \r\n    /**\r\n     * Calculates the total duration of audio clips \r\n     *\r\n     * @method     durationMilliseconds\r\n     * @return     {Number} \r\n     */\r\n\r\n    this.durationMilliseconds = function()\r\n    {\r\n        // returns the smil object\r\n        var smilData = this.getSmil();\r\n\r\n        var total = 0;\r\n        \r\n        for (var i = 0; i < this.children.length; i++)\r\n        {\r\n            var container = this.children[i];\r\n            if (container.nodeType === \"par\")\r\n            {\r\n                if (!container.audio)\r\n                {\r\n                    continue;\r\n                }\r\n                if (container.text && (!container.text.manifestItemId || container.text.manifestItemId != smilData.spineItemId))\r\n                {\r\n                    continue;\r\n                }\r\n                \r\n                var clipDur = container.audio.clipDurationMilliseconds();\r\n                total += clipDur;\r\n            }\r\n            else if (container.nodeType === \"seq\")\r\n            {\r\n                total += container.durationMilliseconds();\r\n            }\r\n        }\r\n\r\n        return total;\r\n    };\r\n    \r\n   /**\r\n     * Looks for a given parallel node in the current sequence node and its children.\r\n     *  Returns true if found. \r\n     *\r\n     * @method     clipOffset\r\n     * @param      {Number} offset\r\n     * @param      {Smil.ParNode} par The reference parallel smil node\r\n     * @return     {Boolean} \r\n     */ \r\n\r\n    this.clipOffset = function(offset, par)\r\n    {\r\n        var smilData = this.getSmil();\r\n        \r\n        for (var i = 0; i < this.children.length; i++)\r\n        {\r\n            var container = this.children[i];\r\n            if (container.nodeType === \"par\")\r\n            {\r\n                if (container == par)\r\n                {\r\n                    return true;\r\n                }\r\n\r\n                if (!container.audio)\r\n                {\r\n                    continue;\r\n                }\r\n\r\n                if (container.text && (!container.text.manifestItemId || container.text.manifestItemId != smilData.spineItemId))\r\n                {\r\n                    continue;\r\n                }\r\n\r\n                var clipDur = container.audio.clipDurationMilliseconds();\r\n                offset.offset += clipDur;\r\n            }\r\n            else if (container.nodeType === \"seq\")\r\n            {\r\n                var found = container.clipOffset(offset, par);\r\n                if (found)\r\n                {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n\r\n        return false;\r\n    };\r\n\r\n\r\n   /**\r\n     * Checks if a parallel smil node exists at a given timecode in the smil sequence node. \r\n     * Returns the node or undefined.\r\n     *\r\n     * @method     parallelAt\r\n     * @param      {Number} timeMilliseconds\r\n     * @return     {Smil.ParNode}\r\n     */ \r\n\r\n    this.parallelAt = function(timeMilliseconds)\r\n    {\r\n        var smilData = this.getSmil();\r\n        \r\n        var offset = 0;\r\n\r\n        for (var i = 0; i < this.children.length; i++)\r\n        {\r\n            var timeAdjusted = timeMilliseconds - offset;\r\n\r\n            var container = this.children[i];\r\n            \r\n            // looks for a winning parallel smil node in a child parallel smil node\r\n            if (container.nodeType === \"par\")\r\n            {\r\n                // the parallel node must contain an audio clip and a text node with a proper id\r\n                if (!container.audio)\r\n                {\r\n                    continue;\r\n                }\r\n\r\n                if (container.text && (!container.text.manifestItemId || container.text.manifestItemId != smilData.spineItemId))\r\n                {\r\n                    continue;\r\n                }\r\n                // and the timecode given as a parameter must correspond to the audio clip time range  \r\n                var clipDur = container.audio.clipDurationMilliseconds();\r\n\r\n                if (clipDur > 0 && timeAdjusted <= clipDur)\r\n                {\r\n                    return container;\r\n                }\r\n\r\n                offset += clipDur;\r\n            }\r\n            // looks for a winning parallel smil node in a child sequence smil node\r\n            else if (container.nodeType === \"seq\")\r\n            {\r\n                var para = container.parallelAt(timeAdjusted);\r\n                if (para)\r\n                {\r\n                    return para;\r\n                }\r\n\r\n                offset += container.durationMilliseconds();\r\n            }\r\n        }\r\n\r\n        return undefined;\r\n    };\r\n\r\n    /**\r\n     * Looks for the nth parallel smil node in the current sequence node\r\n     *\r\n     * @method     nthParallel\r\n     * @param      {Number} index\r\n     * @param      {Number} count\r\n     * @return     {Smil.ParNode} \r\n     */    \r\n\r\n    this.nthParallel = function(index, count)\r\n    {\r\n        for (var i = 0; i < this.children.length; i++)\r\n        {\r\n            var container = this.children[i];\r\n            \r\n            if (container.nodeType === \"par\")\r\n            {\r\n                count.count++;\r\n\r\n                if (count.count == index)\r\n                {\r\n                    return container;\r\n                }\r\n            }\r\n            else if (container.nodeType === \"seq\")\r\n            {\r\n                var para = container.nthParallel(index, count);\r\n                if (para)\r\n                {\r\n                    return para;\r\n                }\r\n            }\r\n        }\r\n\r\n        return undefined;\r\n    };\r\n    \r\n};\r\n\r\nSmil.SeqNode.prototype = new Smil.TimeContainerNode();\r\n\r\n//////////////////////////\r\n//ParNode\r\n\r\n/**\r\n * Returns the parent of the SMIL file by checking out the nodes\r\n *\r\n * @class      Smil.ParNode\r\n * @constructor\r\n * @param      {Smil.SmilNode} parent Parent smil node\r\n\r\n */\r\n\r\nSmil.ParNode = function(parent) {\r\n\r\n    /**\r\n     * The parent node\r\n     *\r\n     * @property parent\r\n     * @type Smil.SmilNode\r\n     */\r\n\r\n    this.parent = parent;\r\n    \r\n    /**\r\n     * The children files\r\n     *\r\n     * @property children\r\n     * @type Array\r\n     */\r\n\r\n    this.children = [];\r\n    \r\n    /**\r\n     * The Node Type\r\n     *\r\n     * @property nodeType which is equal to \"par\" here\r\n     * @type String\r\n     */\r\n\r\n    this.nodeType = \"par\";\r\n\r\n    /**\r\n     * Some text\r\n     *\r\n     * @property text \r\n     * @type String\r\n     */\r\n    this.text = undefined;\r\n    \r\n    /**\r\n     * Some audio\r\n     *\r\n     * @property audio \r\n     * @type unknown\r\n     */\r\n    \r\n    this.audio = undefined;\r\n\r\n    /**\r\n     * An element of the epub archive\r\n     *\r\n     * @property element \r\n     * @type unknown\r\n     */\r\n    \r\n    this.element = undefined;    \r\n\r\n    /**\r\n     * Gets the first ancestor sequence with a given epub type, or undefined.\r\n     *\r\n     * @method     getFirstSeqAncestorWithEpubType\r\n     * @param      {String} epubtype\r\n     * @param      {Boolean} includeSelf\r\n     * @return     {Smil.SmilNode} \r\n     */       \r\n\r\n    this.getFirstSeqAncestorWithEpubType = function(epubtype, includeSelf) {\r\n        if (!epubtype) return undefined;\r\n        \r\n        var parent = includeSelf ? this : this.parent;\r\n        while (parent)\r\n        {\r\n            if (parent.epubtype && parent.epubtype.indexOf(epubtype) >= 0)\r\n            {\r\n                return parent; // assert(parent.nodeType === \"seq\")\r\n            }\r\n            \r\n            parent = parent.parent;\r\n        }\r\n        \r\n        return undefined;\r\n    };\r\n};\r\n\r\nSmil.ParNode.prototype = new Smil.TimeContainerNode();\r\n\r\n//////////////////////////\r\n//TextNode\r\n\r\n/**\r\n * Node Sequence\r\n *\r\n * @class      Smil.TextNode\r\n * @constructor\r\n * @param      {Smil.SmilNode} parent Parent smil node\r\n\r\n */\r\n\r\nSmil.TextNode = function(parent) {\r\n\r\n    /**\r\n     * The parent node\r\n     *\r\n     * @property parent\r\n     * @type Smil.SmilNode\r\n     */\r\n\r\n    this.parent = parent;\r\n\r\n    /**\r\n     * The node type, set to \"text\"\r\n     *\r\n     * @property nodeType\r\n     * @type String \r\n     */\r\n\r\n    this.nodeType = \"text\";\r\n\r\n    /**\r\n     * The source file\r\n     *\r\n     * @property srcFile\r\n     * @type String\r\n     */\r\n    \r\n    this.srcFile = \"\";\r\n    \r\n    /**\r\n     * A fragment of the source file ID\r\n     *\r\n     * @property srcFragmentId\r\n     * @type String\r\n     */\r\n\r\n    this.srcFragmentId = \"\";\r\n    \r\n    /**\r\n     * The ID of the manifest for the current item\r\n     *\r\n     * @property manifestItemId\r\n     * @type Number\r\n     */\r\n    \r\n    this.manifestItemId = undefined;\r\n    \r\n    /**\r\n     * Updates the ID of the manifest for the current media\r\n     *\r\n     * @method     updateMediaManifestItemId \r\n     */  \r\n\r\n    this.updateMediaManifestItemId = function() {\r\n\r\n        var smilData = this.getSmil();\r\n        \r\n        if (!smilData.href || !smilData.href.length)\r\n        {\r\n            return; // Blank MO page placeholder, no real SMIL\r\n        }\r\n        \r\n        // var srcParts = item.src.split('#');\r\n//         item.srcFile = srcParts[0];\r\n//         item.srcFragmentId = (srcParts.length === 2) ? srcParts[1] : \"\";\r\n        \r\n        var src = this.srcFile ? this.srcFile : this.src;\r\n// console.log(\"src: \" + src);\r\n// console.log(\"smilData.href: \" + smilData.href);\r\n        var ref = Helpers.ResolveContentRef(src, smilData.href);\r\n//console.log(\"ref: \" + ref);\r\n        var full = smilData.mo.package.resolveRelativeUrlMO(ref);\r\n// console.log(\"full: \" + full);\r\n// console.log(\"---\");\r\n        for (var j = 0; j < smilData.mo.package.spine.items.length; j++)\r\n        {\r\n            var item = smilData.mo.package.spine.items[j];\r\n//console.log(\"item.href: \" + item.href);\r\n            var url = smilData.mo.package.resolveRelativeUrl(item.href);\r\n//console.log(\"url: \" + url);\r\n            if (url === full)\r\n            {\r\n//console.error(\"FOUND: \" + item.idref);\r\n                this.manifestItemId = item.idref;\r\n                return;\r\n            }\r\n        }\r\n        \r\n        console.error(\"Cannot set the Media ManifestItemId? \" + this.src + \" && \" + smilData.href);\r\n        \r\n//        throw \"BREAK\";\r\n    };\r\n    \r\n};\r\n\r\nSmil.TextNode.prototype = new Smil.MediaNode();\r\n\r\n///////////////////////////\r\n//AudioNode\r\n\r\n/**\r\n * Looks for the media parent folder\r\n *\r\n * @class      Smil.AudioNode\r\n * @constructor\r\n * @param      {Smil.SmilNode} parent Parent smil node\r\n */\r\n\r\nSmil.AudioNode = function(parent) {\r\n\r\n    /**\r\n     * The parent node\r\n     *\r\n     * @property parent\r\n     * @type Smil.SmilNode\r\n     */\r\n\r\n    this.parent = parent;\r\n\r\n    /**\r\n     * The node type, set to \"audio\"\r\n     *\r\n     * @property nodeType \r\n     * @type String\r\n     */\r\n\r\n    this.nodeType = \"audio\";\r\n\r\n    /**\r\n     * The clip begin timecode\r\n     *\r\n     * @property clipBegin \r\n     * @type Number\r\n     */\r\n\r\n    this.clipBegin = 0;\r\n\r\n    /**\r\n     * The max duration of the audio clip which is almost infinite\r\n     *\r\n     * @property MAX \r\n     * @type Number\r\n     */\r\n\r\n    this.MAX = 1234567890.1; //Number.MAX_VALUE - 0.1; //Infinity;\r\n    \r\n    /**\r\n     * The clip end timecode\r\n     *\r\n     * @property clipEnd\r\n     * @type Number\r\n     */\r\n\r\n    this.clipEnd = this.MAX;\r\n    \r\n    /**\r\n     * Returns the duration of the audio clip\r\n     *\r\n     * @method     clipDurationMilliseconds\r\n     * @return     {Number} \r\n     */  \r\n\r\n    this.clipDurationMilliseconds = function()\r\n    {\r\n        var _clipBeginMilliseconds = this.clipBegin * 1000;\r\n        var _clipEndMilliseconds = this.clipEnd * 1000;\r\n        \r\n        if (this.clipEnd >= this.MAX || _clipEndMilliseconds <= _clipBeginMilliseconds)\r\n        {\r\n            return 0;\r\n        }\r\n\r\n        return _clipEndMilliseconds - _clipBeginMilliseconds;\r\n    };  \r\n};\r\n\r\nSmil.AudioNode.prototype = new Smil.MediaNode();\r\n\r\n//////////////////////////////\r\n//SmilModel\r\n\r\n/**\r\n * Wrapper of the SmilModel object\r\n *\r\n * @class      Models.SmilModel\r\n * @constructor\r\n */\r\n\r\nvar SmilModel = function() {\r\n\r\n    /**\r\n     * The parent object\r\n     *\r\n     * @property parent\r\n     * @type any\r\n     */\r\n\r\n    this.parent = undefined;\r\n    \r\n    /**\r\n     * The smil model children, i.e. a collection of seq or par smil nodes\r\n     *\r\n     * @property children\r\n     * @type Array\r\n     */\r\n    \r\n    this.children = []; \r\n    \r\n    /**\r\n     * The manifest item ID\r\n     *\r\n     * @property id\r\n     * @type Number\r\n     */\r\n\r\n    this.id = undefined; \r\n\r\n    /**\r\n     * The href of the .smil source file\r\n     *\r\n     * @property href\r\n     * @type String\r\n     */\r\n\r\n    this.href = undefined; \r\n    \r\n    /**\r\n     * The duration of the audio clips\r\n     *\r\n     * @property duration\r\n     * @type Number\r\n     */\r\n\r\n    this.duration = undefined;\r\n\r\n    /**\r\n     * The media overlay object\r\n     *\r\n     * @property mo\r\n     * @type Models.MediaOverlay\r\n     */\r\n\r\n    this.mo = undefined;\r\n\r\n    /**\r\n     * Checks if a parallel smil node exists at a given timecode in the smil model. \r\n     * Returns the node or undefined.\r\n     *\r\n     * @method     parallelAt\r\n     * @param      {Number} timeMillisecond \r\n     * @return     {Smil.ParNode}\r\n     */\r\n    \r\n    this.parallelAt = function(timeMilliseconds)\r\n    {\r\n        return this.children[0].parallelAt(timeMilliseconds);\r\n    };\r\n\r\n    /**\r\n     * Looks for the nth parallel smil node in the current smil model\r\n     *\r\n     * @method     nthParallel\r\n     * @param      {Number} index\r\n     * @return     {Smil.ParNode} \r\n     */\r\n\r\n    this.nthParallel = function(index)\r\n    {\r\n        var count = {count: -1};\r\n        return this.children[0].nthParallel(index, count);\r\n    };\r\n\r\n    /**\r\n     * Looks for a given parallel node in the current smil model.\r\n     *  Returns its offset if found. \r\n     *\r\n     * @method     clipOffset\r\n     * @param      {Smil.ParNode} par The reference parallel smil node\r\n     * @return     {Number} offset of the audio clip\r\n     */\r\n\r\n    this.clipOffset = function(par)\r\n    {\r\n        var offset = {offset: 0};\r\n        if (this.children[0].clipOffset(offset, par))\r\n        {\r\n            return offset.offset;\r\n        }\r\n\r\n        return 0;\r\n    };\r\n\r\n    /**\r\n     * Calculates the total audio duration of the smil model\r\n     *\r\n     * @method     durationMilliseconds_Calculated    \r\n     * @return     {Number}\r\n     */\r\n\r\n    this.durationMilliseconds_Calculated = function()\r\n    {\r\n        return this.children[0].durationMilliseconds();\r\n    };\r\n    \r\n\r\n    var _epubtypeSyncs = [];\r\n    // \r\n    // this.clearSyncs = function()\r\n    // {\r\n    //     _epubtypeSyncs = [];\r\n    // };\r\n\r\n    // local function, helper\r\n    this.hasSync = function(epubtype)\r\n    {\r\n        for (var i = 0; i < _epubtypeSyncs.length; i++)\r\n        {\r\n            if (_epubtypeSyncs[i] === epubtype)\r\n            {\r\n                return true;\r\n            }\r\n        }\r\n        \r\n        return false;\r\n    };\r\n\r\n    /**\r\n     * Stores epub types given as parameters in the _epubtypeSyncs array\r\n     * Note: any use of the _epubtypeSyncs array?\r\n     *\r\n     * @method     addSync\r\n     * @param      {String} epubtypes    \r\n     */\r\n\r\n    this.addSync = function(epubtypes)\r\n    {\r\n        if (!epubtypes) return;\r\n\r\n        var parts = epubtypes.split(' ');\r\n        for (var i = 0; i < parts.length; i++)\r\n        {\r\n            var epubtype = parts[i].trim();\r\n\r\n            if (epubtype.length > 0 && !this.hasSync(epubtype))\r\n            {\r\n                _epubtypeSyncs.push(epubtype);\r\n            }\r\n        }\r\n    };\r\n    \r\n};\r\n\r\n/**\r\n * Static SmilModel.fromSmilDTO method, returns a clean SmilModel object\r\n *\r\n * @method      Model.fromSmilDTO\r\n * @param      {string} smilDTO\r\n * @param      {string} parent\r\n * @return {Models.SmilModel}\r\n*/\r\n\r\nSmilModel.fromSmilDTO = function(smilDTO, mo) {\r\n\r\n    if (mo.DEBUG)\r\n    {\r\n        console.debug(\"Media Overlay DTO import...\");\r\n    }\r\n\r\n    // Debug level indenting function\r\n    var indent = 0;\r\n    var getIndent = function()\r\n    {\r\n        var str = \"\";\r\n        for (var i = 0; i < indent; i++)\r\n        {\r\n            str += \"   \";\r\n        }\r\n        return str;\r\n    }\r\n\r\n    var smilModel = new SmilModel();\r\n    smilModel.id = smilDTO.id;\r\n    smilModel.spineItemId = smilDTO.spineItemId;\r\n    smilModel.href = smilDTO.href;\r\n    \r\n    smilModel.smilVersion = smilDTO.smilVersion;\r\n    \r\n    smilModel.duration = smilDTO.duration;\r\n    if (smilModel.duration && smilModel.duration.length && smilModel.duration.length > 0)\r\n    {\r\n        console.error(\"SMIL duration is string, parsing float... (\" + smilModel.duration + \")\");\r\n        smilModel.duration = parseFloat(smilModel.duration);\r\n    }\r\n    \r\n    smilModel.mo = mo; //Models.MediaOverlay\r\n\r\n    if (smilModel.mo.DEBUG)\r\n    {\r\n        console.log(\"JS MO smilVersion=\" + smilModel.smilVersion);\r\n        console.log(\"JS MO id=\" + smilModel.id);\r\n        console.log(\"JS MO spineItemId=\" + smilModel.spineItemId);\r\n        console.log(\"JS MO href=\" + smilModel.href);\r\n        console.log(\"JS MO duration=\" + smilModel.duration);\r\n    }\r\n\r\n    // Safe copy, helper function\r\n    var safeCopyProperty = function(property, from, to, isRequired) {\r\n\r\n        if((property in from))\r\n        { // && from[property] !== \"\"\r\n\r\n            if( !(property in to) ) {\r\n                console.debug(\"property \" + property + \" not declared in smil node \" + to.nodeType);\r\n            }\r\n\r\n            to[property] = from[property];\r\n\r\n            if (smilModel.mo.DEBUG)\r\n            {\r\n            console.log(getIndent() + \"JS MO: [\" + property + \"=\" + to[property] + \"]\");\r\n            }\r\n        }\r\n        else if(isRequired) {\r\n            console.log(\"Required property \" + property + \" not found in smil node \" + from.nodeType);\r\n        }\r\n    };\r\n\r\n    // smil node creation, helper function\r\n    var createNodeFromDTO = function(nodeDTO, parent) {\r\n\r\n        var node;\r\n\r\n        if(nodeDTO.nodeType == \"seq\") {\r\n\r\n            if (smilModel.mo.DEBUG)\r\n            {\r\n            console.log(getIndent() + \"JS MO seq\");\r\n            }\r\n\r\n            node = new Smil.SeqNode(parent);\r\n\r\n            safeCopyProperty(\"textref\", nodeDTO, node, ((parent && parent.parent) ? true : false));\r\n            safeCopyProperty(\"id\", nodeDTO, node);\r\n            safeCopyProperty(\"epubtype\", nodeDTO, node);\r\n\r\n            if (node.epubtype)\r\n            {\r\n                node.getSmil().addSync(node.epubtype);\r\n            }\r\n            \r\n            indent++;\r\n            copyChildren(nodeDTO, node);\r\n            indent--;\r\n        }\r\n        else if (nodeDTO.nodeType == \"par\") {\r\n\r\n            if (smilModel.mo.DEBUG)\r\n            {\r\n            console.log(getIndent() + \"JS MO par\");\r\n            }\r\n\r\n            node = new Smil.ParNode(parent);\r\n\r\n            safeCopyProperty(\"id\", nodeDTO, node);\r\n            safeCopyProperty(\"epubtype\", nodeDTO, node);\r\n\r\n            if (node.epubtype)\r\n            {\r\n                node.getSmil().addSync(node.epubtype);\r\n            }\r\n\r\n            indent++;\r\n            copyChildren(nodeDTO, node);\r\n            indent--;\r\n            \r\n            for(var i = 0, count = node.children.length; i < count; i++) {\r\n                var child = node.children[i];\r\n\r\n                if(child.nodeType == \"text\") {\r\n                    node.text = child;\r\n                }\r\n                else if(child.nodeType == \"audio\") {\r\n                    node.audio = child;\r\n                }\r\n                else {\r\n                    console.error(\"Unexpected smil node type: \" + child.nodeType);\r\n                }\r\n            }\r\n\r\n            ////////////////\r\n            var forceTTS = false; // for testing only!\r\n            ////////////////\r\n\r\n            if (forceTTS || !node.audio)\r\n            {\r\n                // synthetic speech (playback using TTS engine), or embedded media, or blank page\r\n                var fakeAudio = new Smil.AudioNode(node);\r\n\r\n                fakeAudio.clipBegin = 0;\r\n                fakeAudio.clipEnd = fakeAudio.MAX;\r\n                fakeAudio.src = undefined;\r\n\r\n                node.audio = fakeAudio;\r\n            }\r\n        }\r\n        else if (nodeDTO.nodeType == \"text\") {\r\n\r\n            if (smilModel.mo.DEBUG)\r\n            {\r\n            console.log(getIndent() + \"JS MO text\");\r\n            }\r\n\r\n            node = new Smil.TextNode(parent);\r\n\r\n            safeCopyProperty(\"src\", nodeDTO, node, true);\r\n            safeCopyProperty(\"srcFile\", nodeDTO, node, true);\r\n            safeCopyProperty(\"srcFragmentId\", nodeDTO, node, false);\r\n            safeCopyProperty(\"id\", nodeDTO, node);\r\n            \r\n            node.updateMediaManifestItemId();\r\n        }\r\n        else if (nodeDTO.nodeType == \"audio\") {\r\n\r\n            if (smilModel.mo.DEBUG)\r\n            {\r\n            console.log(getIndent() + \"JS MO audio\");\r\n            }\r\n\r\n            node = new Smil.AudioNode(parent);\r\n\r\n            safeCopyProperty(\"src\", nodeDTO, node, true);\r\n            safeCopyProperty(\"id\", nodeDTO, node);\r\n\r\n            safeCopyProperty(\"clipBegin\", nodeDTO, node);\r\n            if (node.clipBegin && node.clipBegin.length && node.clipBegin.length > 0)\r\n            {\r\n                console.error(\"SMIL clipBegin is string, parsing float... (\" + node.clipBegin + \")\");\r\n                node.clipBegin = parseFloat(node.clipBegin);\r\n            }\r\n            if (node.clipBegin < 0)\r\n            {\r\n                if (smilModel.mo.DEBUG)\r\n                {\r\n                    console.log(getIndent() + \"JS MO clipBegin adjusted to ZERO\");\r\n                }\r\n                node.clipBegin = 0;\r\n            }\r\n\r\n            safeCopyProperty(\"clipEnd\", nodeDTO, node);\r\n            if (node.clipEnd && node.clipEnd.length && node.clipEnd.length > 0)\r\n            {\r\n                console.error(\"SMIL clipEnd is string, parsing float... (\" + node.clipEnd + \")\");\r\n                node.clipEnd = parseFloat(node.clipEnd);\r\n            }\r\n            if (node.clipEnd <= node.clipBegin)\r\n            {\r\n                if (smilModel.mo.DEBUG)\r\n                {\r\n                    console.log(getIndent() + \"JS MO clipEnd adjusted to MAX\");\r\n                }\r\n                node.clipEnd = node.MAX;\r\n            }\r\n            \r\n            //node.updateMediaManifestItemId(); ONLY XHTML SPINE ITEMS \r\n        }\r\n        else {\r\n            console.error(\"Unexpected smil node type: \" + nodeDTO.nodeType);\r\n            return undefined;\r\n        }\r\n\r\n        return node;\r\n\r\n    };\r\n\r\n    // recursive copy of a tree, helper function\r\n    var copyChildren = function(from, to) {\r\n\r\n        var count = from.children.length;\r\n\r\n        for(var i = 0; i < count; i++) {\r\n            var node = createNodeFromDTO(from.children[i], to);\r\n            node.index = i;\r\n            to.children.push(node);\r\n        }\r\n\r\n    };\r\n\r\n    copyChildren(smilDTO, smilModel);\r\n\r\n    return smilModel;\r\n\r\n};\r\n\r\nreturn SmilModel;\r\n});\r\n\n",
    "//  LauncherOSX\r\n//\r\n//  Created by Boris Schneiderman.\r\n// Modified by Daniel Weck\r\n//  Copyright (c) 2014 Readium Foundation and/or its licensees. All rights reserved.\r\n//  \r\n//  Redistribution and use in source and binary forms, with or without modification, \r\n//  are permitted provided that the following conditions are met:\r\n//  1. Redistributions of source code must retain the above copyright notice, this \r\n//  list of conditions and the following disclaimer.\r\n//  2. Redistributions in binary form must reproduce the above copyright notice, \r\n//  this list of conditions and the following disclaimer in the documentation and/or \r\n//  other materials provided with the distribution.\r\n//  3. Neither the name of the organization nor the names of its contributors may be \r\n//  used to endorse or promote products derived from this software without specific \r\n//  prior written permission.\r\n//  \r\n//  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND \r\n//  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED \r\n//  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. \r\n//  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, \r\n//  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, \r\n//  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, \r\n//  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF \r\n//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE \r\n//  OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED \r\n//  OF THE POSSIBILITY OF SUCH DAMAGE.\r\n\r\ndefine('readium_shared_js/models/media_overlay',[\"./smil_model\"], function(SmilModel) {\r\n\r\n/**\r\n * Wrapper of the MediaOverlay object\r\n *\r\n * @class Models.MediaOverlay\r\n * @constructor\r\n * @param {Models.Package} package EPUB package\r\n*/\r\n\r\nvar MediaOverlay = function(package) {\r\n\r\n    /**\r\n     * The parent package object\r\n     *\r\n     * @property package\r\n     * @type Models.Package\r\n     */    \r\n    this.package = package;\r\n\r\n    /**\r\n     * Checks if a parallel smil node exists at a given timecode. \r\n     * Returns the first corresponding node found in a smil model found, or undefined.\r\n     *\r\n     * @method     parallelAt\r\n     * @param      {number} timeMilliseconds\r\n     * @return     {Smil.ParNode}  \r\n     */\r\n\r\n    this.parallelAt = function(timeMilliseconds)\r\n    {\r\n        var offset = 0;\r\n        \r\n        for (var i = 0; i < this.smil_models.length; i++)\r\n        {\r\n            var smilData = this.smil_models[i];\r\n            \r\n            var timeAdjusted = timeMilliseconds - offset;\r\n\r\n            var para = smilData.parallelAt(timeAdjusted);\r\n            if (para)\r\n            {\r\n                return para;\r\n            }\r\n\r\n            offset += smilData.durationMilliseconds_Calculated();\r\n        }\r\n\r\n        return undefined;\r\n    };\r\n    \r\n    /**\r\n     * Calculates a timecode corresponding to a percent of the total audio duration (the function parameters smilData, par, and milliseconds are objects with a single field using the same name)\r\n     *\r\n     * @method     percentToPosition\r\n     * @param      {Number} percent\r\n     * @param      {Models.SmilModel} smilData (object with a single field using the same name, used as OUT param)\r\n     * @param      {Smil.ParNode} par (object with a single field using the same name, used as OUT param)\r\n     * @param      {Number} milliseconds (object with a single field using the same name, used as OUT param)\r\n     */\r\n\r\n    this.percentToPosition = function(percent, smilData, par, milliseconds)\r\n    {\r\n        if (percent < 0.0 || percent > 100.0)\r\n        {\r\n            percent = 0.0;\r\n        }\r\n            \r\n        var total = this.durationMilliseconds_Calculated();\r\n\r\n        var timeMs = total * (percent / 100.0);\r\n\r\n        par.par = this.parallelAt(timeMs);\r\n        if (!par.par)\r\n        {\r\n            return;\r\n        }\r\n        \r\n        var smilDataPar = par.par.getSmil();\r\n        if (!smilDataPar)\r\n        {\r\n            return;\r\n        }\r\n        \r\n        var smilDataOffset = 0;\r\n        \r\n        for (var i = 0; i < this.smil_models.length; i++)\r\n        {\r\n            smilData.smilData = this.smil_models[i];\r\n            if (smilData.smilData == smilDataPar)\r\n            {\r\n                break;\r\n            }\r\n            smilDataOffset += smilData.smilData.durationMilliseconds_Calculated();\r\n        }\r\n\r\n        milliseconds.milliseconds = timeMs - (smilDataOffset + smilData.smilData.clipOffset(par.par));\r\n    };\r\n\r\n    /**\r\n     * Calculates the accumulated audio duration of each smil overlay\r\n     *\r\n     * @method     durationMilliseconds_Calculated\r\n     * @return     {Number} total duration \r\n     */\r\n\r\n    this.durationMilliseconds_Calculated = function()\r\n    {\r\n        var total = 0;\r\n        \r\n        for (var i = 0; i < this.smil_models.length; i++)\r\n        {\r\n            var smilData = this.smil_models[i];\r\n\r\n            total += smilData.durationMilliseconds_Calculated();\r\n        }\r\n        \r\n        return total;\r\n    };\r\n    \r\n    /**\r\n     * Returns the smil overlay at the given index\r\n     *\r\n     * @method     smilAt\r\n     * @param      {Number} smilIndex\r\n     * @return     {Models.SmilModel}\r\n     */\r\n\r\n    this.smilAt = function(smilIndex)\r\n    {\r\n        if (smilIndex < 0 || smilIndex >= this.smil_models.length)\r\n        {\r\n            return undefined;\r\n        }\r\n        \r\n        return this.smil_models[smilIndex];\r\n    }\r\n    \r\n    /**\r\n     * Calculates a percent of the total audio duration corresponding to a timecode\r\n     * \r\n     * @method     positionToPercent\r\n     * @param      {Number} smilIndex Index of a smil model\r\n     * @param      {Number} parIndex\r\n     * @param      {Number} milliseconds\r\n     * @return     {Number} percent \r\n     */\r\n\r\n    this.positionToPercent = function(smilIndex, parIndex, milliseconds)\r\n    {\r\n           \r\n        if (smilIndex >= this.smil_models.length)\r\n        {\r\n            return -1.0;\r\n        }\r\n\r\n        var smilDataOffset = 0;\r\n        for (var i = 0; i < smilIndex; i++)\r\n        {\r\n            var sd = this.smil_models[i];\r\n            smilDataOffset += sd.durationMilliseconds_Calculated();\r\n        }\r\n        \r\n        var smilData = this.smil_models[smilIndex];\r\n\r\n        var par = smilData.nthParallel(parIndex);\r\n        if (!par)\r\n        {\r\n            return -1.0;\r\n        }\r\n\r\n        var offset = smilDataOffset + smilData.clipOffset(par) + milliseconds;\r\n        \r\n        var total = this.durationMilliseconds_Calculated();\r\n\r\n        var percent = (offset / total) * 100;\r\n        \r\n        return percent;\r\n      };\r\n\r\n    /**\r\n     * Array of smil models {Models.SmilModel}\r\n     *\r\n     * @property smil_models\r\n     * @type Array\r\n     */\r\n\r\n    this.smil_models = [];\r\n\r\n    /**\r\n     * List of the skippable smil items\r\n     *\r\n     * @property skippables\r\n     * @type Array\r\n     */\r\n\r\n    this.skippables = [];\r\n    \r\n    /**\r\n     * List of the escapable smil items\r\n     *\r\n     * @property escapables\r\n     * @type Array\r\n     */\r\n\r\n    this.escapables = [];\r\n\r\n    /**\r\n     * Duration of the smil audio\r\n     *\r\n     * @property duration\r\n     * @type Number\r\n     */\r\n\r\n    this.duration = undefined;\r\n\r\n    /**\r\n     * Narrator\r\n     *\r\n     * @property narrator\r\n     * @type String\r\n     */\r\n\r\n    this.narrator = undefined;\r\n\r\n    /**\r\n     * Author-defined name of the CSS \"active class\" (applied to the document as a whole)\r\n     *\r\n     * @property activeClass\r\n     * @type String\r\n     */\r\n\r\n    this.activeClass = undefined;\r\n\r\n    /**\r\n     * Author-defined name of the CSS \"playback active class\" (applied to a single audio fragment)\r\n     *\r\n     * @property playbackActiveClass\r\n     * @type String\r\n     */\r\n\r\n    this.playbackActiveClass = undefined;\r\n\r\n    // Debug messages, must be false in production!\r\n    this.DEBUG = false;\r\n\r\n    /**\r\n     * Returns the smil model corresponding to a spine item, or undefined if not found.\r\n     *\r\n     * @method     getSmilBySpineItem\r\n     * @param      {Models.SpineItem} spineItem\r\n     * @return     {Models.SmilModel} \r\n     */\r\n\r\n    this.getSmilBySpineItem = function (spineItem) {\r\n        if (!spineItem) return undefined;\r\n\r\n        for(var i = 0, count = this.smil_models.length; i < count; i++)\r\n        {\r\n            var smil = this.smil_models[i];\r\n            if(smil.spineItemId === spineItem.idref) {\r\n                if (spineItem.media_overlay_id !== smil.id)\r\n                {\r\n                    console.error(\"SMIL INCORRECT ID?? \" + spineItem.media_overlay_id + \" /// \" + smil.id);\r\n                }\r\n                return smil;\r\n            }\r\n        }\r\n\r\n        return undefined;\r\n    };\r\n\r\n    /*\r\n    this.getSmilById = function (id) {\r\n\r\n        for(var i = 0, count = this.smil_models.length; i < count; i++) {\r\n\r\n            var smil = this.smil_models[i];\r\n            if(smil.id === id) {\r\n                return smil;\r\n            }\r\n        }\r\n\r\n        return undefined;\r\n    };\r\n    */\r\n\r\n    /**\r\n     * Returns the next smil model\r\n     *\r\n     * @method     getNextSmil\r\n     * @param      {Models.SmilModel} smil The current smil model\r\n     * @return     {Models.SmilModel} \r\n     */\r\n\r\n    this.getNextSmil = function(smil) {\r\n\r\n        var index = this.smil_models.indexOf(smil);\r\n        if(index == -1 || index == this.smil_models.length - 1) {\r\n            return undefined;\r\n        }\r\n\r\n        return this.smil_models[index + 1];\r\n    }\r\n\r\n    /**\r\n     * Returns the previous smil model\r\n     *\r\n     * @method     getPreviousSmil\r\n     * @param      {Models.SmilModel} smil The current smil model\r\n     * @return     {Models.SmilModel} \r\n     */\r\n\r\n    this.getPreviousSmil = function(smil) {\r\n\r\n        var index = this.smil_models.indexOf(smil);\r\n        if(index == -1 || index == 0) {\r\n            return undefined;\r\n        }\r\n\r\n        return this.smil_models[index - 1];\r\n    }\r\n};\r\n\r\n/**\r\n * Static MediaOverlay.fromDTO method, returns a clean MediaOverlay object\r\n *\r\n * @method MediaOverlay.fromDTO\r\n * @param {Object} moDTO Media overlay data object (raw JSON, as returned by a parser)\r\n * @param {Models.Package} package EPUB package object\r\n * @return {Models.MediaOverlay}\r\n*/\r\n\r\nMediaOverlay.fromDTO = function(moDTO, pack) {\r\n\r\n    var mo = new MediaOverlay(pack);\r\n\r\n    if(!moDTO) {\r\n        return mo;\r\n    }\r\n\r\n    mo.duration = moDTO.duration;\r\n    if (mo.duration && mo.duration.length && mo.duration.length > 0)\r\n    {\r\n        console.error(\"SMIL total duration is string, parsing float... (\" + mo.duration + \")\");\r\n        mo.duration = parseFloat(mo.duration);\r\n    }\r\n    if (mo.DEBUG)\r\n        console.debug(\"Media Overlay Duration (TOTAL): \" + mo.duration);\r\n\r\n    mo.narrator = moDTO.narrator;\r\n    if (mo.DEBUG)\r\n        console.debug(\"Media Overlay Narrator: \" + mo.narrator);\r\n\r\n    mo.activeClass = moDTO.activeClass;\r\n    if (mo.DEBUG)\r\n        console.debug(\"Media Overlay Active-Class: \" + mo.activeClass);\r\n\r\n    mo.playbackActiveClass = moDTO.playbackActiveClass;\r\n    if (mo.DEBUG)\r\n        console.debug(\"Media Overlay Playback-Active-Class: \" + mo.playbackActiveClass);\r\n\r\n    var count = moDTO.smil_models.length;\r\n    if (mo.DEBUG)\r\n        console.debug(\"Media Overlay SMIL count: \" + count);\r\n\r\n    for(var i = 0; i < count; i++) {\r\n        var smilModel = SmilModel.fromSmilDTO(moDTO.smil_models[i], mo);\r\n        mo.smil_models.push(smilModel);\r\n\r\n        if (mo.DEBUG)\r\n            console.debug(\"Media Overlay Duration (SPINE ITEM): \" + smilModel.duration);\r\n    }\r\n\r\n    count = moDTO.skippables.length;\r\n    if (mo.DEBUG)\r\n        console.debug(\"Media Overlay SKIPPABLES count: \" + count);\r\n\r\n    for(var i = 0; i < count; i++) {\r\n        mo.skippables.push(moDTO.skippables[i]);\r\n    }\r\n\r\n    count = moDTO.escapables.length;\r\n    if (mo.DEBUG)\r\n        console.debug(\"Media Overlay ESCAPABLES count: \" + count);\r\n\r\n    for(var i = 0; i < count; i++) {\r\n        mo.escapables.push(moDTO.escapables[i]);\r\n\r\n    }\r\n\r\n    return mo;\r\n};\r\n\r\nreturn MediaOverlay;\r\n});\r\n\r\n\r\n\n",
    "//  Created by Boris Schneiderman.\r\n//  Copyright (c) 2016 Readium Foundation and/or its licensees. All rights reserved.\r\n//  \r\n//  Redistribution and use in source and binary forms, with or without modification, \r\n//  are permitted provided that the following conditions are met:\r\n//  1. Redistributions of source code must retain the above copyright notice, this \r\n//  list of conditions and the following disclaimer.\r\n//  2. Redistributions in binary form must reproduce the above copyright notice, \r\n//  this list of conditions and the following disclaimer in the documentation and/or \r\n//  other materials provided with the distribution.\r\n//  3. Neither the name of the organization nor the names of its contributors may be \r\n//  used to endorse or promote products derived from this software without specific \r\n//  prior written permission.\r\n//  \r\n//  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND \r\n//  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED \r\n//  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. \r\n//  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, \r\n//  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, \r\n//  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, \r\n//  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF \r\n//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE \r\n//  OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED \r\n//  OF THE POSSIBILITY OF SUCH DAMAGE.\r\n\r\n\r\ndefine('readium_shared_js/models/package_data',[],function() {\r\n/**\r\n * This object is not instantiated directly but provided by the host application to the DOMAccess layer in the\r\n * Views.ReaderView.OpenBookData function\r\n *\r\n * Provided for reference only\r\n *\r\n * @class Models.PackageData\r\n */\r\nvar PackageData = {\r\n\r\n    /**\r\n     * The Url of the package file\r\n     *\r\n     * @property rootUrl \r\n     * @type {String}\r\n     *\r\n     */\r\n    rootUrl: \"\",\r\n    /**\r\n     * The Url of the package file, to prefix Media Overlays SMIL audio references\r\n     *\r\n     * @property rootUrlMO \r\n     * @type {String}\r\n     *\r\n     */\r\n    rootUrlMO: \"\",\r\n    /**\r\n     * The rendering layout; expected values are \"reflowable\"|\"pre-paginated\"\r\n     *\r\n     * @property rendering_layout \r\n     * @type {String}\r\n     */\r\n    rendering_layout: \"\",\r\n\r\n    /**\r\n     * The spine properties\r\n     *\r\n     * @property spine \r\n     * @type {Object}\r\n     */\r\n    spine: {\r\n\r\n        direction: \"ltr\",\r\n        items: [\r\n            {\r\n                href:\"\",\r\n                idref:\"\",\r\n                page_spread:\"\", //\"page-spread-left\"|\"page-spread-right\"|\"page-spread-center\"\r\n                rendering_layout:\"\" //\"reflowable\"|\"pre-paginated\"\r\n            }\r\n        ]\r\n    }\r\n};\r\n\r\nreturn PackageData;\r\n});\n",
    "//  Created by Boris Schneiderman.\r\n//  Copyright (c) 2016 Readium Foundation and/or its licensees. All rights reserved.\r\n//  \r\n//  Redistribution and use in source and binary forms, with or without modification, \r\n//  are permitted provided that the following conditions are met:\r\n//  1. Redistributions of source code must retain the above copyright notice, this \r\n//  list of conditions and the following disclaimer.\r\n//  2. Redistributions in binary form must reproduce the above copyright notice, \r\n//  this list of conditions and the following disclaimer in the documentation and/or \r\n//  other materials provided with the distribution.\r\n//  3. Neither the name of the organization nor the names of its contributors may be \r\n//  used to endorse or promote products derived from this software without specific \r\n//  prior written permission.\r\n//  \r\n//  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND \r\n//  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED \r\n//  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. \r\n//  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, \r\n//  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, \r\n//  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, \r\n//  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF \r\n//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE \r\n//  OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED \r\n//  OF THE POSSIBILITY OF SUCH DAMAGE.\r\ndefine('readium_shared_js/models/package',['../helpers','./spine_item','./spine','./media_overlay', './package_data', 'URIjs'], function (Helpers, SpineItem, Spine, MediaOverlay, PackageData, URI) {\r\n\r\n/**\r\n *  Wrapper of the Package object, created in openBook()\r\n *\r\n * @class  Models.Package\r\n * @constructor\r\n * @param {Models.PackageData} packageData container for package properties \r\n */\r\nvar Package = function(packageData){\r\n\r\n    var self = this;\r\n    \r\n    /**\r\n     * The associated spine object\r\n     *\r\n     * @property spine\r\n     * @type     Models.Spine\r\n     */\r\n    this.spine = undefined;\r\n\r\n    /**\r\n     * The root URL of the package file\r\n     *\r\n     * @property rootUrl\r\n     * @type     String\r\n     */\r\n    this.rootUrl = undefined;\r\n\r\n    /**\r\n     * The root URL of the package file, to prefix Media Overlays SMIL audio references\r\n     *\r\n     * @property rootUrlMO \r\n     * @type     String\r\n     *\r\n     */\r\n    this.rootUrlMO = undefined;\r\n \r\n    /**\r\n     * The Media Overlays object\r\n     *\r\n     * @property media_overlay \r\n     * @type     Models.MediaOverlay\r\n     *\r\n     */   \r\n    this.media_overlay = undefined;\r\n    \r\n    /**\r\n     * The rendition viewport (as per the EPUB3 specification)\r\n     *\r\n     * @property rendition_viewport \r\n     * @type     String\r\n     *\r\n     */   \r\n    this.rendition_viewport = undefined;\r\n    \r\n    /**\r\n     * The rendition flow (as per the EPUB3 specification)\r\n     *\r\n     * @property rendition_flow \r\n     * @type     String\r\n     *\r\n     */   \r\n    this.rendition_flow = undefined;\r\n    \r\n    /**\r\n     * The rendition layout (as per the EPUB3 specification)\r\n     *\r\n     * @property rendition_layout \r\n     * @type     String\r\n     *\r\n     */   \r\n    this.rendition_layout = undefined;\r\n\r\n    /**\r\n     * The rendition spread (as per the EPUB3 specification)\r\n     *\r\n     * @property rendition_spread \r\n     * @type     String\r\n     *\r\n     */   \r\n    this.rendition_spread = undefined;\r\n\r\n    /**\r\n     * The rendition orientation (as per the EPUB3 specification)\r\n     *\r\n     * @property rendition_orientation \r\n     * @type     String\r\n     *\r\n     */   \r\n    this.rendition_orientation = undefined;\r\n\r\n    /**\r\n     * Returns a resolved relative Url, Media Overlay variant.\r\n     *\r\n     * @method     resolveRelativeUrlMO\r\n     * @param      {String} relativeUrl  the relative URL to resolve\r\n     * @return     {String} the resolved relative URL.\r\n     */\r\n    this.resolveRelativeUrlMO = function(relativeUrl) {\r\n        \r\n        var relativeUrlUri = undefined;\r\n        try {\r\n            relativeUrlUri = new URI(relativeUrl);\r\n        } catch(err) {\r\n            console.error(err);\r\n            console.log(relativeUrl);\r\n        }\r\n        if (relativeUrlUri && relativeUrlUri.is(\"absolute\")) return relativeUrl; //relativeUrlUri.scheme() == \"http://\", \"https://\", \"data:\", etc.\r\n\r\n\r\n        if(self.rootUrlMO && self.rootUrlMO.length > 0) {\r\n\r\n            var url = self.rootUrlMO;\r\n            \r\n            try {\r\n                //url = new URI(relativeUrl).absoluteTo(url).search('').hash('').toString();\r\n                url = new URI(url).search('').hash('').toString();\r\n            } catch(err) {\r\n                console.error(err);\r\n                console.log(url);\r\n            }\r\n            \r\n            if(Helpers.EndsWith(url, \"/\")){\r\n                return url + relativeUrl;\r\n            }\r\n            else {\r\n                return url + \"/\" + relativeUrl;\r\n            }\r\n        }\r\n\r\n        return self.resolveRelativeUrl(relativeUrl);\r\n    };\r\n\r\n    /**\r\n     * Returns a resolved relative Url.\r\n     *\r\n     * @method     resolveRelativeUrl\r\n     * @param      {String} relativeUrl  the relative URL to resolve\r\n     * @return     {String} the resolved relative URL.\r\n     */\r\n    this.resolveRelativeUrl = function(relativeUrl) {\r\n\r\n        var relativeUrlUri = undefined;\r\n        try {\r\n            relativeUrlUri = new URI(relativeUrl);\r\n        } catch(err) {\r\n            console.error(err);\r\n            console.log(relativeUrl);\r\n        }\r\n        if (relativeUrlUri && relativeUrlUri.is(\"absolute\")) return relativeUrl; //relativeUrlUri.scheme() == \"http://\", \"https://\", \"data:\", etc.\r\n\r\n        \r\n        if(self.rootUrl) {\r\n\r\n            var url = self.rootUrl;\r\n            \r\n            try {\r\n                //url = new URI(relativeUrl).absoluteTo(url).search('').hash('').toString();\r\n                url = new URI(url).search('').hash('').toString();\r\n            } catch(err) {\r\n                console.error(err);\r\n                console.log(url);\r\n            }\r\n            \r\n            if(Helpers.EndsWith(url, \"/\")){\r\n                return url + relativeUrl;\r\n            }\r\n            else {\r\n                return url + \"/\" + relativeUrl;\r\n            }\r\n        }\r\n\r\n        return relativeUrl;\r\n    };\r\n\r\n    /**\r\n     * Checks if the package is Fixed Layout.\r\n     *\r\n     * @method     isFixedLayout\r\n     * @return     {Boolean} TRUE if the package is Fixed Layout.\r\n     */\r\n    this.isFixedLayout = function() {\r\n        return self.rendition_layout === SpineItem.RENDITION_LAYOUT_PREPAGINATED;\r\n    };\r\n\r\n    /**\r\n     * Checks if the package is Reflowable.\r\n     *\r\n     * @method     isReflowable\r\n     * @return     {Boolean} TRUE if the package is Reflowable (i.e. not Fixed Layout).\r\n     */\r\n    this.isReflowable = function() {\r\n        return !self.isFixedLayout();\r\n    };\r\n    \r\n    if(packageData) {\r\n        \r\n        this.rootUrl = packageData.rootUrl;\r\n        this.rootUrlMO = packageData.rootUrlMO;\r\n\r\n        this.rendition_viewport = packageData.rendition_viewport;\r\n\r\n        this.rendition_layout = packageData.rendition_layout;\r\n\r\n        this.rendition_flow = packageData.rendition_flow;\r\n        this.rendition_orientation = packageData.rendition_orientation;\r\n        this.rendition_spread = packageData.rendition_spread;\r\n        \r\n        this.spine = new Spine(this, packageData.spine);\r\n\r\n        this.media_overlay = MediaOverlay.fromDTO(packageData.media_overlay, this);\r\n    }\r\n};\r\n\r\nreturn Package;\r\n});\r\n\r\n\n",
    "\r\n//  LauncherOSX\r\n//\r\n//  Created by Boris Schneiderman.\r\n//  Copyright (c) 2014 Readium Foundation and/or its licensees. All rights reserved.\r\n//\r\n//  Redistribution and use in source and binary forms, with or without modification,\r\n//  are permitted provided that the following conditions are met:\r\n//  1. Redistributions of source code must retain the above copyright notice, this\r\n//  list of conditions and the following disclaimer.\r\n//  2. Redistributions in binary form must reproduce the above copyright notice,\r\n//  this list of conditions and the following disclaimer in the documentation and/or\r\n//  other materials provided with the distribution.\r\n//  3. Neither the name of the organization nor the names of its contributors may be\r\n//  used to endorse or promote products derived from this software without specific\r\n//  prior written permission.\r\n//\r\n//  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\r\n//  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n//  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\r\n//  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\r\n//  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\r\n//  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\r\n//  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\r\n//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE\r\n//  OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\r\n//  OF THE POSSIBILITY OF SUCH DAMAGE.\r\n\r\ndefine('readium_shared_js/views/reflowable_view',[\"../globals\", \"jquery\", \"underscore\", \"eventEmitter\", \"../models/bookmark_data\", \"./cfi_navigation_logic\",\r\n    \"../models/current_pages_info\", \"../helpers\", \"../models/page_open_request\",\r\n    \"../models/viewer_settings\", \"ResizeSensor\"],\r\n    function(Globals, $, _, EventEmitter, BookmarkData, CfiNavigationLogic,\r\n             CurrentPagesInfo, Helpers, PageOpenRequest,\r\n             ViewerSettings, ResizeSensor) {\r\n/**\r\n * Renders reflowable content using CSS columns\r\n * @param options\r\n * @constructor\r\n */\r\nvar ReflowableView = function(options, reader){\r\n\r\n    $.extend(this, new EventEmitter());\r\n\r\n    var self = this;\r\n\r\n    var _$viewport = options.$viewport;\r\n    var _spine = options.spine;\r\n    var _userStyles = options.userStyles;\r\n    var _bookStyles = options.bookStyles;\r\n    var _iframeLoader = options.iframeLoader;\r\n\r\n    var _currentSpineItem;\r\n    var _isWaitingFrameRender = false;\r\n    var _deferredPageRequest;\r\n    var _fontSize = 100;\r\n    var _$contentFrame;\r\n    var _navigationLogic;\r\n    var _$el;\r\n    var _$iframe;\r\n    var _$epubHtml;\r\n    var _lastPageRequest = undefined;\r\n\r\n    var _cfiClassBlacklist = [\"cfi-marker\", \"mo-cfi-highlight\", \"resize-sensor\", \"resize-sensor-expand\", \"resize-sensor-shrink\", \"resize-sensor-inner\"];\r\n    var _cfiElementBlacklist = [];\r\n    var _cfiIdBlacklist = [\"MathJax_Message\", \"MathJax_SVG_Hidden\"];\r\n\r\n    var _$htmlBody;\r\n\r\n    var _htmlBodyIsVerticalWritingMode;\r\n    var _htmlBodyIsLTRDirection;\r\n    var _htmlBodyIsLTRWritingMode;\r\n\r\n\r\n    var _currentOpacity = -1;\r\n\r\n    var _lastViewPortSize = {\r\n        width: undefined,\r\n        height: undefined\r\n    };\r\n\r\n    var _paginationInfo = {\r\n\r\n        visibleColumnCount : 2,\r\n        columnGap : 20,\r\n        columnMaxWidth: 550,\r\n        columnMinWidth: 400,\r\n        spreadCount : 0,\r\n        currentSpreadIndex : 0,\r\n        columnWidth : undefined,\r\n        pageOffset : 0,\r\n        columnCount: 0\r\n    };\r\n\r\n    this.render = function(){\r\n\r\n        var template = Helpers.loadTemplate(\"reflowable_book_frame\", {});\r\n\r\n        _$el = $(template);\r\n        _$viewport.append(_$el);\r\n\r\n        var settings = reader.viewerSettings();\r\n        if (!settings || typeof settings.enableGPUHardwareAccelerationCSS3D === \"undefined\")\r\n        {\r\n            //defaults\r\n            settings = new ViewerSettings({});\r\n        }\r\n        if (settings.enableGPUHardwareAccelerationCSS3D) {\r\n            // This fixes rendering issues with WebView (native apps), which clips content embedded in iframes unless GPU hardware acceleration is enabled for CSS rendering.\r\n            _$el.css(\"transform\", \"translateZ(0)\");\r\n        }\r\n\r\n        // See ReaderView.handleViewportResize\r\n        // var lazyResize = _.debounce(self.onViewportResize, 100);\r\n        // $(window).on(\"resize.ReadiumSDK.reflowableView\", _.bind(lazyResize, self));\r\n        renderIframe();\r\n\r\n        return self;\r\n    };\r\n\r\n    function setFrameSizesToRectangle(rectangle) {\r\n        _$contentFrame.css(\"left\", rectangle.left + \"px\");\r\n        _$contentFrame.css(\"top\", rectangle.top + \"px\");\r\n        _$contentFrame.css(\"right\", rectangle.right + \"px\");\r\n        _$contentFrame.css(\"bottom\", rectangle.bottom + \"px\");\r\n\r\n    }\r\n\r\n    this.remove = function() {\r\n\r\n        //$(window).off(\"resize.ReadiumSDK.reflowableView\");\r\n        _$el.remove();\r\n\r\n    };\r\n\r\n    this.isReflowable = function() {\r\n        return true;\r\n    };\r\n\r\n    this.onViewportResize = function() {\r\n\r\n        if(updateViewportSize()) {\r\n            updatePagination();\r\n        }\r\n    };\r\n\r\n    var _viewSettings = undefined;\r\n    this.setViewSettings = function(settings) {\r\n\r\n        _viewSettings = settings;\r\n\r\n        _paginationInfo.columnGap = settings.columnGap;\r\n        _paginationInfo.columnMaxWidth = settings.columnMaxWidth;\r\n        _paginationInfo.columnMinWidth = settings.columnMinWidth;\r\n        \r\n        _fontSize = settings.fontSize;\r\n\r\n        updateHtmlFontSize();\r\n        updateColumnGap();\r\n\r\n        updateViewportSize();\r\n        updatePagination();\r\n    };\r\n    \r\n    function getFrameDimensions() {\r\n        return {\r\n            width: _$iframe[0].clientWidth,\r\n            height: _$iframe[0].clientHeight\r\n        };\r\n    }\r\n\r\n    function renderIframe() {\r\n        if (_$contentFrame) {\r\n            //destroy old contentFrame\r\n            _$contentFrame.remove();\r\n        }\r\n\r\n        var template = Helpers.loadTemplate(\"reflowable_book_page_frame\", {});\r\n        var $bookFrame = $(template);\r\n        $bookFrame = _$el.append($bookFrame);\r\n\r\n        _$contentFrame = $(\"#reflowable-content-frame\", $bookFrame);\r\n\r\n        _$iframe = $(\"#epubContentIframe\", $bookFrame);\r\n\r\n        _$iframe.css(\"left\", \"\");\r\n        _$iframe.css(\"right\", \"\");\r\n        _$iframe.css(\"position\", \"relative\");\r\n        //_$iframe.css(_spine.isLeftToRight() ? \"left\" : \"right\", \"0px\");\r\n        _$iframe.css(\"overflow\", \"hidden\");\r\n\r\n        _navigationLogic = new CfiNavigationLogic({\r\n            $iframe: _$iframe,\r\n            frameDimensions: getFrameDimensions,\r\n            paginationInfo: _paginationInfo,\r\n            classBlacklist: _cfiClassBlacklist,\r\n            elementBlacklist: _cfiElementBlacklist,\r\n            idBlacklist: _cfiIdBlacklist\r\n        });\r\n    }\r\n\r\n    function loadSpineItem(spineItem) {\r\n\r\n        if(_currentSpineItem != spineItem) {\r\n\r\n            //create & append iframe to container frame\r\n            renderIframe();\r\n            if (_currentSpineItem) {\r\n                Globals.logEvent(\"CONTENT_DOCUMENT_UNLOADED\", \"EMIT\", \"reflowable_view.js [ \" + _currentSpineItem.href + \" ]\");\r\n                self.emit(Globals.Events.CONTENT_DOCUMENT_UNLOADED, _$iframe, _currentSpineItem);\r\n            }\r\n\r\n            self.resetCurrentPosition();\r\n\r\n            _paginationInfo.pageOffset = 0;\r\n            _paginationInfo.currentSpreadIndex = 0;\r\n            _currentSpineItem = spineItem;\r\n            \r\n            // TODO: this is a dirty hack!!\r\n            _currentSpineItem.paginationInfo = _paginationInfo; \r\n            \r\n            _isWaitingFrameRender = true;\r\n\r\n            var src = _spine.package.resolveRelativeUrl(spineItem.href);\r\n            \r\n            Globals.logEvent(\"CONTENT_DOCUMENT_LOAD_START\", \"EMIT\", \"reflowable_view.js [ \" + spineItem.href + \" -- \" + src + \" ]\");\r\n            self.emit(Globals.Events.CONTENT_DOCUMENT_LOAD_START, _$iframe, spineItem);\r\n\r\n            _$iframe.css(\"opacity\", \"0.01\");\r\n\r\n            _iframeLoader.loadIframe(_$iframe[0], src, onIFrameLoad, self, {spineItem : spineItem});\r\n        }\r\n    }\r\n\r\n    function updateHtmlFontSize() {\r\n\r\n        if(_$epubHtml) {\r\n            Helpers.UpdateHtmlFontSize(_$epubHtml, _fontSize);\r\n        }\r\n    }\r\n\r\n    function updateColumnGap() {\r\n\r\n        if(_$epubHtml) {\r\n\r\n            _$epubHtml.css(\"column-gap\", _paginationInfo.columnGap + \"px\");\r\n        }\r\n    }\r\n\r\n    function onIFrameLoad(success) {\r\n\r\n        _isWaitingFrameRender = false;\r\n\r\n        //while we where loading frame new request came\r\n        if(_deferredPageRequest && _deferredPageRequest.spineItem != _currentSpineItem) {\r\n            loadSpineItem(_deferredPageRequest.spineItem);\r\n            return;\r\n        }\r\n\r\n        if(!success) {\r\n            _$iframe.css(\"opacity\", \"1\");\r\n            _deferredPageRequest = undefined;\r\n            return;\r\n        }\r\n\r\n        Globals.logEvent(\"CONTENT_DOCUMENT_LOADED\", \"EMIT\", \"reflowable_view.js [ \" + _currentSpineItem.href + \" ]\");\r\n        self.emit(Globals.Events.CONTENT_DOCUMENT_LOADED, _$iframe, _currentSpineItem);\r\n\r\n        var epubContentDocument = _$iframe[0].contentDocument;\r\n        _$epubHtml = $(\"html\", epubContentDocument);\r\n        _$htmlBody = $(\"body\", _$epubHtml);\r\n\r\n        // TODO: how to address this correctly across all the affected platforms?!\r\n        // Video surface sometimes (depends on the video codec) disappears from CSS column (i.e. reflow page) during playback\r\n        // (audio continues to play normally, but video canvas is invisible).\r\n        // https://github.com/readium/readium-js-viewer/issues/265#issuecomment-73018762\r\n        // ...Meanwhile, reverting https://github.com/readium/readium-js-viewer/issues/239\r\n        // by commenting the code below (which unfortunately only works with some GPU / codec configurations,\r\n        // but actually fails on several other machines!!)\r\n        /*\r\n        if(window.chrome\r\n            && window.navigator.vendor === \"Google Inc.\") // TODO: Opera (WebKit) sometimes suffers from this rendering bug too (depends on the video codec), but unfortunately GPU-accelerated rendering makes the video controls unresponsive!!\r\n        {\r\n            $(\"video\", _$htmlBody).css(\"transform\", \"translateZ(0)\");\r\n        }\r\n        */\r\n\r\n        _htmlBodyIsVerticalWritingMode = false;\r\n        _htmlBodyIsLTRDirection = true;\r\n        _htmlBodyIsLTRWritingMode = undefined;\r\n\r\n        var win = _$iframe[0].contentDocument.defaultView || _$iframe[0].contentWindow;\r\n\r\n        //Helpers.isIframeAlive\r\n        var htmlBodyComputedStyle = win.getComputedStyle(_$htmlBody[0], null);\r\n        if (htmlBodyComputedStyle)\r\n        {\r\n            _htmlBodyIsLTRDirection = htmlBodyComputedStyle.direction === \"ltr\";\r\n\r\n            var writingMode = undefined;\r\n            if (htmlBodyComputedStyle.getPropertyValue)\r\n            {\r\n                writingMode = htmlBodyComputedStyle.getPropertyValue(\"-webkit-writing-mode\") || htmlBodyComputedStyle.getPropertyValue(\"-moz-writing-mode\") || htmlBodyComputedStyle.getPropertyValue(\"-ms-writing-mode\") || htmlBodyComputedStyle.getPropertyValue(\"-o-writing-mode\") || htmlBodyComputedStyle.getPropertyValue(\"-epub-writing-mode\") || htmlBodyComputedStyle.getPropertyValue(\"writing-mode\");\r\n            }\r\n            else\r\n            {\r\n                writingMode = htmlBodyComputedStyle.webkitWritingMode || htmlBodyComputedStyle.mozWritingMode || htmlBodyComputedStyle.msWritingMode || htmlBodyComputedStyle.oWritingMode || htmlBodyComputedStyle.epubWritingMode || htmlBodyComputedStyle.writingMode;\r\n            }\r\n\r\n            if (writingMode)\r\n            {\r\n                _htmlBodyIsLTRWritingMode = writingMode.indexOf(\"-lr\") >= 0; // || writingMode.indexOf(\"horizontal-\") >= 0; we need explicit!\r\n\r\n                if (writingMode.indexOf(\"vertical\") >= 0 || writingMode.indexOf(\"tb-\") >= 0 || writingMode.indexOf(\"bt-\") >= 0)\r\n                {\r\n                    _htmlBodyIsVerticalWritingMode = true;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (_htmlBodyIsLTRDirection)\r\n        {\r\n            if (_$htmlBody[0].getAttribute(\"dir\") === \"rtl\" || _$epubHtml[0].getAttribute(\"dir\") === \"rtl\")\r\n            {\r\n                _htmlBodyIsLTRDirection = false;\r\n            }\r\n        }\r\n\r\n        // Some EPUBs may not have explicit RTL content direction (via CSS \"direction\" property or @dir attribute) despite having a RTL page progression direction. Readium consequently tweaks the HTML in order to restore the correct block flow in the browser renderer, resulting in the appropriate CSS columnisation (which is used to emulate pagination).\r\n        if (!_spine.isLeftToRight() && _htmlBodyIsLTRDirection && !_htmlBodyIsVerticalWritingMode)\r\n        {\r\n            _$htmlBody[0].setAttribute(\"dir\", \"rtl\");\r\n            _htmlBodyIsLTRDirection = false;\r\n            _htmlBodyIsLTRWritingMode = false;\r\n        }\r\n\r\n        _paginationInfo.isVerticalWritingMode = _htmlBodyIsVerticalWritingMode; \r\n\r\n        hideBook();\r\n        _$iframe.css(\"opacity\", \"1\");\r\n\r\n        updateViewportSize();\r\n        _$epubHtml.css(\"height\", _lastViewPortSize.height + \"px\");\r\n\r\n        _$epubHtml.css(\"position\", \"relative\");\r\n        _$epubHtml.css(\"margin\", \"0\");\r\n        _$epubHtml.css(\"padding\", \"0\");\r\n\r\n        _$epubHtml.css(\"column-axis\", (_htmlBodyIsVerticalWritingMode ? \"vertical\" : \"horizontal\"));\r\n\r\n        //\r\n        // /////////\r\n        // //Columns Debugging\r\n        //\r\n        //     _$epubHtml.css(\"column-rule-color\", \"red\");\r\n        //     _$epubHtml.css(\"column-rule-style\", \"dashed\");\r\n        //     _$epubHtml.css(\"column-rule-width\", \"1px\");\r\n        // _$epubHtml.css(\"background-color\", '#b0c4de');\r\n        //\r\n        // ////\r\n\r\n        self.applyBookStyles();\r\n        resizeImages();\r\n\r\n        updateHtmlFontSize();\r\n        updateColumnGap();\r\n\r\n        var bodyElement = _$htmlBody[0];\r\n        bodyElement.resizeSensor = new ResizeSensor(bodyElement, function() {\r\n            console.debug(\"ReflowableView content resized\", $(bodyElement).width(), $(bodyElement).height());\r\n            updatePagination();\r\n        });\r\n\r\n        self.applyStyles();\r\n    }\r\n\r\n    this.applyStyles = function() {\r\n\r\n        Helpers.setStyles(_userStyles.getStyles(), _$el.parent());\r\n\r\n        //because left, top, bottom, right setting ignores padding of parent container\r\n        //we have to take it to account manually\r\n        var elementMargins = Helpers.Margins.fromElement(_$el);\r\n        setFrameSizesToRectangle(elementMargins.padding);\r\n\r\n\r\n        updateViewportSize();\r\n        updatePagination();\r\n    };\r\n\r\n    this.applyBookStyles = function() {\r\n\r\n        if(_$epubHtml) {\r\n            Helpers.setStyles(_bookStyles.getStyles(), _$epubHtml);\r\n        }\r\n    };\r\n\r\n    function openDeferredElement() {\r\n\r\n        if(!_deferredPageRequest) {\r\n            return;\r\n        }\r\n\r\n        var deferredData = _deferredPageRequest;\r\n        _deferredPageRequest = undefined;\r\n        self.openPage(deferredData);\r\n\r\n    }\r\n\r\n    this.openPageInternal = function(pageRequest) {\r\n\r\n        if(_isWaitingFrameRender) {\r\n            _deferredPageRequest = pageRequest;\r\n            return;\r\n        }\r\n\r\n        // if no spine item specified we are talking about current spine item\r\n        if(pageRequest.spineItem && pageRequest.spineItem != _currentSpineItem) {\r\n            _deferredPageRequest = pageRequest;\r\n            loadSpineItem(pageRequest.spineItem);\r\n            return;\r\n        }\r\n\r\n        var pageIndex = undefined;\r\n\r\n\r\n        if(pageRequest.spineItemPageIndex !== undefined) {\r\n            pageIndex = pageRequest.spineItemPageIndex;\r\n        }\r\n        else if(pageRequest.elementId) {\r\n            pageIndex = _navigationLogic.getPageForElementId(pageRequest.elementId);\r\n            \r\n            if (pageIndex < 0) pageIndex = 0;\r\n        }\r\n        else if(pageRequest.firstVisibleCfi && pageRequest.lastVisibleCfi) {\r\n            var firstPageIndex;\r\n            var lastPageIndex;\r\n            try\r\n            {\r\n                firstPageIndex = _navigationLogic.getPageForElementCfi(pageRequest.firstVisibleCfi,\r\n                    _cfiClassBlacklist,\r\n                    _cfiElementBlacklist,\r\n                    _cfiIdBlacklist);\r\n                \r\n                if (firstPageIndex < 0) firstPageIndex = 0;\r\n            }\r\n            catch (e)\r\n            {\r\n                firstPageIndex = 0;\r\n                console.error(e);\r\n            }\r\n            try\r\n            {\r\n                lastPageIndex = _navigationLogic.getPageForElementCfi(pageRequest.lastVisibleCfi,\r\n                    _cfiClassBlacklist,\r\n                    _cfiElementBlacklist,\r\n                    _cfiIdBlacklist);\r\n                \r\n                if (lastPageIndex < 0) lastPageIndex = 0;\r\n            }\r\n            catch (e)\r\n            {\r\n                lastPageIndex = 0;\r\n                console.error(e);\r\n            }\r\n            // Go to the page in the middle of the two elements\r\n            pageIndex = Math.round((firstPageIndex + lastPageIndex) / 2);\r\n        }\r\n        else if(pageRequest.elementCfi) {\r\n            try\r\n            {\r\n                pageIndex = _navigationLogic.getPageForElementCfi(pageRequest.elementCfi,\r\n                    _cfiClassBlacklist,\r\n                    _cfiElementBlacklist,\r\n                    _cfiIdBlacklist);\r\n                \r\n                if (pageIndex < 0) pageIndex = 0;\r\n            }\r\n            catch (e)\r\n            {\r\n                pageIndex = 0;\r\n                console.error(e);\r\n            }\r\n        }\r\n        else if(pageRequest.firstPage) {\r\n            pageIndex = 0;\r\n        }\r\n        else if(pageRequest.lastPage) {\r\n            pageIndex = _paginationInfo.columnCount - 1;\r\n        }\r\n        else {\r\n            console.debug(\"No criteria in pageRequest\");\r\n            pageIndex = 0;\r\n        }\r\n\r\n        if(pageIndex >= 0 && pageIndex < _paginationInfo.columnCount) {\r\n            _paginationInfo.currentSpreadIndex = Math.floor(pageIndex / _paginationInfo.visibleColumnCount) ;\r\n            onPaginationChanged(pageRequest.initiator, pageRequest.spineItem, pageRequest.elementId);\r\n        }\r\n        else {\r\n            console.log('Illegal pageIndex value: ', pageIndex, 'column count is ', _paginationInfo.columnCount);\r\n        }\r\n    };\r\n\r\n    this.openPage = function(pageRequest) {\r\n        // Go to request page, it will save the new position in onPaginationChanged\r\n        this.openPageInternal(pageRequest);\r\n        // Save it for when pagination is updated\r\n        _lastPageRequest = pageRequest;\r\n    };\r\n\r\n    this.resetCurrentPosition = function() {\r\n        _lastPageRequest = undefined;\r\n    };\r\n\r\n    this.saveCurrentPosition = function() {\r\n        // If there's a deferred page request, there's no point in saving the current position\r\n        // as it's going to change soon\r\n        if (_deferredPageRequest) {\r\n            return;\r\n        }\r\n\r\n        var _firstVisibleCfi = self.getFirstVisibleCfi();\r\n        var _lastVisibleCfi = self.getLastVisibleCfi();\r\n        _lastPageRequest = new PageOpenRequest(_currentSpineItem, self);\r\n        _lastPageRequest.setFirstAndLastVisibleCfi(_firstVisibleCfi.contentCFI, _lastVisibleCfi.contentCFI);\r\n    };\r\n\r\n    this.restoreCurrentPosition = function() {\r\n        if (_lastPageRequest) {\r\n            this.openPageInternal(_lastPageRequest);            \r\n        }\r\n    };\r\n\r\n    function redraw() {\r\n\r\n        var offsetVal =  -_paginationInfo.pageOffset + \"px\";\r\n\r\n        if (_htmlBodyIsVerticalWritingMode)\r\n        {\r\n            _$epubHtml.css(\"top\", offsetVal);\r\n        }\r\n        else\r\n        {\r\n            var ltr = _htmlBodyIsLTRDirection || _htmlBodyIsLTRWritingMode;\r\n\r\n            _$epubHtml.css(\"left\", ltr ? offsetVal : \"\");\r\n            _$epubHtml.css(\"right\", !ltr ? offsetVal : \"\");\r\n        }\r\n\r\n        showBook(); // as it's no longer hidden by shifting the position\r\n    }\r\n\r\n    function updateViewportSize() {\r\n\r\n        var newWidth = _$contentFrame.width();\r\n        \r\n        // Ensure that the new viewport width is always even numbered\r\n        // this is to prevent a rendering inconsistency between browsers when odd-numbered bounds are used for CSS columns\r\n        // See https://github.com/readium/readium-shared-js/issues/37\r\n        newWidth -= newWidth % 2;\r\n\r\n        var newHeight = _$contentFrame.height();\r\n\r\n        if(_lastViewPortSize.width !== newWidth || _lastViewPortSize.height !== newHeight){\r\n\r\n            _lastViewPortSize.width = newWidth;\r\n            _lastViewPortSize.height = newHeight;\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    function onPaginationChanged_(initiator, paginationRequest_spineItem, paginationRequest_elementId) {\r\n\r\n        _paginationInfo.pageOffset = (_paginationInfo.columnWidth + _paginationInfo.columnGap) * _paginationInfo.visibleColumnCount * _paginationInfo.currentSpreadIndex;\r\n        \r\n        redraw();\r\n\r\n        _.defer(function () {\r\n\r\n            if (_lastPageRequest == undefined) {\r\n                self.saveCurrentPosition();\r\n            }\r\n            \r\n            Globals.logEvent(\"InternalEvents.CURRENT_VIEW_PAGINATION_CHANGED\", \"EMIT\", \"reflowable_view.js\");\r\n            self.emit(Globals.InternalEvents.CURRENT_VIEW_PAGINATION_CHANGED, {\r\n                paginationInfo: self.getPaginationInfo(),\r\n                initiator: initiator,\r\n                spineItem: paginationRequest_spineItem,\r\n                elementId: paginationRequest_elementId\r\n            });\r\n        });\r\n    }\r\n    var onPaginationChanged = _.debounce(onPaginationChanged_, 100);\r\n\r\n    this.openPagePrev = function (initiator) {\r\n\r\n        if(!_currentSpineItem) {\r\n            return;\r\n        }\r\n\r\n        if(_paginationInfo.currentSpreadIndex > 0) {\r\n            // Page will change, the current position is not valid any more\r\n            // Reset it so it's saved next time onPaginationChanged is called\r\n            this.resetCurrentPosition();\r\n            _paginationInfo.currentSpreadIndex--;\r\n            onPaginationChanged(initiator);\r\n        }\r\n        else {\r\n\r\n            var prevSpineItem = _spine.prevItem(_currentSpineItem, true);\r\n            if(prevSpineItem) {\r\n\r\n                var pageRequest = new PageOpenRequest(prevSpineItem, initiator);\r\n                pageRequest.setLastPage();\r\n                self.openPage(pageRequest);\r\n            }\r\n        }\r\n    };\r\n\r\n    this.openPageNext = function (initiator) {\r\n\r\n        if(!_currentSpineItem) {\r\n            return;\r\n        }\r\n\r\n        if(_paginationInfo.currentSpreadIndex < _paginationInfo.spreadCount - 1) {\r\n            // Page will change, the current position is not valid any more\r\n            // Reset it so it's saved next time onPaginationChanged is called\r\n            this.resetCurrentPosition();\r\n            _paginationInfo.currentSpreadIndex++;\r\n            onPaginationChanged(initiator);\r\n        }\r\n        else {\r\n\r\n            var nextSpineItem = _spine.nextItem(_currentSpineItem, true);\r\n            if(nextSpineItem) {\r\n\r\n                var pageRequest = new PageOpenRequest(nextSpineItem, initiator);\r\n                pageRequest.setFirstPage();\r\n                self.openPage(pageRequest);\r\n            }\r\n        }\r\n    };\r\n\r\n\r\n    function updatePagination() {\r\n\r\n        // At 100% font-size = 16px (on HTML, not body or descendant markup!)\r\n        var MAXW = _paginationInfo.columnMaxWidth;\r\n        var MINW = _paginationInfo.columnMinWidth;\r\n\r\n        var isDoublePageSyntheticSpread = Helpers.deduceSyntheticSpread(_$viewport, _currentSpineItem, _viewSettings);\r\n\r\n        var forced = (isDoublePageSyntheticSpread === false) || (isDoublePageSyntheticSpread === true);\r\n        // excludes 0 and 1 falsy/truthy values which denote non-forced result\r\n\r\n// console.debug(\"isDoublePageSyntheticSpread: \" + isDoublePageSyntheticSpread);\r\n// console.debug(\"forced: \" + forced);\r\n//\r\n        if (isDoublePageSyntheticSpread === 0)\r\n        {\r\n            isDoublePageSyntheticSpread = 1; // try double page, will shrink if doesn't fit\r\n// console.debug(\"TRYING SPREAD INSTEAD OF SINGLE...\");\r\n        }\r\n\r\n        _paginationInfo.visibleColumnCount = isDoublePageSyntheticSpread ? 2 : 1;\r\n\r\n        if (_htmlBodyIsVerticalWritingMode)\r\n        {\r\n            MAXW *= 2;\r\n            isDoublePageSyntheticSpread = false;\r\n            forced = true;\r\n            _paginationInfo.visibleColumnCount = 1;\r\n// console.debug(\"Vertical Writing Mode => single CSS column, but behaves as if two-page spread\");\r\n        }\r\n\r\n        if(!_$epubHtml) {\r\n            return;\r\n        }\r\n\r\n        hideBook(); // shiftBookOfScreen();\r\n\r\n        // \"borderLeft\" is the blank vertical strip (e.g. 40px wide) where the left-arrow button resides, i.e. previous page command\r\n        var borderLeft = parseInt(_$viewport.css(\"border-left-width\"));\r\n        \r\n        // The \"columnGap\" separates two consecutive columns in a 2-page synthetic spread (e.g. 60px wide).\r\n        // This middle gap (blank vertical strip) actually corresponds to the left page's right-most margin, combined with the right page's left-most margin.\r\n        // So, \"adjustedGapLeft\" is half of the center strip... \r\n        var adjustedGapLeft = _paginationInfo.columnGap/2;\r\n        // ...but we include the \"borderLeft\" strip to avoid wasting valuable rendering real-estate:  \r\n        adjustedGapLeft = Math.max(0, adjustedGapLeft-borderLeft);\r\n        // Typically, \"adjustedGapLeft\" is zero because the space available for the 'previous page' button is wider than half of the column gap!\r\n\r\n        // \"borderRight\" is the blank vertical strip (e.g. 40px wide) where the right-arrow button resides, i.e. next page command\r\n        var borderRight = parseInt(_$viewport.css(\"border-right-width\"));\r\n        \r\n        // The \"columnGap\" separates two consecutive columns in a 2-page synthetic spread (e.g. 60px wide).\r\n        // This middle gap (blank vertical strip) actually corresponds to the left page's right-most margin, combined with the right page's left-most margin.\r\n        // So, \"adjustedGapRight\" is half of the center strip... \r\n        var adjustedGapRight = _paginationInfo.columnGap/2;\r\n        // ...but we include the \"borderRight\" strip to avoid wasting valuable rendering real-estate:\r\n        adjustedGapRight = Math.max(0, adjustedGapRight-borderRight);\r\n        // Typically, \"adjustedGapRight\" is zero because the space available for the 'next page' button is wider than half of the column gap! (in other words, the right-most and left-most page margins are fully included in the strips reserved for the arrow buttons)\r\n\r\n        // Note that \"availableWidth\" does not contain \"borderLeft\" and \"borderRight\" (.width() excludes the padding and border and margin in the CSS box model of div#epub-reader-frame)  \r\n        var availableWidth = _$viewport.width();\r\n        \r\n        // ...So, we substract the page margins and button spacing to obtain the width available for actual text:\r\n        var textWidth = availableWidth - adjustedGapLeft - adjustedGapRight;\r\n        \r\n        // ...and if we have 2 pages / columns, then we split the text width in half: \r\n        if (isDoublePageSyntheticSpread)\r\n        {\r\n            textWidth = (textWidth - _paginationInfo.columnGap) * 0.5;\r\n        }\r\n\r\n        var filler = 0;\r\n\r\n        // Now, if the resulting width actually available for document content is greater than the maximum allowed value, we create even more left+right blank space to \"compress\" the horizontal run of text.  \r\n        if (textWidth > MAXW)\r\n        {\r\n            var eachPageColumnReduction = textWidth - MAXW;\r\n            \r\n            // if we have a 2-page synthetic spread, then we \"trim\" left and right sides by adding \"eachPageColumnReduction\" blank space.\r\n            // if we have a single page / column, then this loss of text real estate is shared between right and left sides  \r\n            filler = Math.floor(eachPageColumnReduction * (isDoublePageSyntheticSpread ? 1 : 0.5));\r\n        }\r\n\r\n        // Let's check whether a narrow two-page synthetic spread (impeded reabability) can be reduced down to a single page / column:\r\n        else if (!forced && textWidth < MINW && isDoublePageSyntheticSpread)\r\n        {\r\n            isDoublePageSyntheticSpread = false;\r\n            _paginationInfo.visibleColumnCount = 1;\r\n\r\n            textWidth = availableWidth - adjustedGapLeft - adjustedGapRight;\r\n            if (textWidth > MAXW)\r\n            {\r\n                filler = Math.floor((textWidth - MAXW) * 0.5);\r\n            }\r\n        }\r\n        \r\n        _$el.css({\"left\": (filler+adjustedGapLeft + \"px\"), \"right\": (filler+adjustedGapRight + \"px\")});\r\n        \r\n        updateViewportSize(); //_$contentFrame ==> _lastViewPortSize\r\n\r\n        var resultingColumnWidth = _$el.width();\r\n        if (isDoublePageSyntheticSpread) {\r\n            resultingColumnWidth = (resultingColumnWidth - _paginationInfo.columnGap) / 2;\r\n        }\r\n        resultingColumnWidth = Math.floor(resultingColumnWidth);\r\n        if ((resultingColumnWidth-1) > MAXW) {\r\n            console.debug(\"resultingColumnWidth > MAXW ! \" + resultingColumnWidth + \" > \" + MAXW);\r\n        }\r\n        \r\n\r\n        _$iframe.css(\"width\", _lastViewPortSize.width + \"px\");\r\n        _$iframe.css(\"height\", _lastViewPortSize.height + \"px\");\r\n\r\n        _$epubHtml.css(\"height\", _lastViewPortSize.height + \"px\");\r\n\r\n        // below min- max- are required in vertical writing mode (height is not enough, in some cases...weird!)\r\n        _$epubHtml.css(\"min-height\", _lastViewPortSize.height + \"px\");\r\n        _$epubHtml.css(\"max-height\", _lastViewPortSize.height + \"px\");\r\n\r\n        //normalise spacing to avoid interference with column-isation\r\n        _$epubHtml.css('margin', 0);\r\n        _$epubHtml.css('padding', 0);\r\n        _$epubHtml.css('border', 0);\r\n        _$htmlBody.css('margin', 0);\r\n        _$htmlBody.css('padding', 0);\r\n\r\n        _paginationInfo.rightToLeft = _spine.isRightToLeft();\r\n\r\n        _paginationInfo.columnWidth = Math.round(((_htmlBodyIsVerticalWritingMode ? _lastViewPortSize.height : _lastViewPortSize.width) - _paginationInfo.columnGap * (_paginationInfo.visibleColumnCount - 1)) / _paginationInfo.visibleColumnCount);\r\n\r\n        var useColumnCountNotWidth = _paginationInfo.visibleColumnCount > 1; // column-count == 1 does not work in Chrome, and is not needed anyway (HTML width is full viewport width, no Firefox video flickering)\r\n        if (useColumnCountNotWidth) {\r\n            _$epubHtml.css(\"width\", _lastViewPortSize.width + \"px\");\r\n            _$epubHtml.css(\"column-width\", \"auto\");\r\n            _$epubHtml.css(\"column-count\", _paginationInfo.visibleColumnCount);\r\n        } else {\r\n            _$epubHtml.css(\"width\", (_htmlBodyIsVerticalWritingMode ? _lastViewPortSize.width : _paginationInfo.columnWidth) + \"px\");\r\n            _$epubHtml.css(\"column-count\", \"auto\");\r\n            _$epubHtml.css(\"column-width\", _paginationInfo.columnWidth + \"px\");\r\n        }\r\n\r\n        _$epubHtml.css(\"column-fill\", \"auto\");\r\n\r\n        _$epubHtml.css({left: \"0\", right: \"0\", top: \"0\"});\r\n\r\n        Helpers.triggerLayout(_$iframe);\r\n\r\n        _paginationInfo.columnCount = ((_htmlBodyIsVerticalWritingMode ? _$epubHtml[0].scrollHeight : _$epubHtml[0].scrollWidth) + _paginationInfo.columnGap) / (_paginationInfo.columnWidth + _paginationInfo.columnGap);\r\n        _paginationInfo.columnCount = Math.round(_paginationInfo.columnCount);\r\n\r\n        var totalGaps = (_paginationInfo.columnCount-1) * _paginationInfo.columnGap;\r\n        var colWidthCheck = ((_htmlBodyIsVerticalWritingMode ? _$epubHtml[0].scrollHeight : _$epubHtml[0].scrollWidth) - totalGaps) / _paginationInfo.columnCount;\r\n        colWidthCheck = Math.round(colWidthCheck);\r\n\r\n        if (colWidthCheck > _paginationInfo.columnWidth)\r\n        {\r\n            console.debug(\"ADJUST COLUMN\");\r\n            console.log(_paginationInfo.columnWidth);\r\n            console.log(colWidthCheck);\r\n\r\n            _paginationInfo.columnWidth = colWidthCheck;\r\n        }\r\n\r\n        _paginationInfo.spreadCount =  Math.ceil(_paginationInfo.columnCount / _paginationInfo.visibleColumnCount);\r\n\r\n        if(_paginationInfo.currentSpreadIndex >= _paginationInfo.spreadCount) {\r\n            _paginationInfo.currentSpreadIndex = _paginationInfo.spreadCount - 1;\r\n        }\r\n\r\n        if(_deferredPageRequest) {\r\n\r\n            //if there is a request for specific page we get here\r\n            openDeferredElement();\r\n        }\r\n        else {\r\n\r\n            // we get here on resizing the viewport\r\n            if (_lastPageRequest) {\r\n                // Make sure we stay on the same page after the content or the viewport \r\n                // has been resized\r\n                self.restoreCurrentPosition();\r\n            } else {\r\n                onPaginationChanged(self); // => redraw() => showBook(), so the trick below is not needed                \r\n            }\r\n\r\n            //onPaginationChanged(self); // => redraw() => showBook(), so the trick below is not needed \r\n\r\n            // //We do this to force re-rendering of the document in the iframe.\r\n            // //There is a bug in WebView control with right to left columns layout - after resizing the window html document\r\n            // //is shifted in side the containing div. Hiding and showing the html element puts document in place.\r\n            // _$epubHtml.hide();\r\n            // setTimeout(function() {\r\n            //     _$epubHtml.show();\r\n            //     onPaginationChanged(self); // => redraw() => showBook()\r\n            // }, 50);\r\n\r\n        }\r\n    }\r\n\r\n//    function shiftBookOfScreen() {\r\n//\r\n//        if(_spine.isLeftToRight()) {\r\n//            _$epubHtml.css(\"left\", (_lastViewPortSize.width + 1000) + \"px\");\r\n//        }\r\n//        else {\r\n//            _$epubHtml.css(\"right\", (_lastViewPortSize.width + 1000) + \"px\");\r\n//        }\r\n//    }\r\n\r\n    function hideBook()\r\n    {\r\n        if (_currentOpacity != -1) return; // already hidden\r\n\r\n        // css('opacity') produces invalid result in Firefox, when iframes are involved and when is called\r\n        // directly after set, i.e. after showBook(), see: https://github.com/jquery/jquery/issues/2622\r\n        //_currentOpacity = $epubHtml.css('opacity');\r\n        _currentOpacity = _$epubHtml[0].style.opacity;\r\n        _$epubHtml.css('opacity', \"0\");\r\n    }\r\n\r\n    function showBook()\r\n    {\r\n        if (_currentOpacity != -1)\r\n        {\r\n            _$epubHtml.css('opacity', _currentOpacity);\r\n        }\r\n        _currentOpacity = -1;\r\n    }\r\n\r\n    this.getPaginationInfo = function() {\r\n\r\n        var paginationInfo = new CurrentPagesInfo(_spine, false);\r\n\r\n        if(!_currentSpineItem) {\r\n            return paginationInfo;\r\n        }\r\n\r\n        var pageIndexes = getOpenPageIndexes();\r\n\r\n        for(var i = 0, count = pageIndexes.length; i < count; i++) {\r\n\r\n            paginationInfo.addOpenPage(pageIndexes[i], _paginationInfo.columnCount, _currentSpineItem.idref, _currentSpineItem.index);\r\n        }\r\n\r\n        return paginationInfo;\r\n\r\n    };\r\n\r\n    function getOpenPageIndexes() {\r\n\r\n        var indexes = [];\r\n\r\n        var currentPage = _paginationInfo.currentSpreadIndex * _paginationInfo.visibleColumnCount;\r\n\r\n        for(var i = 0; i < _paginationInfo.visibleColumnCount && (currentPage + i) < _paginationInfo.columnCount; i++) {\r\n\r\n            indexes.push(currentPage + i);\r\n        }\r\n\r\n        return indexes;\r\n\r\n    }\r\n\r\n    //we need this styles for css columnizer not to chop big images\r\n    function resizeImages() {\r\n\r\n        if(!_$epubHtml) {\r\n            return;\r\n        }\r\n\r\n        var $elem;\r\n        var height;\r\n        var width;\r\n\r\n        $('img, svg', _$epubHtml).each(function(){\r\n\r\n            $elem = $(this);\r\n\r\n            // if we set max-width/max-height to 100% columnizing engine chops images embedded in the text\r\n            // (but not if we set it to 99-98%) go figure.\r\n            // TODO: CSS min-w/h is content-box, not border-box (does not take into account padding + border)? => images may still overrun?\r\n            $elem.css('max-width', '98%');\r\n            $elem.css('max-height', '98%');\r\n\r\n            if(!$elem.css('height')) {\r\n                $elem.css('height', 'auto');\r\n            }\r\n\r\n            if(!$elem.css('width')) {\r\n                $elem.css('width', 'auto');\r\n            }\r\n\r\n        });\r\n    }\r\n\r\n    this.bookmarkCurrentPage = function() {\r\n\r\n        if(!_currentSpineItem) {\r\n\r\n            return undefined;\r\n        }\r\n\r\n        return self.getFirstVisibleCfi();\r\n    };\r\n\r\n    this.getLoadedSpineItems = function() {\r\n        return [_currentSpineItem];\r\n    };\r\n\r\n    this.getElementByCfi = function(spineItemIdref, cfi, classBlacklist, elementBlacklist, idBlacklist) {\r\n\r\n        if(spineItemIdref != _currentSpineItem.idref) {\r\n            console.warn(\"spine item is not loaded\");\r\n            return undefined;\r\n        }\r\n\r\n        return _navigationLogic.getElementByCfi(cfi, classBlacklist, elementBlacklist, idBlacklist);\r\n    };\r\n\r\n    this.getElementById = function(spineItemIdref, id) {\r\n\r\n        if(spineItemIdref != _currentSpineItem.idref) {\r\n            console.error(\"spine item is not loaded\");\r\n            return undefined;\r\n        }\r\n\r\n        return _navigationLogic.getElementById(id);\r\n    };\r\n\r\n    this.getElement = function(spineItemIdref, selector) {\r\n\r\n        if(spineItemIdref != _currentSpineItem.idref) {\r\n            console.warn(\"spine item is not loaded\");\r\n            return undefined;\r\n        }\r\n\r\n        return _navigationLogic.getElement(selector);\r\n    };\r\n\r\n    this.getFirstVisibleMediaOverlayElement = function() {\r\n\r\n        return _navigationLogic.getFirstVisibleMediaOverlayElement();\r\n    };\r\n\r\n    this.insureElementVisibility = function(spineItemId, element, initiator) {\r\n\r\n        var $element = $(element);\r\n        if(_navigationLogic.isElementVisible($element))\r\n        {\r\n            return;\r\n        }\r\n\r\n        var page = _navigationLogic.getPageForElement($element);\r\n\r\n        if(page == -1)\r\n        {\r\n            return;\r\n        }\r\n\r\n        var openPageRequest = new PageOpenRequest(_currentSpineItem, initiator);\r\n        openPageRequest.setPageIndex(page);\r\n\r\n        var id = element.id;\r\n        if (!id)\r\n        {\r\n            id = element.getAttribute(\"id\");\r\n        }\r\n\r\n        if (id)\r\n        {\r\n            openPageRequest.setElementId(id);\r\n        }\r\n\r\n        self.openPage(openPageRequest);\r\n    };\r\n\r\n    this.getVisibleElementsWithFilter = function(filterFunction, includeSpineItem) {\r\n\r\n        var elements = _navigationLogic.getVisibleElementsWithFilter(null, filterFunction);\r\n\r\n        if (includeSpineItem) {\r\n            return [{elements: elements, spineItem:_currentSpineItem}];\r\n        } else {\r\n            return elements;\r\n        }\r\n\r\n    };\r\n\r\n    this.getVisibleElements = function(selector, includeSpineItem) {\r\n\r\n        var elements = _navigationLogic.getAllVisibleElementsWithSelector(selector);\r\n\r\n        if (includeSpineItem) {\r\n            return [{elements: elements, spineItem:_currentSpineItem}];\r\n        } else {\r\n            return elements;\r\n        }\r\n\r\n    };\r\n\r\n    this.isElementVisible = function ($element) {\r\n\r\n        return _navigationLogic.isElementVisible($element);\r\n\r\n    };\r\n\r\n    this.getElements = function(spineItemIdref, selector) {\r\n\r\n        if(spineItemIdref != _currentSpineItem.idref) {\r\n            console.warn(\"spine item is not loaded\");\r\n            return undefined;\r\n        }\r\n\r\n        return _navigationLogic.getElements(selector);\r\n    };\r\n\r\n    this.isNodeFromRangeCfiVisible = function (spineIdref, partialCfi) {\r\n        if (_currentSpineItem.idref === spineIdref) {\r\n            return _navigationLogic.isNodeFromRangeCfiVisible(partialCfi);\r\n        }\r\n        return undefined;\r\n    };\r\n\r\n    this.isVisibleSpineItemElementCfi = function (spineIdRef, partialCfi) {\r\n        if (_navigationLogic.isRangeCfi(partialCfi)) {\r\n            return this.isNodeFromRangeCfiVisible(spineIdRef, partialCfi);\r\n        }\r\n        var $elementFromCfi = this.getElementByCfi(spineIdRef, partialCfi);\r\n        return ($elementFromCfi && this.isElementVisible($elementFromCfi));\r\n    };\r\n\r\n    this.getNodeRangeInfoFromCfi = function (spineIdRef, partialCfi) {\r\n        if (spineIdRef != _currentSpineItem.idref) {\r\n            console.warn(\"spine item is not loaded\");\r\n            return undefined;\r\n        }\r\n\r\n        return _navigationLogic.getNodeRangeInfoFromCfi(partialCfi);\r\n    };\r\n\r\n    function createBookmarkFromCfi(cfi){\r\n        return new BookmarkData(_currentSpineItem.idref, cfi);\r\n    }\r\n\r\n    this.getFirstVisibleCfi = function () {\r\n        return createBookmarkFromCfi(_navigationLogic.getFirstVisibleCfi());\r\n    };\r\n\r\n    this.getLastVisibleCfi = function () {\r\n        return createBookmarkFromCfi(_navigationLogic.getLastVisibleCfi());\r\n    };\r\n\r\n    this.getDomRangeFromRangeCfi = function (rangeCfi, rangeCfi2, inclusive) {\r\n        if (rangeCfi2 && rangeCfi.idref !== rangeCfi2.idref) {\r\n            console.error(\"getDomRangeFromRangeCfi: both CFIs must be scoped under the same spineitem idref\");\r\n            return undefined;\r\n        }\r\n        return _navigationLogic.getDomRangeFromRangeCfi(rangeCfi.contentCFI, rangeCfi2? rangeCfi2.contentCFI: null, inclusive);\r\n    };\r\n\r\n    this.getRangeCfiFromDomRange = function (domRange) {\r\n        return createBookmarkFromCfi(_navigationLogic.getRangeCfiFromDomRange(domRange));\r\n    };\r\n\r\n    this.getVisibleCfiFromPoint = function (x, y, precisePoint) {\r\n        return createBookmarkFromCfi(_navigationLogic.getVisibleCfiFromPoint(x, y, precisePoint));\r\n    };\r\n\r\n    this.getRangeCfiFromPoints = function(startX, startY, endX, endY) {\r\n        return createBookmarkFromCfi(_navigationLogic.getRangeCfiFromPoints(startX, startY, endX, endY));\r\n    };\r\n\r\n    this.getCfiForElement = function(element) {\r\n        return createBookmarkFromCfi(_navigationLogic.getCfiForElement(element));\r\n    };\r\n\r\n    this.getElementFromPoint = function(x, y) {\r\n        return _navigationLogic.getElementFromPoint(x,y);\r\n    };\r\n};\r\n    return ReflowableView;\r\n});\r\n\n",
    "//  Created by Boris Schneiderman.\r\n//  Copyright (c) 2014 Readium Foundation and/or its licensees. All rights reserved.\r\n//  \r\n//  Redistribution and use in source and binary forms, with or without modification, \r\n//  are permitted provided that the following conditions are met:\r\n//  1. Redistributions of source code must retain the above copyright notice, this \r\n//  list of conditions and the following disclaimer.\r\n//  2. Redistributions in binary form must reproduce the above copyright notice, \r\n//  this list of conditions and the following disclaimer in the documentation and/or \r\n//  other materials provided with the distribution.\r\n//  3. Neither the name of the organization nor the names of its contributors may be \r\n//  used to endorse or promote products derived from this software without specific \r\n//  prior written permission.\r\n//  \r\n//  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND \r\n//  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED \r\n//  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. \r\n//  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, \r\n//  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, \r\n//  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, \r\n//  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF \r\n//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE \r\n//  OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED \r\n//  OF THE POSSIBILITY OF SUCH DAMAGE.\r\n\r\ndefine('readium_shared_js/models/style',[], function() {\r\n/**\r\n * @class Models.Style\r\n * @constructor\r\n * @param selector\r\n * @param declarations\r\n */\r\nvar Style = function(selector, declarations) {\r\n\r\n    /**\r\n     * Initializing the selector\r\n     *\r\n     * @property selector\r\n     * @type \r\n     */\r\n\r\n    this.selector = selector;\r\n\r\n    /**\r\n     * Initializing the declarations\r\n     *\r\n     * @property selector\r\n     * @type \r\n     */\r\n\r\n    this.declarations = declarations;\r\n\r\n    /**\r\n     * Set the declarations array\r\n     *\r\n     * @method setDeclarations\r\n     * @param {Object} declarations\r\n     */\r\n\r\n    this.setDeclarations = function(declarations) {\r\n\r\n        for(var prop in declarations) {\r\n            if(declarations.hasOwnProperty(prop)) {\r\n                this.declarations[prop] = declarations[prop];\r\n            }\r\n        }\r\n\r\n    }\r\n};\r\n    return Style;\r\n});\r\n\n",
    "    //  Created by Boris Schneiderman.\r\n//  Copyright (c) 2014 Readium Foundation and/or its licensees. All rights reserved.\r\n//  \r\n//  Redistribution and use in source and binary forms, with or without modification, \r\n//  are permitted provided that the following conditions are met:\r\n//  1. Redistributions of source code must retain the above copyright notice, this \r\n//  list of conditions and the following disclaimer.\r\n//  2. Redistributions in binary form must reproduce the above copyright notice, \r\n//  this list of conditions and the following disclaimer in the documentation and/or \r\n//  other materials provided with the distribution.\r\n//  3. Neither the name of the organization nor the names of its contributors may be \r\n//  used to endorse or promote products derived from this software without specific \r\n//  prior written permission.\r\n//  \r\n//  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND \r\n//  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED \r\n//  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. \r\n//  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, \r\n//  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, \r\n//  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, \r\n//  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF \r\n//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE \r\n//  OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED \r\n//  OF THE POSSIBILITY OF SUCH DAMAGE.\r\n\r\ndefine('readium_shared_js/models/style_collection',[\"./style\"], function(Style) {\r\n\r\n/**\r\n *\r\n * @class Models.StyleCollection\r\n * @return StyleCollection\r\n * @constructor\r\n */\r\n\r\nvar StyleCollection = function() {\r\n\r\n    var _styles = [];\r\n\r\n    /**\r\n     * Clears the collection.\r\n     *\r\n     * @method     clear\r\n     */\r\n\r\n    this.clear = function() {\r\n        _styles.length = 0;\r\n\r\n    };\r\n\r\n    /**\r\n     * Finds the style of a selected item\r\n     *\r\n     * @method     findStyle\r\n     * @param      selector\r\n     * @return     {Models.Style}\r\n     */\r\n\r\n    this.findStyle = function(selector) {\r\n\r\n        var count = _styles.length;\r\n        for(var i = 0; i < count; i++) {\r\n            if(_styles[i].selector === selector) {\r\n                return _styles[i];\r\n            }\r\n        }\r\n\r\n        return undefined;\r\n    };\r\n\r\n    /**\r\n     * Adds a style to the collection\r\n     *\r\n     * @method     addStyle\r\n     * @param      selector\r\n     * @param      declarations\r\n     * @return     {Models.Style}\r\n     */\r\n\r\n    this.addStyle = function(selector, declarations) {\r\n\r\n        var style = this.findStyle(selector);\r\n\r\n        if(style) {\r\n            style.setDeclarations(declarations);\r\n        }\r\n        else {\r\n            style = new Style(selector, declarations);\r\n            _styles.push(style);\r\n        }\r\n\r\n        return style;\r\n    };\r\n\r\n    /**\r\n     * Removes a style from the collection\r\n     *\r\n     * @method     addStyle\r\n     * @param      selector\r\n     */\r\n\r\n    this.removeStyle = function(selector) {\r\n        \r\n        var count = _styles.length;\r\n\r\n        for(var i = 0; i < count; i++) {\r\n\r\n            if(_styles[i].selector === selector) {\r\n                _styles.splice(i, 1);\r\n                return;\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Gets all styles\r\n     *\r\n     * @method     getStyles\r\n     * @return     {Array}\r\n     */\r\n\r\n    this.getStyles = function() {\r\n        return _styles;\r\n    };\r\n\r\n    /**\r\n     * Resets the styles\r\n     *\r\n     * @method     resetStyleValues\r\n     */\r\n\r\n    this.resetStyleValues = function() {\r\n\r\n        var count = _styles.length;\r\n\r\n        for(var i = 0; i < count; i++) {\r\n\r\n            var style = _styles[i];\r\n            var declarations = style.declarations;\r\n\r\n            for(var prop in declarations) {\r\n                if(declarations.hasOwnProperty(prop)) {\r\n                    declarations[prop] = '';\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n};\r\n    return StyleCollection;\r\n});\r\n\n",
    "//  LauncherOSX\r\n//\r\n//  Created by Boris Schneiderman.\r\n//  Copyright (c) 2014 Readium Foundation and/or its licensees. All rights reserved.\r\n//  \r\n//  Redistribution and use in source and binary forms, with or without modification, \r\n//  are permitted provided that the following conditions are met:\r\n//  1. Redistributions of source code must retain the above copyright notice, this \r\n//  list of conditions and the following disclaimer.\r\n//  2. Redistributions in binary form must reproduce the above copyright notice, \r\n//  this list of conditions and the following disclaimer in the documentation and/or \r\n//  other materials provided with the distribution.\r\n//  3. Neither the name of the organization nor the names of its contributors may be \r\n//  used to endorse or promote products derived from this software without specific \r\n//  prior written permission.\r\n//  \r\n//  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND \r\n//  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED \r\n//  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. \r\n//  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, \r\n//  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, \r\n//  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, \r\n//  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF \r\n//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE \r\n//  OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED \r\n//  OF THE POSSIBILITY OF SUCH DAMAGE.\r\ndefine('readium_shared_js/models/switches',[\"jquery\", \"underscore\"], function($, _) {\r\n/** \r\n * Switches in the epub publication.\r\n * \r\n * @class Models.Switches\r\n * @constructor\r\n */\r\nvar Switches = function() {\r\n\r\n};\r\n\r\n// Description: Parse the epub \"switch\" tags and hide\r\n// cases that are not supported\r\n\r\n/**\r\n *\r\n * Static Switches.apply method.\r\n * \r\n * @method Switches.apply\r\n * @param dom\r\n */\r\n\r\nSwitches.apply = function(dom) {\r\n\r\n    function isSupported(caseNode) {\r\n\r\n        var ns = caseNode.attributes[\"required-namespace\"];\r\n        if(!ns) {\r\n            // the namespace was not specified, that should\r\n            // never happen, we don't support it then\r\n            console.log(\"Encountered a case statement with no required-namespace\");\r\n            return false;\r\n        }\r\n        // all the xmlns that readium is known to support\r\n        // TODO this is going to require maintenance\r\n        var supportedNamespaces = [\"http://www.w3.org/1998/Math/MathML\"];\r\n        return _.include(supportedNamespaces, ns.value);\r\n    }\r\n\r\n    var getQuery = ((window.navigator.userAgent.indexOf(\"Trident\") > 0) || (window.navigator.userAgent.indexOf(\"Edge\") > 0))\r\n        ? function (elementName) { return 'epub\\\\:' + elementName; }\r\n        : function (elementName) { return elementName; };\r\n\r\n    _.each(dom.querySelectorAll(getQuery('switch')), function(switchNode) {\r\n\r\n        // keep track of whether or now we found one\r\n        var found = false;\r\n\r\n        _.each(switchNode.querySelectorAll(getQuery('case')), function(caseNode) {\r\n\r\n            if( !found && isSupported(caseNode) ) {\r\n                found = true; // we found the node, don't remove it\r\n            }\r\n            else {\r\n                $(caseNode).remove(); // remove the node from the dom\r\n            }\r\n\r\n        });\r\n\r\n        if (found) {\r\n\r\n            // if we found a supported case, remove the default\r\n            _.each(switchNode.querySelectorAll(getQuery('default')), function(defaultNode) {\r\n                $(defaultNode).remove();\r\n            });\r\n\r\n        }\r\n\r\n    });\r\n};\r\n    return Switches;\r\n});\r\n\n",
    "//  LauncherOSX\r\n//\r\n//  Created by Boris Schneiderman.\r\n//  Copyright (c) 2014 Readium Foundation and/or its licensees. All rights reserved.\r\n//  \r\n//  Redistribution and use in source and binary forms, with or without modification, \r\n//  are permitted provided that the following conditions are met:\r\n//  1. Redistributions of source code must retain the above copyright notice, this \r\n//  list of conditions and the following disclaimer.\r\n//  2. Redistributions in binary form must reproduce the above copyright notice, \r\n//  this list of conditions and the following disclaimer in the documentation and/or \r\n//  other materials provided with the distribution.\r\n//  3. Neither the name of the organization nor the names of its contributors may be \r\n//  used to endorse or promote products derived from this software without specific \r\n//  prior written permission.\r\n//  \r\n//  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND \r\n//  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED \r\n//  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. \r\n//  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, \r\n//  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, \r\n//  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, \r\n//  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF \r\n//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE \r\n//  OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED \r\n//  OF THE POSSIBILITY OF SUCH DAMAGE.\r\n\r\ndefine('readium_shared_js/models/trigger',[\"jquery\", \"../helpers\"], function($, Helpers) {\r\n/**\r\n * Trigger in an epub publication.\r\n *\r\n * @class Models.Trigger\r\n * @constructor\r\n * @param domNode\r\n */\r\n\r\nvar Trigger = function(domNode) {\r\n\r\n    var $el = $(domNode);\r\n    \r\n    /**\r\n     * epub trigger action\r\n     *\r\n     * @property action\r\n     * @type String\r\n     */\r\n\r\n    this.action     = $el.attr(\"action\");\r\n    \r\n    /**\r\n     * epub trigger ref\r\n     *\r\n     * @property ref\r\n     * @type String\r\n     */\r\n\r\n    this.ref         = $el.attr(\"ref\");\r\n    \r\n    /**\r\n     * epub trigger event\r\n     *\r\n     * @property event\r\n     * @type String\r\n     */\r\n\r\n    this.event         = $el.attr(\"ev:event\");\r\n    \r\n    /**\r\n     * epub trigger observer\r\n     *\r\n     * @property observer\r\n     * @type String\r\n     */\r\n\r\n    this.observer     = $el.attr(\"ev:observer\");\r\n    this.ref         = $el.attr(\"ref\");\r\n};\r\n\r\n/**\r\n * Static register method\r\n *\r\n * @method register\r\n * @param dom\r\n */\r\nTrigger.register = function(dom) {\r\n    $('trigger', dom).each(function() {\r\n        var trigger = new Trigger(this);\r\n        trigger.subscribe(dom);\r\n    });\r\n};\r\n\r\n/**\r\n * Prototype subscribe method\r\n *\r\n * @method subscribe\r\n * @param dom\r\n */\r\n\r\nTrigger.prototype.subscribe = function(dom) {\r\n    \r\n    var selector = \"#\" + this.observer;\r\n    var that = this;\r\n    $(selector, dom).on(this.event, function() {\r\n        that.execute(dom);\r\n    });\r\n};\r\n\r\n/**\r\n * Prototype execute method\r\n *\r\n * @method execute\r\n * @param dom\r\n */\r\n\r\nTrigger.prototype.execute = function(dom) {\r\n\r\n    var $target = $( \"#\" + Helpers.escapeJQuerySelector(this.ref), dom);\r\n    switch(this.action)\r\n    {\r\n        case \"show\":\r\n            $target.css(\"visibility\", \"visible\");\r\n            break;\r\n        case \"hide\":\r\n            $target.css(\"visibility\", \"hidden\");\r\n            break;\r\n        case \"play\":\r\n            $target[0].currentTime = 0;\r\n            $target[0].play();\r\n            break;\r\n        case \"pause\":\r\n            $target[0].pause();\r\n            break;\r\n        case \"resume\":\r\n            $target[0].play();\r\n            break;\r\n        case \"mute\":\r\n            $target[0].muted = true;\r\n            break;\r\n        case \"unmute\":\r\n            $target[0].muted = false;\r\n            break;\r\n        default:\r\n            console.log(\"do not no how to handle trigger \" + this.action);\r\n    }\r\n};\r\n\r\n    return Trigger;\r\n});\r\n\n",
    "//  Created by Juan Corona\r\n//  Copyright (c) 2016 Readium Foundation and/or its licensees. All rights reserved.\r\n//\r\n//  Redistribution and use in source and binary forms, with or without modification,\r\n//  are permitted provided that the following conditions are met:\r\n//  1. Redistributions of source code must retain the above copyright notice, this\r\n//  list of conditions and the following disclaimer.\r\n//  2. Redistributions in binary form must reproduce the above copyright notice,\r\n//  this list of conditions and the following disclaimer in the documentation and/or\r\n//  other materials provided with the distribution.\r\n//  3. Neither the name of the organization nor the names of its contributors may be\r\n//  used to endorse or promote products derived from this software without specific\r\n//  prior written permission.\r\n//\r\n//  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\r\n//  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n//  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\r\n//  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\r\n//  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\r\n//  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\r\n//  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\r\n//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE\r\n//  OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\r\n//  OF THE POSSIBILITY OF SUCH DAMAGE.\r\n\r\ndefine('readium_shared_js/models/node_range_info',[],function () {\r\n\r\n    /**\r\n     * @class Models.NodeRangePositionInfo\r\n     * @constructor\r\n     * @param {Node} node The actual DOM node\r\n     * @param {Number} offest The position offsetf for the node\r\n     */\r\n    var NodeRangePositionInfo = function (node, offset) {\r\n\r\n        /**\r\n         * The actual DOM node\r\n         * @property node\r\n         * @type Node\r\n         */\r\n        this.node = node;\r\n\r\n        /**\r\n         * The position offsetf for the node\r\n         * @property offset\r\n         * @type Number\r\n         */\r\n        this.offset = offset;\r\n\r\n    };\r\n\r\n    /**\r\n     * @class Models.NodeRangeInfo\r\n     * @constructor\r\n     * @param {ClientRect} clientRect\r\n     * @param {Models.NodeRangePositionInfo} startInfo\r\n     * @param {Models.NodeRangePositionInfo} endInfo\r\n     */\r\n    var NodeRangeInfo = function (clientRect, startInfo, endInfo) {\r\n\r\n        var self = this;\r\n        /**\r\n         * Client rectangle information for the range content bounds\r\n         * @property clientRect\r\n         * @type ClientRect\r\n         */\r\n        this.clientRect = clientRect;\r\n\r\n        /**\r\n         * Node and position information providing where and which node the range starts with\r\n         * @property startInfo\r\n         * @type Models.NodeRangePositionInfo\r\n         */\r\n        this.startInfo = startInfo;\r\n\r\n        /**\r\n         * Node and position information providing where and which node the range ends with\r\n         * @property endInfo\r\n         * @type Models.NodeRangePositionInfo\r\n         */\r\n        this.endInfo = endInfo;\r\n\r\n\r\n        this.setStartInfo = function (info) {\r\n            self.startInfo = new NodeRangePositionInfo(info);\r\n            return self;\r\n        };\r\n\r\n        this.setEndInfo = function (info) {\r\n            self.endInfo = new NodeRangePositionInfo(info);\r\n            return self;\r\n        };\r\n    };\r\n\r\n    return NodeRangeInfo;\r\n});\n",
    "//  Created by Boris Schneiderman.\r\n// Modified by Daniel Weck\r\n//  Copyright (c) 2014 Readium Foundation and/or its licensees. All rights reserved.\r\n//  \r\n//  Redistribution and use in source and binary forms, with or without modification, \r\n//  are permitted provided that the following conditions are met:\r\n//  1. Redistributions of source code must retain the above copyright notice, this \r\n//  list of conditions and the following disclaimer.\r\n//  2. Redistributions in binary form must reproduce the above copyright notice, \r\n//  this list of conditions and the following disclaimer in the documentation and/or \r\n//  other materials provided with the distribution.\r\n//  3. Neither the name of the organization nor the names of its contributors may be \r\n//  used to endorse or promote products derived from this software without specific \r\n//  prior written permission.\r\n//  \r\n//  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND \r\n//  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED \r\n//  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. \r\n//  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, \r\n//  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, \r\n//  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, \r\n//  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF \r\n//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE \r\n//  OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED \r\n//  OF THE POSSIBILITY OF SUCH DAMAGE.\r\n\r\ndefine('readium_shared_js/views/reader_view',[\"../globals\", \"jquery\", \"underscore\", \"eventEmitter\", \"./fixed_view\", \"../helpers\", \"./iframe_loader\", \"./internal_links_support\",\r\n        \"./media_overlay_data_injector\", \"./media_overlay_player\", \"../models/package\", \"../models/page_open_request\",\r\n        \"./reflowable_view\", \"./scroll_view\", \"../models/style_collection\", \"../models/switches\", \"../models/trigger\",\r\n        \"../models/viewer_settings\", \"../models/bookmark_data\", \"../models/node_range_info\"],\r\n    function (Globals, $, _, EventEmitter, FixedView, Helpers, IFrameLoader, InternalLinksSupport,\r\n              MediaOverlayDataInjector, MediaOverlayPlayer, Package, PageOpenRequest,\r\n              ReflowableView, ScrollView, StyleCollection, Switches, Trigger,\r\n              ViewerSettings, BookmarkData, NodeRangeInfo) {\r\n/**\r\n * Options passed on the reader from the readium loader/initializer\r\n *\r\n * @typedef {object} Globals.Views.ReaderView.ReaderOptions\r\n * @property {jQueryElement|string} el   The element the reader view should create itself in. Can be a jquery wrapped element or a query selector.\r\n * @property {Globals.Views.IFrameLoader} iframeLoader   An instance of an iframe loader or one expanding it.\r\n * @property {boolean} needsFixedLayoutScalerWorkAround\r\n */\r\n\r\n/**\r\n * Top level View object. Interface for view manipulation public APIs\r\n * @param {Views.ReaderView.ReaderOptions} options\r\n * @constructor\r\n */\r\nvar ReaderView = function (options) {\r\n\r\n    $.extend(this, new EventEmitter());\r\n\r\n    var self = this;\r\n    var _currentView = undefined;\r\n    var _package = undefined;\r\n    var _spine = undefined;\r\n    var _viewerSettings = new ViewerSettings({});\r\n    //styles applied to the container divs\r\n    var _userStyles = new StyleCollection();\r\n    //styles applied to the content documents\r\n    var _bookStyles = new StyleCollection();\r\n    var _internalLinksSupport = new InternalLinksSupport(this);\r\n    var _mediaOverlayPlayer;\r\n    var _mediaOverlayDataInjector;\r\n    var _iframeLoader;\r\n    var _$el;\r\n\r\n    //We will call onViewportResize after user stopped resizing window\r\n    var lazyResize = Helpers.extendedThrottle(\r\n        handleViewportResizeStart,\r\n        handleViewportResizeTick,\r\n        handleViewportResizeEnd, 250, 1000, self);\r\n\r\n    $(window).on(\"resize.ReadiumSDK.readerView\", lazyResize);\r\n\r\n    if (options.el instanceof $) {\r\n        _$el = options.el;\r\n        console.log(\"** EL is a jQuery selector:\" + options.el.attr('id'));\r\n    } else {\r\n        _$el = $(options.el);\r\n        console.log(\"** EL is a string:\" + _$el.attr('id'));\r\n    }\r\n\r\n    if (options.iframeLoader) {\r\n        _iframeLoader = options.iframeLoader;\r\n    }\r\n    else {\r\n        _iframeLoader = new IFrameLoader({mathJaxUrl: options.mathJaxUrl});\r\n    }\r\n\r\n\r\n    _needsFixedLayoutScalerWorkAround = options.needsFixedLayoutScalerWorkAround;\r\n    /**\r\n     * @returns {boolean}\r\n     */\r\n    this.needsFixedLayoutScalerWorkAround = function () {\r\n        return _needsFixedLayoutScalerWorkAround;\r\n    };\r\n\r\n    /**\r\n     * Create a view based on the given view type.\r\n     * @param {Views.ReaderView.ViewType} viewType\r\n     * @param {Views.ReaderView.ViewCreationOptions} options\r\n     * @returns {*}\r\n     */\r\n    this.createViewForType = function (viewType, options) {\r\n        var createdView;\r\n\r\n        // NOTE: _$el == options.$viewport\r\n        _$el.css(\"overflow\", \"hidden\");\r\n\r\n        switch (viewType) {\r\n            case ReaderView.VIEW_TYPE_FIXED:\r\n\r\n                _$el.css(\"overflow\", \"auto\"); // for content pan, see self.setZoom()\r\n\r\n                createdView = new FixedView(options, self);\r\n                break;\r\n            case ReaderView.VIEW_TYPE_SCROLLED_DOC:\r\n                createdView = new ScrollView(options, false, self);\r\n                break;\r\n            case ReaderView.VIEW_TYPE_SCROLLED_CONTINUOUS:\r\n                createdView = new ScrollView(options, true, self);\r\n                break;\r\n            default:\r\n                createdView = new ReflowableView(options, self);\r\n                break;\r\n        }\r\n\r\n        return createdView;\r\n    };\r\n\r\n    /**\r\n     * Returns the current view type of the reader view\r\n     * @returns {ReaderView.ViewType}\r\n     */\r\n    this.getCurrentViewType = function () {\r\n\r\n        if (!_currentView) {\r\n            return undefined;\r\n        }\r\n\r\n        if (_currentView instanceof ReflowableView) {\r\n            return ReaderView.VIEW_TYPE_COLUMNIZED;\r\n        }\r\n\r\n        if (_currentView instanceof FixedView) {\r\n            return ReaderView.VIEW_TYPE_FIXED;\r\n        }\r\n\r\n        if (_currentView instanceof ScrollView) {\r\n            if (_currentView.isContinuousScroll()) {\r\n                return ReaderView.VIEW_TYPE_SCROLLED_CONTINUOUS;\r\n            }\r\n\r\n            return ReaderView.VIEW_TYPE_SCROLLED_DOC;\r\n        }\r\n\r\n        console.error(\"Unrecognized view type\");\r\n        return undefined;\r\n    };\r\n\r\n    this.getCurrentView = function () {\r\n        return _currentView;\r\n    };\r\n\r\n    //based on https://docs.google.com/spreadsheet/ccc?key=0AoPMUkQhc4wcdDI0anFvWm96N0xRT184ZE96MXFRdFE&usp=drive_web#gid=0 document\r\n    function deduceDesiredViewType(spineItem) {\r\n\r\n        //check settings\r\n        if (_viewerSettings.scroll == \"scroll-doc\") {\r\n            return ReaderView.VIEW_TYPE_SCROLLED_DOC;\r\n        }\r\n\r\n        if (_viewerSettings.scroll == \"scroll-continuous\") {\r\n            return ReaderView.VIEW_TYPE_SCROLLED_CONTINUOUS;\r\n        }\r\n\r\n        //is fixed layout ignore flow\r\n        if (spineItem.isFixedLayout()) {\r\n            return ReaderView.VIEW_TYPE_FIXED;\r\n        }\r\n\r\n        //flow\r\n        if (spineItem.isFlowScrolledDoc()) {\r\n            return ReaderView.VIEW_TYPE_SCROLLED_DOC;\r\n        }\r\n\r\n        if (spineItem.isFlowScrolledContinuous()) {\r\n            return ReaderView.VIEW_TYPE_SCROLLED_CONTINUOUS;\r\n        }\r\n\r\n        return ReaderView.VIEW_TYPE_COLUMNIZED;\r\n    }\r\n\r\n    // returns true is view changed\r\n    function initViewForItem(spineItem, callback) {\r\n\r\n        var desiredViewType = deduceDesiredViewType(spineItem);\r\n\r\n        if (_currentView) {\r\n\r\n            if (self.getCurrentViewType() == desiredViewType) {\r\n                callback(false);\r\n                return;\r\n            }\r\n\r\n            resetCurrentView();\r\n        }\r\n\r\n        /**\r\n         * View creation options\r\n         * @typedef {object} Globals.Views.ReaderView.ViewCreationOptions\r\n         * @property {jQueryElement} $viewport  The view port element the reader view has created.\r\n         * @property {Globals.Models.Spine} spine The spine item collection object\r\n         * @property {Globals.Collections.StyleCollection} userStyles User styles\r\n         * @property {Globals.Collections.StyleCollection} bookStyles Book styles\r\n         * @property {Globals.Views.IFrameLoader} iframeLoader   An instance of an iframe loader or one expanding it.\r\n         */\r\n        var viewCreationParams = {\r\n            $viewport: _$el,\r\n            spine: _spine,\r\n            userStyles: _userStyles,\r\n            bookStyles: _bookStyles,\r\n            iframeLoader: _iframeLoader\r\n        };\r\n\r\n\r\n        _currentView = self.createViewForType(desiredViewType, viewCreationParams);\r\n        \r\n        Globals.logEvent(\"READER_VIEW_CREATED\", \"EMIT\", \"reader_view.js\");\r\n        self.emit(Globals.Events.READER_VIEW_CREATED, desiredViewType);\r\n\r\n        _currentView.on(Globals.Events.CONTENT_DOCUMENT_LOADED, function ($iframe, spineItem) {\r\n            \r\n            Globals.logEvent(\"CONTENT_DOCUMENT_LOADED\", \"ON\", \"reader_view.js (current view) [ \" + spineItem.href + \" ]\");\r\n\r\n            if (!Helpers.isIframeAlive($iframe[0])) return;\r\n\r\n            // performance degrades with large DOM (e.g. word-level text-audio sync)\r\n            _mediaOverlayDataInjector.attachMediaOverlayData($iframe, spineItem, _viewerSettings);\r\n\r\n            _internalLinksSupport.processLinkElements($iframe, spineItem);\r\n\r\n            var contentDoc = $iframe[0].contentDocument;\r\n            Trigger.register(contentDoc);\r\n            Switches.apply(contentDoc);\r\n\r\n            Globals.logEvent(\"CONTENT_DOCUMENT_LOADED\", \"EMIT\", \"reader_view.js [ \" + spineItem.href + \" ]\");\r\n            self.emit(Globals.Events.CONTENT_DOCUMENT_LOADED, $iframe, spineItem);\r\n        });\r\n\r\n        _currentView.on(Globals.Events.CONTENT_DOCUMENT_LOAD_START, function ($iframe, spineItem) {\r\n\r\n            Globals.logEvent(\"CONTENT_DOCUMENT_LOAD_START\", \"EMIT\", \"reader_view.js [ \" + spineItem.href + \" ]\");\r\n            self.emit(Globals.Events.CONTENT_DOCUMENT_LOAD_START, $iframe, spineItem);\r\n        });\r\n\r\n        _currentView.on(Globals.Events.CONTENT_DOCUMENT_UNLOADED, function ($iframe, spineItem) {\r\n            \r\n            Globals.logEvent(\"CONTENT_DOCUMENT_UNLOADED\", \"EMIT\", \"reader_view.js [ \" + spineItem.href + \" ]\");\r\n            self.emit(Globals.Events.CONTENT_DOCUMENT_UNLOADED, $iframe, spineItem);\r\n        });\r\n\r\n        _currentView.on(Globals.InternalEvents.CURRENT_VIEW_PAGINATION_CHANGED, function (pageChangeData) {\r\n            \r\n            Globals.logEvent(\"InternalEvents.CURRENT_VIEW_PAGINATION_CHANGED\", \"ON\", \"reader_view.js\");\r\n\r\n            //we call on onPageChanged explicitly instead of subscribing to the Globals.Events.PAGINATION_CHANGED by\r\n            //mediaOverlayPlayer because we hve to guarantee that mediaOverlayPlayer will be updated before the host\r\n            //application will be notified by the same Globals.Events.PAGINATION_CHANGED event\r\n            _mediaOverlayPlayer.onPageChanged(pageChangeData);\r\n\r\n            _.defer(function () {\r\n                Globals.logEvent(\"PAGINATION_CHANGED\", \"EMIT\", \"reader_view.js\");\r\n                self.emit(Globals.Events.PAGINATION_CHANGED, pageChangeData);\r\n            });\r\n        });\r\n\r\n        _currentView.on(Globals.Events.FXL_VIEW_RESIZED, function () {\r\n            Globals.logEvent(\"FXL_VIEW_RESIZED\", \"EMIT\", \"reader_view.js\");\r\n            self.emit(Globals.Events.FXL_VIEW_RESIZED);\r\n        })\r\n\r\n        _currentView.render();\r\n        _currentView.setViewSettings(_viewerSettings);\r\n\r\n        // we do this to wait until elements are rendered otherwise book is not able to determine view size.\r\n        setTimeout(function () {\r\n\r\n            callback(true);\r\n\r\n        }, 50);\r\n\r\n    }\r\n\r\n    /**\r\n     * Returns a list of the currently active spine items\r\n     *\r\n     * @returns {Models.SpineItem[]}\r\n     */\r\n    this.getLoadedSpineItems = function () {\r\n\r\n        if (_currentView) {\r\n            return _currentView.getLoadedSpineItems();\r\n        }\r\n\r\n        return [];\r\n    };\r\n\r\n    function resetCurrentView() {\r\n\r\n        if (!_currentView) {\r\n            return;\r\n        }\r\n\r\n        Globals.logEvent(\"READER_VIEW_DESTROYED\", \"EMIT\", \"reader_view.js\");\r\n        self.emit(Globals.Events.READER_VIEW_DESTROYED);\r\n\r\n\r\n        Globals.logEvent(\"InternalEvents.CURRENT_VIEW_PAGINATION_CHANGED\", \"OFF\", \"reader_view.js\");\r\n        _currentView.off(Globals.InternalEvents.CURRENT_VIEW_PAGINATION_CHANGED);\r\n        \r\n        _currentView.remove();\r\n        _currentView = undefined;\r\n    }\r\n\r\n    /**\r\n     * Returns the currently instanced viewer settings\r\n     *\r\n     * @returns {Models.ViewerSettings}\r\n     */\r\n    this.viewerSettings = function () {\r\n        return _viewerSettings;\r\n    };\r\n\r\n    /**\r\n     * Returns a data object based on the package document\r\n     *\r\n     * @returns {Models.Package}\r\n     */\r\n    this.package = function () {\r\n        return _package;\r\n    };\r\n\r\n    /**\r\n     * Returns a representation of the spine as a data object, also acts as list of spine items\r\n     *\r\n     * @returns {Models.Spine}\r\n     */\r\n    this.spine = function () {\r\n        return _spine;\r\n    };\r\n\r\n    /**\r\n     * Returns the user CSS styles collection\r\n     *\r\n     * @returns {Collections.StyleCollection}\r\n     */\r\n    this.userStyles = function () {\r\n        return _userStyles;\r\n    };\r\n\r\n    /**\r\n     * Open Book Data\r\n     *\r\n     * @typedef {object} Globals.Views.ReaderView.OpenBookData\r\n     * @property {Globals.Models.Package} package - packageData (required)\r\n     * @property {Globals.Models.PageOpenRequest} openPageRequest - openPageRequestData, (optional) data related to open page request\r\n     * @property {Globals.Views.ReaderView.SettingsData} [settings]\r\n     * @property {Globals.Collections.StyleCollection} styles: [cssStyles]\r\n     * @todo Define missing types\r\n     */\r\n\r\n    /**\r\n     * Triggers the process of opening the book and requesting resources specified in the packageData\r\n     *\r\n     * @param {Views.ReaderView.OpenBookData} openBookData Open book data object\r\n     */\r\n    this.openBook = function (openBookData) {\r\n\r\n        var packageData = openBookData.package ? openBookData.package : openBookData;\r\n\r\n        _package = new Package(packageData);\r\n\r\n        _spine = _package.spine;\r\n        _spine.handleLinear(true);\r\n\r\n        if (_mediaOverlayPlayer) {\r\n            _mediaOverlayPlayer.reset();\r\n        }\r\n\r\n        _mediaOverlayPlayer = new MediaOverlayPlayer(self, $.proxy(onMediaPlayerStatusChanged, self));\r\n        _mediaOverlayPlayer.setAutomaticNextSmil(_viewerSettings.mediaOverlaysAutomaticPageTurn ? true : false); // just to ensure the internal var is set to the default settings (user settings are applied below at self.updateSettings(openBookData.settings);)\r\n\r\n        _mediaOverlayDataInjector = new MediaOverlayDataInjector(_package.media_overlay, _mediaOverlayPlayer);\r\n\r\n\r\n        resetCurrentView();\r\n\r\n        if (openBookData.settings) {\r\n            self.updateSettings(openBookData.settings);\r\n        }\r\n\r\n        if (openBookData.styles) {\r\n            self.setStyles(openBookData.styles);\r\n        }\r\n\r\n        var pageRequestData = undefined;\r\n\r\n        if (openBookData.openPageRequest) {\r\n\r\n            if (openBookData.openPageRequest.idref || (openBookData.openPageRequest.contentRefUrl && openBookData.openPageRequest.sourceFileHref)) {\r\n                pageRequestData = openBookData.openPageRequest;\r\n            }\r\n            else {\r\n                console.log(\"Invalid page request data: idref required!\");\r\n            }\r\n        }\r\n\r\n        var fallback = false;\r\n        if (pageRequestData) {\r\n\r\n            pageRequestData = openBookData.openPageRequest;\r\n\r\n            try {\r\n                if (pageRequestData.idref) {\r\n\r\n                    if (pageRequestData.spineItemPageIndex) {\r\n                        fallback = !self.openSpineItemPage(pageRequestData.idref, pageRequestData.spineItemPageIndex, self);\r\n                    }\r\n                    else if (pageRequestData.elementCfi) {\r\n                        fallback = !self.openSpineItemElementCfi(pageRequestData.idref, pageRequestData.elementCfi, self);\r\n                    }\r\n                    else {\r\n                        fallback = !self.openSpineItemPage(pageRequestData.idref, 0, self);\r\n                    }\r\n                }\r\n                else {\r\n                    fallback = !self.openContentUrl(pageRequestData.contentRefUrl, pageRequestData.sourceFileHref, self);\r\n                }\r\n            } catch (err) {\r\n                console.error(\"openPageRequest fail: fallback to first page!\")\r\n                console.log(err);\r\n                fallback = true;\r\n            }\r\n        }\r\n        else {\r\n            fallback = true;\r\n        }\r\n\r\n        if (fallback) {// if we where not asked to open specific page we will open the first one\r\n\r\n            var spineItem = _spine.first();\r\n            if (spineItem) {\r\n                var pageOpenRequest = new PageOpenRequest(spineItem, self);\r\n                pageOpenRequest.setFirstPage();\r\n                openPage(pageOpenRequest, 0);\r\n            }\r\n\r\n        }\r\n\r\n    };\r\n\r\n    function onMediaPlayerStatusChanged(status) {\r\n\r\n        Globals.logEvent(\"MEDIA_OVERLAY_STATUS_CHANGED\", \"EMIT\", \"reader_view.js (via MediaOverlayPlayer + AudioPlayer)\");\r\n        self.emit(Globals.Events.MEDIA_OVERLAY_STATUS_CHANGED, status);\r\n    }\r\n\r\n    /**\r\n     * Flips the page from left to right.\r\n     * Takes to account the page progression direction to decide to flip to prev or next page.\r\n     */\r\n    this.openPageLeft = function () {\r\n\r\n        if (_package.spine.isLeftToRight()) {\r\n            self.openPagePrev();\r\n        }\r\n        else {\r\n            self.openPageNext();\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Flips the page from right to left.\r\n     * Takes to account the page progression direction to decide to flip to prev or next page.\r\n     */\r\n    this.openPageRight = function () {\r\n\r\n        if (_package.spine.isLeftToRight()) {\r\n            self.openPageNext();\r\n        }\r\n        else {\r\n            self.openPagePrev();\r\n        }\r\n\r\n    };\r\n\r\n    /**\r\n     * Returns if the current child view is an instance of a fixed page view\r\n     *\r\n     * @returns {boolean}\r\n     */\r\n    this.isCurrentViewFixedLayout = function () {\r\n        return _currentView instanceof FixedView;\r\n    };\r\n\r\n    /**\r\n     * Zoom options\r\n     *\r\n     * @typedef {object} Globals.Views.ReaderView.ZoomOptions\r\n     * @property {string} style - \"user\"|\"fit-screen\"|\"fit-width\"\r\n     * @property {number} scale - 0.0 to 1.0\r\n     */\r\n\r\n    /**\r\n     * Set the zoom options.\r\n     *\r\n     * @param {Views.ReaderView.ZoomOptions} zoom Zoom options\r\n     */\r\n    this.setZoom = function (zoom) {\r\n        // zoom only handled by fixed layout views\r\n        if (self.isCurrentViewFixedLayout()) {\r\n            _currentView.setZoom(zoom);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Returns the current view scale as a percentage\r\n     *\r\n     * @returns {number}\r\n     */\r\n    this.getViewScale = function () {\r\n        if (self.isCurrentViewFixedLayout()) {\r\n            return 100 * _currentView.getViewScale();\r\n        }\r\n        else {\r\n            return 100;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Settings Data\r\n     *\r\n     * @typedef {object} Globals.Views.ReaderView.SettingsData\r\n     * @property {number} fontSize - Font size as percentage\r\n     * @property {(string|boolean)} syntheticSpread - \"auto\"|true|false\r\n     * @property {(string|boolean)} scroll - \"auto\"|true|false\r\n     * @property {boolean} doNotUpdateView - Indicates whether the view should be updated after the settings are applied\r\n     * @property {boolean} mediaOverlaysEnableClick - Indicates whether media overlays are interactive on mouse clicks\r\n     */\r\n\r\n    /**\r\n     * Updates reader view based on the settings specified in settingsData object\r\n     *\r\n     * @param {Globals.Views.ReaderView.SettingsData} settingsData Settings data\r\n     * @fires Globals.Events.SETTINGS_APPLIED\r\n     */\r\n    this.updateSettings = function (settingsData) {\r\n\r\n//console.debug(\"UpdateSettings: \" + JSON.stringify(settingsData));\r\n\r\n        _viewerSettings.update(settingsData);\r\n\r\n        if (_mediaOverlayPlayer) {\r\n            _mediaOverlayPlayer.setAutomaticNextSmil(_viewerSettings.mediaOverlaysAutomaticPageTurn ? true : false);\r\n        }\r\n\r\n        if (_currentView && !settingsData.doNotUpdateView) {\r\n\r\n            var bookMark = _currentView.bookmarkCurrentPage();\r\n\r\n            if (bookMark && bookMark.idref) {\r\n\r\n                var wasPlaying = false;\r\n                if (_currentView.isReflowable && _currentView.isReflowable()) {\r\n                    wasPlaying = self.isPlayingMediaOverlay();\r\n                    if (wasPlaying) {\r\n                        self.pauseMediaOverlay();\r\n                    }\r\n                }\r\n\r\n                var spineItem = _spine.getItemById(bookMark.idref);\r\n\r\n                initViewForItem(spineItem, function (isViewChanged) {\r\n\r\n                    if (!isViewChanged) {\r\n                        _currentView.setViewSettings(_viewerSettings);\r\n                    }\r\n\r\n                    self.openSpineItemElementCfi(bookMark.idref, bookMark.contentCFI, self);\r\n\r\n                    if (wasPlaying) {\r\n                        self.playMediaOverlay();\r\n                        // setTimeout(function()\r\n                        // {\r\n                        // }, 60);\r\n                    }\r\n\r\n                    Globals.logEvent(\"SETTINGS_APPLIED 1 (view update)\", \"EMIT\", \"reader_view.js\");\r\n                    self.emit(Globals.Events.SETTINGS_APPLIED);\r\n                });\r\n                \r\n                return;\r\n            }\r\n        }\r\n\r\n        Globals.logEvent(\"SETTINGS_APPLIED 2 (no view update)\", \"EMIT\", \"reader_view.js\");\r\n        self.emit(Globals.Events.SETTINGS_APPLIED);\r\n    };\r\n\r\n    /**\r\n     * Opens the next page.\r\n     */\r\n    this.openPageNext = function () {\r\n\r\n        if (self.getCurrentViewType() === ReaderView.VIEW_TYPE_SCROLLED_CONTINUOUS) {\r\n            _currentView.openPageNext(self);\r\n            return;\r\n        }\r\n\r\n        var paginationInfo = _currentView.getPaginationInfo();\r\n\r\n        if (paginationInfo.openPages.length == 0) {\r\n            return;\r\n        }\r\n\r\n        var lastOpenPage = paginationInfo.openPages[paginationInfo.openPages.length - 1];\r\n\r\n        if (lastOpenPage.spineItemPageIndex < lastOpenPage.spineItemPageCount - 1) {\r\n            _currentView.openPageNext(self);\r\n            return;\r\n        }\r\n\r\n        var currentSpineItem = _spine.getItemById(lastOpenPage.idref);\r\n\r\n        var nextSpineItem = _spine.nextItem(currentSpineItem);\r\n\r\n        if (!nextSpineItem) {\r\n            return;\r\n        }\r\n\r\n        var openPageRequest = new PageOpenRequest(nextSpineItem, self);\r\n        openPageRequest.setFirstPage();\r\n\r\n        openPage(openPageRequest, 2);\r\n    };\r\n\r\n    /**\r\n     * Opens the previous page.\r\n     */\r\n    this.openPagePrev = function () {\r\n\r\n        if (self.getCurrentViewType() === ReaderView.VIEW_TYPE_SCROLLED_CONTINUOUS) {\r\n            _currentView.openPagePrev(self);\r\n            return;\r\n        }\r\n\r\n        var paginationInfo = _currentView.getPaginationInfo();\r\n\r\n        if (paginationInfo.openPages.length == 0) {\r\n            return;\r\n        }\r\n\r\n        var firstOpenPage = paginationInfo.openPages[0];\r\n\r\n        if (firstOpenPage.spineItemPageIndex > 0) {\r\n            _currentView.openPagePrev(self);\r\n            return;\r\n        }\r\n\r\n        var currentSpineItem = _spine.getItemById(firstOpenPage.idref);\r\n\r\n        var prevSpineItem = _spine.prevItem(currentSpineItem);\r\n\r\n        if (!prevSpineItem) {\r\n            return;\r\n        }\r\n\r\n        var openPageRequest = new PageOpenRequest(prevSpineItem, self);\r\n        openPageRequest.setLastPage();\r\n\r\n        openPage(openPageRequest, 1);\r\n    };\r\n\r\n    function getSpineItem(idref) {\r\n\r\n        if (!idref) {\r\n\r\n            console.log(\"idref parameter value missing!\");\r\n            return undefined;\r\n        }\r\n\r\n        var spineItem = _spine.getItemById(idref);\r\n        if (!spineItem) {\r\n            console.log(\"Spine item with id \" + idref + \" not found!\");\r\n            return undefined;\r\n        }\r\n\r\n        return spineItem;\r\n\r\n    }\r\n\r\n    /**\r\n     * Opens the page of the spine item with element with provided cfi\r\n     *\r\n     * @param {string} idref Id of the spine item\r\n     * @param {string} elementCfi CFI of the element to be shown\r\n     * @param {object} initiator optional\r\n     */\r\n    this.openSpineItemElementCfi = function (idref, elementCfi, initiator) {\r\n\r\n        var spineItem = getSpineItem(idref);\r\n\r\n        if (!spineItem) {\r\n            return false;\r\n        }\r\n\r\n        var pageData = new PageOpenRequest(spineItem, initiator);\r\n        if (elementCfi) {\r\n            pageData.setElementCfi(elementCfi);\r\n        }\r\n\r\n        openPage(pageData, 0);\r\n\r\n        return true;\r\n    };\r\n\r\n    /**\r\n     * Opens specified page index of the current spine item\r\n     *\r\n     * @param {number} pageIndex Zero based index of the page in the current spine item\r\n     * @param {object} initiator optional\r\n     */\r\n    this.openPageIndex = function (pageIndex, initiator) {\r\n\r\n        if (!_currentView) {\r\n            return false;\r\n        }\r\n\r\n        var pageRequest;\r\n\r\n        if (_package.isFixedLayout()) {\r\n            var spineItem = _spine.items[pageIndex];\r\n            if (!spineItem) {\r\n                return false;\r\n            }\r\n\r\n            pageRequest = new PageOpenRequest(spineItem, initiator);\r\n            pageRequest.setPageIndex(0);\r\n        }\r\n        else {\r\n\r\n            var spineItems = this.getLoadedSpineItems();\r\n            if (spineItems.length > 0) {\r\n                pageRequest = new PageOpenRequest(spineItems[0], initiator);\r\n                pageRequest.setPageIndex(pageIndex);\r\n            }\r\n        }\r\n\r\n        openPage(pageRequest, 0);\r\n\r\n        return true;\r\n    };\r\n\r\n    // dir: 0 => new or same page, 1 => previous, 2 => next\r\n    function openPage(pageRequest, dir) {\r\n\r\n        initViewForItem(pageRequest.spineItem, function (isViewChanged) {\r\n\r\n            if (!isViewChanged) {\r\n                _currentView.setViewSettings(_viewerSettings);\r\n            }\r\n\r\n            _currentView.openPage(pageRequest, dir);\r\n        });\r\n    }\r\n\r\n\r\n    /**\r\n     * Opens page index of the spine item with idref provided\r\n     *\r\n     * @param {string} idref Id of the spine item\r\n     * @param {number} pageIndex Zero based index of the page in the spine item\r\n     * @param {object} initiator optional\r\n     */\r\n    this.openSpineItemPage = function (idref, pageIndex, initiator) {\r\n\r\n        var spineItem = getSpineItem(idref);\r\n\r\n        if (!spineItem) {\r\n            return false;\r\n        }\r\n\r\n        var pageData = new PageOpenRequest(spineItem, initiator);\r\n        if (pageIndex) {\r\n            pageData.setPageIndex(pageIndex);\r\n        }\r\n\r\n        openPage(pageData, 0);\r\n\r\n        return true;\r\n    };\r\n\r\n    /**\r\n     * Set CSS Styles to the reader container\r\n     *\r\n     * @param {Collections.StyleCollection} styles   Style collection containing selector property and declarations object\r\n     * @param {boolean} doNotUpdateView                         Whether to update the view after the styles are applied.\r\n     */\r\n    this.setStyles = function (styles, doNotUpdateView) {\r\n\r\n        var count = styles.length;\r\n\r\n        for (var i = 0; i < count; i++) {\r\n            if (styles[i].declarations) {\r\n                _userStyles.addStyle(styles[i].selector, styles[i].declarations);\r\n            }\r\n            else {\r\n                _userStyles.removeStyle(styles[i].selector);\r\n            }\r\n        }\r\n\r\n        applyStyles(doNotUpdateView);\r\n\r\n    };\r\n\r\n    /**\r\n     * Set CSS Styles to the content documents\r\n     *\r\n     * @param {Collections.StyleCollection} styles    Style collection containing selector property and declarations object\r\n     */\r\n    this.setBookStyles = function (styles) {\r\n\r\n        var count = styles.length;\r\n\r\n        for (var i = 0; i < count; i++) {\r\n            _bookStyles.addStyle(styles[i].selector, styles[i].declarations);\r\n        }\r\n\r\n        if (_currentView) {\r\n            _currentView.applyBookStyles();\r\n        }\r\n\r\n    };\r\n\r\n    /**\r\n     * Gets an element from active content documents based on a query selector.\r\n     *\r\n     * @param {Models.SpineItem} spineItem       The spine item object associated with an active content document\r\n     * @param {string} selector                      The query selector\r\n     * @returns {HTMLElement|undefined}\r\n     */\r\n    this.getElement = function (spineItemIdref, selector) {\r\n\r\n        if (_currentView) {\r\n            return _currentView.getElement(spineItemIdref, selector);\r\n        }\r\n\r\n        return undefined;\r\n    };\r\n\r\n    /**\r\n     * Gets an element from active content documents based on an element id.\r\n     *\r\n     * @param {string} spineItemIdref      The spine item idref associated with an active content document\r\n     * @param {string} id                                  The element id\r\n     * @returns {HTMLElement|undefined}\r\n     */\r\n    this.getElementById = function (spineItemIdref, id) {\r\n\r\n        if (_currentView) {\r\n            return _currentView.getElementById(spineItemIdref, id);\r\n        }\r\n\r\n        return undefined;\r\n    };\r\n\r\n    /**\r\n     * Gets an element from active content documents based on a content CFI.\r\n     *\r\n     * @param {string} spineItemIdref     The spine item idref associated with an active content document\r\n     * @param {string} cfi                                The partial content CFI\r\n     * @param {string[]} [classBlacklist]\r\n     * @param {string[]} [elementBlacklist]\r\n     * @param {string[]} [idBlacklist]\r\n     * @returns {HTMLElement|undefined}\r\n     */\r\n    this.getElementByCfi = function (spineItemIdref, cfi, classBlacklist, elementBlacklist, idBlacklist) {\r\n\r\n        if (_currentView) {\r\n            return _currentView.getElementByCfi(spineItemIdref, cfi, classBlacklist, elementBlacklist, idBlacklist);\r\n        }\r\n\r\n        return undefined;\r\n\r\n    };\r\n\r\n    function applyStyles(doNotUpdateView) {\r\n\r\n        Helpers.setStyles(_userStyles.getStyles(), _$el);\r\n\r\n        if (_mediaOverlayPlayer)\r\n            _mediaOverlayPlayer.applyStyles();\r\n\r\n        if (doNotUpdateView) return;\r\n\r\n        if (_currentView) {\r\n            _currentView.applyStyles();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Opens a content url from a media player context\r\n     *\r\n     * @param {string} contentRefUrl\r\n     * @param {string} sourceFileHref\r\n     * @param offset\r\n     */\r\n    this.mediaOverlaysOpenContentUrl = function (contentRefUrl, sourceFileHref, offset) {\r\n        _mediaOverlayPlayer.mediaOverlaysOpenContentUrl(contentRefUrl, sourceFileHref, offset);\r\n    };\r\n\r\n\r\n    /**\r\n     * Opens the content document specified by the url\r\n     *\r\n     * @param {string} contentRefUrl Url of the content document\r\n     * @param {string | undefined} sourceFileHref Url to the file that contentRefUrl is relative to. If contentRefUrl is\r\n     * relative ot the source file that contains it instead of the package file (ex. TOC file) We have to know the\r\n     * sourceFileHref to resolve contentUrl relative to the package file.\r\n     * @param {object} initiator optional\r\n     */\r\n    this.openContentUrl = function (contentRefUrl, sourceFileHref, initiator) {\r\n\r\n        var combinedPath = Helpers.ResolveContentRef(contentRefUrl, sourceFileHref);\r\n\r\n        var hashIndex = combinedPath.indexOf(\"#\");\r\n        var hrefPart;\r\n        var elementId;\r\n        if (hashIndex >= 0) {\r\n            hrefPart = combinedPath.substr(0, hashIndex);\r\n            elementId = combinedPath.substr(hashIndex + 1);\r\n        }\r\n        else {\r\n            hrefPart = combinedPath;\r\n            elementId = undefined;\r\n        }\r\n\r\n        var spineItem = _spine.getItemByHref(hrefPart);\r\n        if (!spineItem) {\r\n            console.warn('spineItem ' + hrefPart + ' not found');\r\n            // sometimes that happens because spine item's URI gets encoded,\r\n            // yet it's compared with raw strings by `getItemByHref()` -\r\n            // so we try to search with decoded link as well\r\n            var decodedHrefPart = decodeURIComponent(hrefPart);\r\n            spineItem = _spine.getItemByHref(decodedHrefPart);\r\n            if (!spineItem) {\r\n                console.warn('decoded spineItem ' + decodedHrefPart + ' missing as well');\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return self.openSpineItemElementId(spineItem.idref, elementId, initiator);\r\n    };\r\n\r\n    /**\r\n     * Opens the page of the spine item with element with provided cfi\r\n     *\r\n     * @param {string} idref Id of the spine item\r\n     * @param {string} elementId id of the element to be shown\r\n     * @param {object} initiator optional\r\n     */\r\n    this.openSpineItemElementId = function (idref, elementId, initiator) {\r\n\r\n        var spineItem = _spine.getItemById(idref);\r\n        if (!spineItem) {\r\n            return false;\r\n        }\r\n\r\n        var pageData = new PageOpenRequest(spineItem, initiator);\r\n\r\n        if (elementId) {\r\n            pageData.setElementId(elementId);\r\n        }\r\n\r\n\r\n        openPage(pageData, 0);\r\n\r\n        return true;\r\n    };\r\n\r\n    /**\r\n     * Returns the bookmark associated with currently opened page.\r\n     *\r\n     * @returns {string} Serialized ReadiumSDK.Models.BookmarkData object as JSON string.\r\n     *          {null} If a bookmark could not be created successfully.\r\n     */\r\n    this.bookmarkCurrentPage = function() {\r\n        var bookmark = _currentView.bookmarkCurrentPage();\r\n        return bookmark ? bookmark.toString() : null;\r\n    };\r\n\r\n    /**\r\n     * Resets all the custom styles set by setStyle callers at runtime\r\n     */\r\n    this.clearStyles = function () {\r\n\r\n        _userStyles.resetStyleValues();\r\n        applyStyles();\r\n        _userStyles.clear();\r\n    };\r\n\r\n    /**\r\n     * Resets all the custom styles set by setBookStyle callers at runtime\r\n     */\r\n    this.clearBookStyles = function () {\r\n\r\n        if (_currentView) {\r\n\r\n            _bookStyles.resetStyleValues();\r\n            _currentView.applyBookStyles();\r\n        }\r\n\r\n        _bookStyles.clear();\r\n    };\r\n\r\n    /**\r\n     * Returns true if media overlay available for one of the open pages.\r\n     *\r\n     * @returns {boolean}\r\n     */\r\n    this.isMediaOverlayAvailable = function () {\r\n\r\n        if (!_mediaOverlayPlayer) return false;\r\n\r\n        return _mediaOverlayPlayer.isMediaOverlayAvailable();\r\n    };\r\n\r\n    /*\r\n     this.setMediaOverlaySkippables = function(items) {\r\n\r\n     _mediaOverlayPlayer.setMediaOverlaySkippables(items);\r\n     };\r\n\r\n     this.setMediaOverlayEscapables = function(items) {\r\n\r\n     _mediaOverlayPlayer.setMediaOverlayEscapables(items);\r\n     };\r\n     */\r\n\r\n    /**\r\n     * Starts/Stop playing media overlay on current page\r\n     */\r\n    this.toggleMediaOverlay = function () {\r\n\r\n        _mediaOverlayPlayer.toggleMediaOverlay();\r\n    };\r\n\r\n\r\n    /**\r\n     * Plays next fragment media overlay\r\n     */\r\n    this.nextMediaOverlay = function () {\r\n\r\n        _mediaOverlayPlayer.nextMediaOverlay();\r\n\r\n    };\r\n\r\n    /**\r\n     * Plays previous fragment media overlay\r\n     */\r\n    this.previousMediaOverlay = function () {\r\n\r\n        _mediaOverlayPlayer.previousMediaOverlay();\r\n\r\n    };\r\n\r\n    /**\r\n     * Plays next available fragment media overlay that is outside of the current escapable scope\r\n     */\r\n    this.escapeMediaOverlay = function () {\r\n\r\n        _mediaOverlayPlayer.escape();\r\n    };\r\n\r\n    /**\r\n     * End media overlay TTS\r\n     * @todo Clarify what this does with Daniel.\r\n     */\r\n    this.ttsEndedMediaOverlay = function () {\r\n\r\n        _mediaOverlayPlayer.onTTSEnd();\r\n    };\r\n\r\n    /**\r\n     * Pause currently playing media overlays.\r\n     */\r\n    this.pauseMediaOverlay = function () {\r\n\r\n        _mediaOverlayPlayer.pause();\r\n    };\r\n\r\n    /**\r\n     * Start/Resume playback of media overlays.\r\n     */\r\n    this.playMediaOverlay = function () {\r\n\r\n        _mediaOverlayPlayer.play();\r\n    };\r\n\r\n    /**\r\n     * Determine if media overlays are currently playing.\r\n     * @returns {boolean}\r\n     */\r\n    this.isPlayingMediaOverlay = function () {\r\n\r\n        return _mediaOverlayPlayer.isPlaying();\r\n    };\r\n\r\n//\r\n// should use Globals.Events.SETTINGS_APPLIED instead!\r\n//    this.setRateMediaOverlay = function(rate) {\r\n//\r\n//        _mediaOverlayPlayer.setRate(rate);\r\n//    };\r\n//    this.setVolumeMediaOverlay = function(volume){\r\n//\r\n//        _mediaOverlayPlayer.setVolume(volume);\r\n//    };\r\n\r\n    /**\r\n     * Get the first visible media overlay element from the currently active content document(s)\r\n     * @returns {HTMLElement|undefined}\r\n     */\r\n    this.getFirstVisibleMediaOverlayElement = function () {\r\n\r\n        if (_currentView) {\r\n            return _currentView.getFirstVisibleMediaOverlayElement();\r\n        }\r\n\r\n        return undefined;\r\n    };\r\n\r\n    /**\r\n     * Used to jump to an element to make sure it is visible when a content document is paginated\r\n     * @param {string}      spineItemId   The spine item idref associated with an active content document\r\n     * @param {HTMLElement} element       The element to make visible\r\n     * @param [initiator]\r\n     */\r\n    this.insureElementVisibility = function (spineItemId, element, initiator) {\r\n\r\n        if (_currentView) {\r\n            _currentView.insureElementVisibility(spineItemId, element, initiator);\r\n        }\r\n    };\r\n\r\n    var _resizeBookmark = null;\r\n    var _resizeMOWasPlaying = false;\r\n\r\n    function handleViewportResizeStart() {\r\n\r\n        _resizeBookmark = null;\r\n        _resizeMOWasPlaying = false;\r\n\r\n        if (_currentView) {\r\n\r\n            if (_currentView.isReflowable && _currentView.isReflowable()) {\r\n                _resizeMOWasPlaying = self.isPlayingMediaOverlay();\r\n                if (_resizeMOWasPlaying) {\r\n                    self.pauseMediaOverlay();\r\n                }\r\n            }\r\n\r\n            _resizeBookmark = _currentView.bookmarkCurrentPage(); // not self! (JSON string)\r\n        }\r\n    }\r\n\r\n    function handleViewportResizeTick() {\r\n        if (_currentView) {\r\n            self.handleViewportResize(_resizeBookmark);\r\n        }\r\n    }\r\n\r\n    function handleViewportResizeEnd() {\r\n        //same as doing one final tick for now\r\n        handleViewportResizeTick();\r\n\r\n        if (_resizeMOWasPlaying) self.playMediaOverlay();\r\n    }\r\n\r\n    this.handleViewportResize = function (bookmarkToRestore) {\r\n        if (!_currentView) return;\r\n\r\n        _currentView.onViewportResize();\r\n    };\r\n\r\n    /**\r\n     * Lets user to subscribe to iframe's window events\r\n     *\r\n     * @param {string} eventName              Event name.\r\n     * @param {function} callback             Callback function.\r\n     * @param {object} context                User specified data passed to the callback function.\r\n     * @returns {undefined}\r\n     */\r\n    this.addIFrameEventListener = function (eventName, callback, context) {\r\n        _iframeLoader.addIFrameEventListener(eventName, callback, context);\r\n    };\r\n\r\n    var BackgroundAudioTrackManager = function (readerView) {\r\n        var _spineItemIframeMap = {};\r\n        var _wasPlaying = false;\r\n\r\n        var _callback_playPause = undefined;\r\n        this.setCallback_PlayPause = function (callback) {\r\n            _callback_playPause = callback;\r\n        };\r\n\r\n        var _callback_isAvailable = undefined;\r\n        this.setCallback_IsAvailable = function (callback) {\r\n            _callback_isAvailable = callback;\r\n        };\r\n\r\n        this.playPause = function (doPlay) {\r\n            _playPause(doPlay);\r\n        };\r\n\r\n        var _playPause = function (doPlay) {\r\n            if (_callback_playPause) {\r\n                _callback_playPause(doPlay);\r\n            }\r\n\r\n            try {\r\n                var $iframe = undefined;\r\n\r\n                for (var prop in _spineItemIframeMap) {\r\n                    if (!_spineItemIframeMap.hasOwnProperty(prop)) continue;\r\n\r\n                    var data = _spineItemIframeMap[prop];\r\n                    if (!data || !data.active) continue;\r\n\r\n                    if ($iframe) console.error(\"More than one active iframe?? (pagination)\");\r\n\r\n                    $iframe = data[\"$iframe\"];\r\n                    if (!$iframe) continue;\r\n\r\n                    var $audios = $(\"audio\", $iframe[0].contentDocument);\r\n\r\n                    $.each($audios, function () {\r\n\r\n                        var attr = this.getAttribute(\"epub:type\") || this.getAttribute(\"type\");\r\n\r\n                        if (!attr) return true; // continue\r\n\r\n                        if (attr.indexOf(\"ibooks:soundtrack\") < 0 && attr.indexOf(\"media:soundtrack\") < 0 && attr.indexOf(\"media:background\") < 0) return true; // continue\r\n\r\n                        if (doPlay && this.play) {\r\n                            this.play();\r\n                        }\r\n                        else if (this.pause) {\r\n                            this.pause();\r\n                        }\r\n\r\n                        return true; // continue (more than one track?)\r\n                    });\r\n                }\r\n            }\r\n            catch (err) {\r\n                console.error(err);\r\n            }\r\n        };\r\n\r\n        this.setPlayState = function (wasPlaying) {\r\n            _wasPlaying = wasPlaying;\r\n        };\r\n\r\n        readerView.on(Globals.Events.CONTENT_DOCUMENT_LOADED, function ($iframe, spineItem) {\r\n            Globals.logEvent(\"CONTENT_DOCUMENT_LOADED\", \"ON\", \"reader_view.js (via BackgroundAudioTrackManager) [ \" + spineItem.href + \" ]\");;\r\n            \r\n            try {\r\n                if (spineItem && spineItem.idref && $iframe && $iframe[0]) {\r\n                    // console.log(\"CONTENT_DOCUMENT_LOADED\");\r\n                    // console.debug(spineItem.href);\r\n                    // console.debug(spineItem.idref);\r\n\r\n                    _spineItemIframeMap[spineItem.idref] = {\"$iframe\": $iframe, href: spineItem.href};\r\n                }\r\n            }\r\n            catch (err) {\r\n                console.error(err);\r\n            }\r\n        });\r\n\r\n        readerView.on(Globals.Events.PAGINATION_CHANGED, function (pageChangeData) {\r\n            Globals.logEvent(\"PAGINATION_CHANGED\", \"ON\", \"reader_view.js (via BackgroundAudioTrackManager)\");\r\n            \r\n            // console.log(\"PAGINATION_CHANGED\");\r\n            // console.debug(pageChangeData);\r\n            //\r\n            // if (pageChangeData.spineItem)\r\n            // {\r\n            //     console.debug(pageChangeData.spineItem.href);\r\n            //     console.debug(pageChangeData.spineItem.idref);\r\n            // }\r\n            // else\r\n            // {\r\n            //     //console.error(pageChangeData);\r\n            // }\r\n            //\r\n            // if (pageChangeData.paginationInfo && pageChangeData.paginationInfo.openPages && pageChangeData.paginationInfo.openPages.length)\r\n            // {\r\n            //     for (var i = 0; i < pageChangeData.paginationInfo.openPages.length; i++)\r\n            //     {\r\n            //         console.log(pageChangeData.paginationInfo.openPages[i].idref);\r\n            //     }\r\n            // }\r\n\r\n            var atLeastOne = false;\r\n\r\n            try {\r\n                for (var prop in _spineItemIframeMap) {\r\n                    if (!_spineItemIframeMap.hasOwnProperty(prop)) continue;\r\n\r\n                    var isActive = pageChangeData.spineItem && pageChangeData.spineItem.idref === prop;\r\n\r\n                    var isDisplayed = false;\r\n\r\n                    if (pageChangeData.paginationInfo && pageChangeData.paginationInfo.openPages.length) {\r\n                        var allSame = true;\r\n\r\n                        for (var i = 0; i < pageChangeData.paginationInfo.openPages.length; i++) {\r\n                            if (pageChangeData.paginationInfo.openPages[i].idref === prop) {\r\n                                isDisplayed = true;\r\n                            }\r\n                            else {\r\n                                allSame = false;\r\n                            }\r\n                        }\r\n\r\n                        if (!isActive && allSame) isActive = true;\r\n                    }\r\n\r\n                    if (isActive || isDisplayed) {\r\n                        var data = _spineItemIframeMap[prop];\r\n                        if (!data) continue;\r\n\r\n                        _spineItemIframeMap[prop][\"active\"] = isActive;\r\n\r\n                        var $iframe = data[\"$iframe\"];\r\n                        var href = data.href;\r\n\r\n                        var $audios = $(\"audio\", $iframe[0].contentDocument);\r\n                        $.each($audios, function () {\r\n\r\n                            var attr = this.getAttribute(\"epub:type\") || this.getAttribute(\"type\");\r\n\r\n                            if (!attr) return true; // continue\r\n\r\n                            if (attr.indexOf(\"ibooks:soundtrack\") < 0 && attr.indexOf(\"media:soundtrack\") < 0 && attr.indexOf(\"media:background\") < 0) return true; // continue\r\n\r\n                            this.setAttribute(\"loop\", \"loop\");\r\n                            this.removeAttribute(\"autoplay\");\r\n\r\n                            // DEBUG!\r\n                            //this.setAttribute(\"controls\", \"controls\");\r\n\r\n                            if (isActive) {\r\n                                // DEBUG!\r\n                                //$(this).css({border:\"2px solid green\"});\r\n                            }\r\n                            else {\r\n                                if (this.pause) this.pause();\r\n\r\n                                // DEBUG!\r\n                                //$(this).css({border:\"2px solid red\"});\r\n                            }\r\n\r\n                            atLeastOne = true;\r\n\r\n                            return true; // continue (more than one track?)\r\n                        });\r\n\r\n                        continue;\r\n                    }\r\n                    else {\r\n                        if (_spineItemIframeMap[prop]) _spineItemIframeMap[prop][\"$iframe\"] = undefined;\r\n                        _spineItemIframeMap[prop] = undefined;\r\n                    }\r\n                }\r\n            }\r\n            catch (err) {\r\n                console.error(err);\r\n            }\r\n\r\n            if (_callback_isAvailable) {\r\n                _callback_isAvailable(atLeastOne);\r\n            }\r\n\r\n            if (atLeastOne) {\r\n                if (_wasPlaying) {\r\n                    _playPause(true);\r\n                }\r\n                else {\r\n                    _playPause(false); // ensure correct paused state\r\n                }\r\n            }\r\n            else {\r\n                _playPause(false); // ensure correct paused state\r\n            }\r\n        });\r\n\r\n        readerView.on(Globals.Events.MEDIA_OVERLAY_STATUS_CHANGED, function (value) {\r\n            Globals.logEvent(\"MEDIA_OVERLAY_STATUS_CHANGED\", \"ON\", \"reader_view.js (via BackgroundAudioTrackManager)\");\r\n            \r\n            if (!value.smilIndex) return;\r\n            var package = readerView.package();\r\n            var smil = package.media_overlay.smilAt(value.smilIndex);\r\n            if (!smil || !smil.spineItemId) return;\r\n\r\n            var needUpdate = false;\r\n            for (var prop in _spineItemIframeMap) {\r\n                if (!_spineItemIframeMap.hasOwnProperty(prop)) continue;\r\n\r\n                var data = _spineItemIframeMap[prop];\r\n                if (!data) continue;\r\n\r\n                if (data.active) {\r\n                    if (prop !== smil.spineItemId) {\r\n                        _playPause(false); // ensure correct paused state\r\n                        data.active = false;\r\n                        needUpdate = true;\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (needUpdate) {\r\n                for (var prop in _spineItemIframeMap) {\r\n                    if (!_spineItemIframeMap.hasOwnProperty(prop)) continue;\r\n\r\n                    var data = _spineItemIframeMap[prop];\r\n                    if (!data) continue;\r\n\r\n                    if (!data.active) {\r\n                        if (prop === smil.spineItemId) {\r\n                            data.active = true;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (_wasPlaying) {\r\n                    _playPause(true);\r\n                }\r\n            }\r\n        });\r\n    };\r\n    this.backgroundAudioTrackManager = new BackgroundAudioTrackManager(self);\r\n\r\n    function getCfisForVisibleRegion() {\r\n        return {firstVisibleCfi: self.getFirstVisibleCfi(), lastVisibleCfi: self.getLastVisibleCfi()};\r\n    }\r\n\r\n\r\n    this.isVisibleSpineItemElementCfi = function(spineIdRef, partialCfi){\r\n        var spineItem = getSpineItem(spineIdRef);\r\n\r\n        if (!spineItem) {\r\n            return false;\r\n        }\r\n\r\n        if (_currentView) {\r\n\r\n            if(!partialCfi || (partialCfi && partialCfi === '')){\r\n                var spines = _currentView.getLoadedSpineItems();\r\n                for(var i = 0, count = spines.length; i < count; i++) {\r\n                    if(spines[i].idref == spineIdRef){\r\n                        return true;\r\n                    }\r\n                }\r\n            }\r\n            return _currentView.isVisibleSpineItemElementCfi(spineIdRef, partialCfi);\r\n\r\n        }\r\n        return false;\r\n    };\r\n\r\n    /**\r\n     * Gets all elements from active content documents based on a query selector.\r\n     *\r\n     * @param {string} spineItemIdref    The spine item idref associated with the content document\r\n     * @param {string} selector          The query selector\r\n     * @returns {HTMLElement[]}\r\n     */\r\n    this.getElements = function(spineItemIdref, selector) {\r\n\r\n        if(_currentView) {\r\n            return _currentView.getElements(spineItemIdref, selector);\r\n        }\r\n\r\n        return undefined;\r\n    };\r\n\r\n    /**\r\n     * Determine if an element is visible on the active content documents\r\n     *\r\n     * @param {HTMLElement} element The element.\r\n     * @returns {boolean}\r\n     */\r\n    this.isElementVisible = function (element) {\r\n        return _currentView.isElementVisible($(element));\r\n\r\n    };\r\n\r\n    /**\r\n     * Resolve a range CFI into an object containing info about it.\r\n     * @param {string} spineIdRef    The spine item idref associated with the content document\r\n     * @param {string} partialCfi    The partial CFI that is the range CFI to resolve\r\n     * @returns {Models.NodeRangeInfo}\r\n     */\r\n    this.getNodeRangeInfoFromCfi = function (spineIdRef, partialCfi) {\r\n        if (_currentView && spineIdRef && partialCfi) {\r\n            var nodeRangeInfo = _currentView.getNodeRangeInfoFromCfi(spineIdRef, partialCfi);\r\n            if (nodeRangeInfo) {\r\n                return new NodeRangeInfo(nodeRangeInfo.clientRect)\r\n                    .setStartInfo(nodeRangeInfo.startInfo)\r\n                    .setEndInfo(nodeRangeInfo.endInfo);\r\n            }\r\n        }\r\n        return undefined;\r\n    };\r\n\r\n    /**\r\n     * Get the pagination info from the current view\r\n     *\r\n     * @returns {ReadiumSDK.Models.CurrentPagesInfo}\r\n     */\r\n    this.getPaginationInfo = function(){\r\n        return _currentView.getPaginationInfo();\r\n    };\r\n    /**\r\n     * Get CFI of the first element visible in the viewport\r\n     * @returns {ReadiumSDK.Models.BookmarkData}\r\n     */\r\n    this.getFirstVisibleCfi = function() {\r\n        if (_currentView) {\r\n            return _currentView.getFirstVisibleCfi();\r\n        }\r\n        return undefined;\r\n    };\r\n\r\n    /**\r\n     * Get CFI of the last element visible in the viewport\r\n     * @returns {ReadiumSDK.Models.BookmarkData}\r\n     */\r\n    this.getLastVisibleCfi = function() {\r\n        if (_currentView) {\r\n            return _currentView.getLastVisibleCfi();\r\n        }\r\n        return undefined;\r\n    };\r\n    /**\r\n     *\r\n     * @param {string} rangeCfi\r\n     * @param {string} [rangeCfi2]\r\n     * @param {boolean} [inclusive]\r\n     * @returns {array}\r\n     */\r\n    this.getDomRangesFromRangeCfi = function(rangeCfi, rangeCfi2, inclusive) {\r\n        if (_currentView) {\r\n            if (_currentView.getDomRangesFromRangeCfi) {\r\n                return _currentView.getDomRangesFromRangeCfi(rangeCfi, rangeCfi2, inclusive);\r\n            } else {\r\n                return [_currentView.getDomRangeFromRangeCfi(rangeCfi, rangeCfi2, inclusive)];\r\n            }\r\n        }\r\n        return undefined;\r\n    };\r\n\r\n    /**\r\n     *\r\n     * @param {ReadiumSDK.Models.BookmarkData} startCfi starting CFI\r\n     * @param {ReadiumSDK.Models.BookmarkData} [endCfi] ending CFI\r\n     * optional - may be omited if startCfi is a range CFI\r\n     * @param {boolean} [inclusive] optional indicating if the range should be inclusive\r\n     * @returns {array}\r\n     */\r\n    this.getDomRangesFromRangeCfi = function(rangeCfi, rangeCfi2, inclusive) {\r\n        if (_currentView) {\r\n            if (_currentView.getDomRangesFromRangeCfi) {\r\n                return _currentView.getDomRangesFromRangeCfi(rangeCfi, rangeCfi2, inclusive);\r\n            } else {\r\n                return [_currentView.getDomRangeFromRangeCfi(rangeCfi, rangeCfi2, inclusive)];\r\n            }\r\n        }\r\n        return undefined;\r\n    };\r\n\r\n    /**\r\n     *\r\n     * @param {ReadiumSDK.Models.BookmarkData} startCfi starting CFI\r\n     * @param {ReadiumSDK.Models.BookmarkData} [endCfi] ending CFI\r\n     * optional - may be omited if startCfi is a range CFI\r\n     * @param {boolean} [inclusive] optional indicating if the range should be inclusive\r\n     * @returns {DOM Range} https://developer.mozilla.org/en-US/docs/Web/API/Range\r\n     */\r\n    this.getDomRangeFromRangeCfi = function(startCfi, endCfi, inclusive) {\r\n        if (_currentView) {\r\n            return _currentView.getDomRangeFromRangeCfi(startCfi, endCfi, inclusive);\r\n        }\r\n        return undefined;\r\n    };\r\n\r\n    /**\r\n     * Generate range CFI from DOM range\r\n     * @param {DOM Range} https://developer.mozilla.org/en-US/docs/Web/API/Range\r\n     * @returns {string} - represents Range CFI for the DOM range\r\n     */\r\n    this.getRangeCfiFromDomRange = function(domRange) {\r\n        if (_currentView) {\r\n            return _currentView.getRangeCfiFromDomRange(domRange);\r\n        }\r\n        return undefined;\r\n    };\r\n\r\n    /**\r\n     * @param x\r\n     * @param y\r\n     * @param [precisePoint]\r\n     * @param [spineItemIdref] Required for fixed layout views\r\n     * @returns {string}\r\n     */\r\n    this.getVisibleCfiFromPoint = function (x, y, precisePoint, spineItemIdref) {\r\n        if (_currentView) {\r\n            return _currentView.getVisibleCfiFromPoint(x, y, precisePoint, spineItemIdref);\r\n        }\r\n        return undefined;\r\n    };\r\n\r\n    /**\r\n     *\r\n     * @param startX\r\n     * @param startY\r\n     * @param endX\r\n     * @param endY\r\n     * @param [spineItemIdref] Required for fixed layout views\r\n     * @returns {*}\r\n     */\r\n    this.getRangeCfiFromPoints = function(startX, startY, endX, endY, spineItemIdref) {\r\n        if (_currentView) {\r\n            return _currentView.getRangeCfiFromPoints(startX, startY, endX, endY, spineItemIdref);\r\n        }\r\n        return undefined;\r\n    };\r\n\r\n    /**\r\n     *\r\n     * @param {HTMLElement} element\r\n     * @returns {*}\r\n     */\r\n    this.getCfiForElement = function(element) {\r\n        if (_currentView) {\r\n            return _currentView.getCfiForElement(element);\r\n        }\r\n        return undefined;\r\n    };\r\n};\r\n\r\n/**\r\n * View Type\r\n * @typedef {object} Globals.Views.ReaderView.ViewType\r\n * @property {number} VIEW_TYPE_COLUMNIZED          Reflowable document view\r\n * @property {number} VIEW_TYPE_FIXED               Fixed layout document view\r\n * @property {number} VIEW_TYPE_SCROLLED_DOC        Scrollable document view\r\n * @property {number} VIEW_TYPE_SCROLLED_CONTINUOUS Continuous scrollable document view\r\n */\r\nReaderView.VIEW_TYPE_COLUMNIZED = 1;\r\nReaderView.VIEW_TYPE_FIXED = 2;\r\nReaderView.VIEW_TYPE_SCROLLED_DOC = 3;\r\nReaderView.VIEW_TYPE_SCROLLED_CONTINUOUS = 4;\r\nreturn ReaderView;\r\n});\r\n\n",
    "\ndefine(\"readium-shared-js\", function(){});\n",
    "\nrequire([\"readium_shared_js/globalsSetup\"]);\n"
  ]
}