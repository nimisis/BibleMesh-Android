{
  "version": 3,
  "sources": [
    "readium_cfi_js/cfi_parser.js",
    "../../readium-cfi-js/js/cfi_runtime_errors.js",
    "../../readium-cfi-js/js/cfi_instructions.js",
    "../../readium-cfi-js/js/cfi_interpreter.js",
    "../../readium-cfi-js/js/cfi_generator.js",
    "../../readium-cfi-js/js/cfi_API.js",
    "../../../../../../../../../module-create.js",
    "../../../../../../../../../module-insertRequire.js"
  ],
  "names": [],
  "mappings": "AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACtgDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACrHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACtYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC3dA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACzfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC9JA;AACA;AACA,ACFA;AACA;AACA",
  "file": "readium-cfi-js.js",
  "sourcesContent": [
    "/*\n * Generated by PEG.js 0.10.0.\n *\n * http://pegjs.org/\n */\n(function(root) {\n  \"use strict\";\n\n  function peg$subclass(child, parent) {\n    function ctor() { this.constructor = child; }\n    ctor.prototype = parent.prototype;\n    child.prototype = new ctor();\n  }\n\n  function peg$SyntaxError(message, expected, found, location) {\n    this.message  = message;\n    this.expected = expected;\n    this.found    = found;\n    this.location = location;\n    this.name     = \"SyntaxError\";\n\n    if (typeof Error.captureStackTrace === \"function\") {\n      Error.captureStackTrace(this, peg$SyntaxError);\n    }\n  }\n\n  peg$subclass(peg$SyntaxError, Error);\n\n  peg$SyntaxError.buildMessage = function(expected, found) {\n    var DESCRIBE_EXPECTATION_FNS = {\n          literal: function(expectation) {\n            return \"\\\"\" + literalEscape(expectation.text) + \"\\\"\";\n          },\n\n          \"class\": function(expectation) {\n            var escapedParts = \"\",\n                i;\n\n            for (i = 0; i < expectation.parts.length; i++) {\n              escapedParts += expectation.parts[i] instanceof Array\n                ? classEscape(expectation.parts[i][0]) + \"-\" + classEscape(expectation.parts[i][1])\n                : classEscape(expectation.parts[i]);\n            }\n\n            return \"[\" + (expectation.inverted ? \"^\" : \"\") + escapedParts + \"]\";\n          },\n\n          any: function(expectation) {\n            return \"any character\";\n          },\n\n          end: function(expectation) {\n            return \"end of input\";\n          },\n\n          other: function(expectation) {\n            return expectation.description;\n          }\n        };\n\n    function hex(ch) {\n      return ch.charCodeAt(0).toString(16).toUpperCase();\n    }\n\n    function literalEscape(s) {\n      return s\n        .replace(/\\\\/g, '\\\\\\\\')\n        .replace(/\"/g,  '\\\\\"')\n        .replace(/\\0/g, '\\\\0')\n        .replace(/\\t/g, '\\\\t')\n        .replace(/\\n/g, '\\\\n')\n        .replace(/\\r/g, '\\\\r')\n        .replace(/[\\x00-\\x0F]/g,          function(ch) { return '\\\\x0' + hex(ch); })\n        .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return '\\\\x'  + hex(ch); });\n    }\n\n    function classEscape(s) {\n      return s\n        .replace(/\\\\/g, '\\\\\\\\')\n        .replace(/\\]/g, '\\\\]')\n        .replace(/\\^/g, '\\\\^')\n        .replace(/-/g,  '\\\\-')\n        .replace(/\\0/g, '\\\\0')\n        .replace(/\\t/g, '\\\\t')\n        .replace(/\\n/g, '\\\\n')\n        .replace(/\\r/g, '\\\\r')\n        .replace(/[\\x00-\\x0F]/g,          function(ch) { return '\\\\x0' + hex(ch); })\n        .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return '\\\\x'  + hex(ch); });\n    }\n\n    function describeExpectation(expectation) {\n      return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);\n    }\n\n    function describeExpected(expected) {\n      var descriptions = new Array(expected.length),\n          i, j;\n\n      for (i = 0; i < expected.length; i++) {\n        descriptions[i] = describeExpectation(expected[i]);\n      }\n\n      descriptions.sort();\n\n      if (descriptions.length > 0) {\n        for (i = 1, j = 1; i < descriptions.length; i++) {\n          if (descriptions[i - 1] !== descriptions[i]) {\n            descriptions[j] = descriptions[i];\n            j++;\n          }\n        }\n        descriptions.length = j;\n      }\n\n      switch (descriptions.length) {\n        case 1:\n          return descriptions[0];\n\n        case 2:\n          return descriptions[0] + \" or \" + descriptions[1];\n\n        default:\n          return descriptions.slice(0, -1).join(\", \")\n            + \", or \"\n            + descriptions[descriptions.length - 1];\n      }\n    }\n\n    function describeFound(found) {\n      return found ? \"\\\"\" + literalEscape(found) + \"\\\"\" : \"end of input\";\n    }\n\n    return \"Expected \" + describeExpected(expected) + \" but \" + describeFound(found) + \" found.\";\n  };\n\n  function peg$parse(input, options) {\n    options = options !== void 0 ? options : {};\n\n    var peg$FAILED = {},\n\n        peg$startRuleFunctions = { fragment: peg$parsefragment },\n        peg$startRuleFunction  = peg$parsefragment,\n\n        peg$c0 = \"epubcfi(\",\n        peg$c1 = peg$literalExpectation(\"epubcfi(\", false),\n        peg$c2 = \")\",\n        peg$c3 = peg$literalExpectation(\")\", false),\n        peg$c4 = function(fragmentVal) { \r\n                \r\n                return { type:\"CFIAST\", cfiString:fragmentVal };\r\n            },\n        peg$c5 = \",\",\n        peg$c6 = peg$literalExpectation(\",\", false),\n        peg$c7 = function(stepVal, localPathVal, rangeLocalPath1Val, rangeLocalPath2Val) {\r\n\r\n                return { type:\"range\", path:stepVal, localPath:localPathVal, range1:rangeLocalPath1Val, range2:rangeLocalPath2Val };\r\n          },\n        peg$c8 = function(stepVal, localPathVal) { \r\n\r\n                return { type:\"path\", path:stepVal, localPath:localPathVal }; \r\n            },\n        peg$c9 = function(localPathStepVal, termStepVal) { \r\n\r\n                return { steps:localPathStepVal, termStep:termStepVal?termStepVal:\"\" }; \r\n            },\n        peg$c10 = \"/\",\n        peg$c11 = peg$literalExpectation(\"/\", false),\n        peg$c12 = \"[\",\n        peg$c13 = peg$literalExpectation(\"[\", false),\n        peg$c14 = \"]\",\n        peg$c15 = peg$literalExpectation(\"]\", false),\n        peg$c16 = function(stepLengthVal, assertVal) { \r\n\r\n                return { type:\"indexStep\", stepLength:stepLengthVal, idAssertion:assertVal?assertVal[1]:undefined };\r\n            },\n        peg$c17 = \"!/\",\n        peg$c18 = peg$literalExpectation(\"!/\", false),\n        peg$c19 = function(stepLengthVal, assertVal) { \r\n\r\n                return { type:\"indirectionStep\", stepLength:stepLengthVal, idAssertion:assertVal?assertVal[1]:undefined };\r\n            },\n        peg$c20 = \":\",\n        peg$c21 = peg$literalExpectation(\":\", false),\n        peg$c22 = function(textOffsetValue, textLocAssertVal) { \r\n\r\n                return { type:\"textTerminus\", offsetValue:textOffsetValue, textAssertion: textLocAssertVal?textLocAssertVal[1]:undefined };\r\n            },\n        peg$c23 = function(idVal) { \r\n\r\n                return idVal; \r\n            },\n        peg$c24 = function(csvVal, paramVal) { \r\n\r\n                return { type:\"textLocationAssertion\", csv:csvVal?csvVal:\"\", parameter:paramVal?paramVal:\"\" }; \r\n            },\n        peg$c25 = \";\",\n        peg$c26 = peg$literalExpectation(\";\", false),\n        peg$c27 = \"=\",\n        peg$c28 = peg$literalExpectation(\"=\", false),\n        peg$c29 = function(paramLHSVal, paramRHSVal) { \r\n\r\n                return { type:\"parameter\", LHSValue:paramLHSVal?paramLHSVal:\"\", RHSValue:paramRHSVal?paramRHSVal:\"\" }; \r\n            },\n        peg$c30 = function(preAssertionVal, postAssertionVal) { \r\n\r\n                return { type:\"csv\", preAssertion:preAssertionVal?preAssertionVal:\"\", postAssertion:postAssertionVal?postAssertionVal:\"\" }; \r\n            },\n        peg$c31 = function(stringVal) { \r\n\r\n                return stringVal.join(''); \r\n            },\n        peg$c32 = function(escSpecCharVal) { \r\n                \r\n                return escSpecCharVal[1]; \r\n            },\n        peg$c33 = /^[1-9]/,\n        peg$c34 = peg$classExpectation([[\"1\", \"9\"]], false, false),\n        peg$c35 = /^[0-9]/,\n        peg$c36 = peg$classExpectation([[\"0\", \"9\"]], false, false),\n        peg$c37 = \".\",\n        peg$c38 = peg$literalExpectation(\".\", false),\n        peg$c39 = function(intPartVal, fracPartVal) { \r\n\r\n                return intPartVal.join('') + \".\" + fracPartVal.join(''); \r\n            },\n        peg$c40 = \"0\",\n        peg$c41 = peg$literalExpectation(\"0\", false),\n        peg$c42 = function(integerVal) { \r\n\r\n                if (integerVal === \"0\") { \r\n                  return \"0\";\r\n                } \r\n                else { \r\n                  return integerVal[0].concat(integerVal[1].join(''));\r\n                }\r\n            },\n        peg$c43 = \" \",\n        peg$c44 = peg$literalExpectation(\" \", false),\n        peg$c45 = function() { return \" \"; },\n        peg$c46 = \"^\",\n        peg$c47 = peg$literalExpectation(\"^\", false),\n        peg$c48 = function() { return \"^\"; },\n        peg$c49 = \"\\\"\",\n        peg$c50 = peg$literalExpectation(\"\\\"\", false),\n        peg$c51 = function() { return '\"'; },\n        peg$c52 = function(bracketVal) { return bracketVal; },\n        peg$c53 = \"(\",\n        peg$c54 = peg$literalExpectation(\"(\", false),\n        peg$c55 = function(paraVal) { return paraVal; },\n        peg$c56 = function() { return \",\"; },\n        peg$c57 = function() { return \";\"; },\n        peg$c58 = function() { return \"=\"; },\n        peg$c59 = /^[a-z]/,\n        peg$c60 = peg$classExpectation([[\"a\", \"z\"]], false, false),\n        peg$c61 = /^[A-Z]/,\n        peg$c62 = peg$classExpectation([[\"A\", \"Z\"]], false, false),\n        peg$c63 = \"-\",\n        peg$c64 = peg$literalExpectation(\"-\", false),\n        peg$c65 = \"_\",\n        peg$c66 = peg$literalExpectation(\"_\", false),\n        peg$c67 = \"%\",\n        peg$c68 = peg$literalExpectation(\"%\", false),\n        peg$c69 = function(charVal) { return charVal; },\n\n        peg$currPos          = 0,\n        peg$savedPos         = 0,\n        peg$posDetailsCache  = [{ line: 1, column: 1 }],\n        peg$maxFailPos       = 0,\n        peg$maxFailExpected  = [],\n        peg$silentFails      = 0,\n\n        peg$result;\n\n    if (\"startRule\" in options) {\n      if (!(options.startRule in peg$startRuleFunctions)) {\n        throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n      }\n\n      peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n    }\n\n    function text() {\n      return input.substring(peg$savedPos, peg$currPos);\n    }\n\n    function location() {\n      return peg$computeLocation(peg$savedPos, peg$currPos);\n    }\n\n    function expected(description, location) {\n      location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)\n\n      throw peg$buildStructuredError(\n        [peg$otherExpectation(description)],\n        input.substring(peg$savedPos, peg$currPos),\n        location\n      );\n    }\n\n    function error(message, location) {\n      location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)\n\n      throw peg$buildSimpleError(message, location);\n    }\n\n    function peg$literalExpectation(text, ignoreCase) {\n      return { type: \"literal\", text: text, ignoreCase: ignoreCase };\n    }\n\n    function peg$classExpectation(parts, inverted, ignoreCase) {\n      return { type: \"class\", parts: parts, inverted: inverted, ignoreCase: ignoreCase };\n    }\n\n    function peg$anyExpectation() {\n      return { type: \"any\" };\n    }\n\n    function peg$endExpectation() {\n      return { type: \"end\" };\n    }\n\n    function peg$otherExpectation(description) {\n      return { type: \"other\", description: description };\n    }\n\n    function peg$computePosDetails(pos) {\n      var details = peg$posDetailsCache[pos], p;\n\n      if (details) {\n        return details;\n      } else {\n        p = pos - 1;\n        while (!peg$posDetailsCache[p]) {\n          p--;\n        }\n\n        details = peg$posDetailsCache[p];\n        details = {\n          line:   details.line,\n          column: details.column\n        };\n\n        while (p < pos) {\n          if (input.charCodeAt(p) === 10) {\n            details.line++;\n            details.column = 1;\n          } else {\n            details.column++;\n          }\n\n          p++;\n        }\n\n        peg$posDetailsCache[pos] = details;\n        return details;\n      }\n    }\n\n    function peg$computeLocation(startPos, endPos) {\n      var startPosDetails = peg$computePosDetails(startPos),\n          endPosDetails   = peg$computePosDetails(endPos);\n\n      return {\n        start: {\n          offset: startPos,\n          line:   startPosDetails.line,\n          column: startPosDetails.column\n        },\n        end: {\n          offset: endPos,\n          line:   endPosDetails.line,\n          column: endPosDetails.column\n        }\n      };\n    }\n\n    function peg$fail(expected) {\n      if (peg$currPos < peg$maxFailPos) { return; }\n\n      if (peg$currPos > peg$maxFailPos) {\n        peg$maxFailPos = peg$currPos;\n        peg$maxFailExpected = [];\n      }\n\n      peg$maxFailExpected.push(expected);\n    }\n\n    function peg$buildSimpleError(message, location) {\n      return new peg$SyntaxError(message, null, null, location);\n    }\n\n    function peg$buildStructuredError(expected, found, location) {\n      return new peg$SyntaxError(\n        peg$SyntaxError.buildMessage(expected, found),\n        expected,\n        found,\n        location\n      );\n    }\n\n    function peg$parsefragment() {\n      var s0, s1, s2, s3;\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 8) === peg$c0) {\n        s1 = peg$c0;\n        peg$currPos += 8;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c1); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parserange();\n        if (s2 === peg$FAILED) {\n          s2 = peg$parsepath();\n        }\n        if (s2 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 41) {\n            s3 = peg$c2;\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c3); }\n          }\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c4(s2);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parserange() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      s0 = peg$currPos;\n      s1 = peg$parseindexStep();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parselocal_path();\n        if (s2 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 44) {\n            s3 = peg$c5;\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c6); }\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parselocal_path();\n            if (s4 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 44) {\n                s5 = peg$c5;\n                peg$currPos++;\n              } else {\n                s5 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c6); }\n              }\n              if (s5 !== peg$FAILED) {\n                s6 = peg$parselocal_path();\n                if (s6 !== peg$FAILED) {\n                  peg$savedPos = s0;\n                  s1 = peg$c7(s1, s2, s4, s6);\n                  s0 = s1;\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parsepath() {\n      var s0, s1, s2;\n\n      s0 = peg$currPos;\n      s1 = peg$parseindexStep();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parselocal_path();\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c8(s1, s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parselocal_path() {\n      var s0, s1, s2;\n\n      s0 = peg$currPos;\n      s1 = [];\n      s2 = peg$parseindexStep();\n      if (s2 === peg$FAILED) {\n        s2 = peg$parseindirectionStep();\n      }\n      if (s2 !== peg$FAILED) {\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          s2 = peg$parseindexStep();\n          if (s2 === peg$FAILED) {\n            s2 = peg$parseindirectionStep();\n          }\n        }\n      } else {\n        s1 = peg$FAILED;\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseterminus();\n        if (s2 === peg$FAILED) {\n          s2 = null;\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c9(s1, s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseindexStep() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 47) {\n        s1 = peg$c10;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c11); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseinteger();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$currPos;\n          if (input.charCodeAt(peg$currPos) === 91) {\n            s4 = peg$c12;\n            peg$currPos++;\n          } else {\n            s4 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c13); }\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parseidAssertion();\n            if (s5 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 93) {\n                s6 = peg$c14;\n                peg$currPos++;\n              } else {\n                s6 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c15); }\n              }\n              if (s6 !== peg$FAILED) {\n                s4 = [s4, s5, s6];\n                s3 = s4;\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n          if (s3 === peg$FAILED) {\n            s3 = null;\n          }\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c16(s2, s3);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseindirectionStep() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 2) === peg$c17) {\n        s1 = peg$c17;\n        peg$currPos += 2;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c18); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseinteger();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$currPos;\n          if (input.charCodeAt(peg$currPos) === 91) {\n            s4 = peg$c12;\n            peg$currPos++;\n          } else {\n            s4 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c13); }\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parseidAssertion();\n            if (s5 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 93) {\n                s6 = peg$c14;\n                peg$currPos++;\n              } else {\n                s6 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c15); }\n              }\n              if (s6 !== peg$FAILED) {\n                s4 = [s4, s5, s6];\n                s3 = s4;\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n          if (s3 === peg$FAILED) {\n            s3 = null;\n          }\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c19(s2, s3);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseterminus() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 58) {\n        s1 = peg$c20;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c21); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseinteger();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$currPos;\n          if (input.charCodeAt(peg$currPos) === 91) {\n            s4 = peg$c12;\n            peg$currPos++;\n          } else {\n            s4 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c13); }\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parsetextLocationAssertion();\n            if (s5 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 93) {\n                s6 = peg$c14;\n                peg$currPos++;\n              } else {\n                s6 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c15); }\n              }\n              if (s6 !== peg$FAILED) {\n                s4 = [s4, s5, s6];\n                s3 = s4;\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n          if (s3 === peg$FAILED) {\n            s3 = null;\n          }\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c22(s2, s3);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseidAssertion() {\n      var s0, s1;\n\n      s0 = peg$currPos;\n      s1 = peg$parsevalue();\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c23(s1);\n      }\n      s0 = s1;\n\n      return s0;\n    }\n\n    function peg$parsetextLocationAssertion() {\n      var s0, s1, s2;\n\n      s0 = peg$currPos;\n      s1 = peg$parsecsv();\n      if (s1 === peg$FAILED) {\n        s1 = null;\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseparameter();\n        if (s2 === peg$FAILED) {\n          s2 = null;\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c24(s1, s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseparameter() {\n      var s0, s1, s2, s3, s4;\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 59) {\n        s1 = peg$c25;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c26); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parsevalueNoSpace();\n        if (s2 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 61) {\n            s3 = peg$c27;\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c28); }\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parsevalueNoSpace();\n            if (s4 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c29(s2, s4);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parsecsv() {\n      var s0, s1, s2, s3;\n\n      s0 = peg$currPos;\n      s1 = peg$parsevalue();\n      if (s1 === peg$FAILED) {\n        s1 = null;\n      }\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 44) {\n          s2 = peg$c5;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c6); }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parsevalue();\n          if (s3 === peg$FAILED) {\n            s3 = null;\n          }\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c30(s1, s3);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parsevalueNoSpace() {\n      var s0, s1, s2;\n\n      s0 = peg$currPos;\n      s1 = [];\n      s2 = peg$parseescapedSpecialChars();\n      if (s2 === peg$FAILED) {\n        s2 = peg$parsecharacter();\n      }\n      if (s2 !== peg$FAILED) {\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          s2 = peg$parseescapedSpecialChars();\n          if (s2 === peg$FAILED) {\n            s2 = peg$parsecharacter();\n          }\n        }\n      } else {\n        s1 = peg$FAILED;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c31(s1);\n      }\n      s0 = s1;\n\n      return s0;\n    }\n\n    function peg$parsevalue() {\n      var s0, s1, s2;\n\n      s0 = peg$currPos;\n      s1 = [];\n      s2 = peg$parseescapedSpecialChars();\n      if (s2 === peg$FAILED) {\n        s2 = peg$parsecharacter();\n        if (s2 === peg$FAILED) {\n          s2 = peg$parsespace();\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          s2 = peg$parseescapedSpecialChars();\n          if (s2 === peg$FAILED) {\n            s2 = peg$parsecharacter();\n            if (s2 === peg$FAILED) {\n              s2 = peg$parsespace();\n            }\n          }\n        }\n      } else {\n        s1 = peg$FAILED;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c31(s1);\n      }\n      s0 = s1;\n\n      return s0;\n    }\n\n    function peg$parseescapedSpecialChars() {\n      var s0, s1, s2, s3;\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsecircumflex();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsecircumflex();\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n      if (s1 === peg$FAILED) {\n        s1 = peg$currPos;\n        s2 = peg$parsecircumflex();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parsesquareBracket();\n          if (s3 !== peg$FAILED) {\n            s2 = [s2, s3];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n        if (s1 === peg$FAILED) {\n          s1 = peg$currPos;\n          s2 = peg$parsecircumflex();\n          if (s2 !== peg$FAILED) {\n            s3 = peg$parseparentheses();\n            if (s3 !== peg$FAILED) {\n              s2 = [s2, s3];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$FAILED;\n          }\n          if (s1 === peg$FAILED) {\n            s1 = peg$currPos;\n            s2 = peg$parsecircumflex();\n            if (s2 !== peg$FAILED) {\n              s3 = peg$parsecomma();\n              if (s3 !== peg$FAILED) {\n                s2 = [s2, s3];\n                s1 = s2;\n              } else {\n                peg$currPos = s1;\n                s1 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s1;\n              s1 = peg$FAILED;\n            }\n            if (s1 === peg$FAILED) {\n              s1 = peg$currPos;\n              s2 = peg$parsecircumflex();\n              if (s2 !== peg$FAILED) {\n                s3 = peg$parsesemicolon();\n                if (s3 !== peg$FAILED) {\n                  s2 = [s2, s3];\n                  s1 = s2;\n                } else {\n                  peg$currPos = s1;\n                  s1 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s1;\n                s1 = peg$FAILED;\n              }\n              if (s1 === peg$FAILED) {\n                s1 = peg$currPos;\n                s2 = peg$parsecircumflex();\n                if (s2 !== peg$FAILED) {\n                  s3 = peg$parseequal();\n                  if (s3 !== peg$FAILED) {\n                    s2 = [s2, s3];\n                    s1 = s2;\n                  } else {\n                    peg$currPos = s1;\n                    s1 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s1;\n                  s1 = peg$FAILED;\n                }\n              }\n            }\n          }\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c32(s1);\n      }\n      s0 = s1;\n\n      return s0;\n    }\n\n    function peg$parsenumber() {\n      var s0, s1, s2, s3, s4, s5;\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      if (peg$c33.test(input.charAt(peg$currPos))) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c34); }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = [];\n        if (peg$c35.test(input.charAt(peg$currPos))) {\n          s4 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s4 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c36); }\n        }\n        if (s4 !== peg$FAILED) {\n          while (s4 !== peg$FAILED) {\n            s3.push(s4);\n            if (peg$c35.test(input.charAt(peg$currPos))) {\n              s4 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s4 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c36); }\n            }\n          }\n        } else {\n          s3 = peg$FAILED;\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 46) {\n          s2 = peg$c37;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c38); }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$currPos;\n          s4 = [];\n          if (peg$c35.test(input.charAt(peg$currPos))) {\n            s5 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c36); }\n          }\n          while (s5 !== peg$FAILED) {\n            s4.push(s5);\n            if (peg$c35.test(input.charAt(peg$currPos))) {\n              s5 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c36); }\n            }\n          }\n          if (s4 !== peg$FAILED) {\n            if (peg$c33.test(input.charAt(peg$currPos))) {\n              s5 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c34); }\n            }\n            if (s5 !== peg$FAILED) {\n              s4 = [s4, s5];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c39(s1, s3);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseinteger() {\n      var s0, s1, s2, s3, s4;\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 48) {\n        s1 = peg$c40;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c41); }\n      }\n      if (s1 === peg$FAILED) {\n        s1 = peg$currPos;\n        if (peg$c33.test(input.charAt(peg$currPos))) {\n          s2 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c34); }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = [];\n          if (peg$c35.test(input.charAt(peg$currPos))) {\n            s4 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s4 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c36); }\n          }\n          while (s4 !== peg$FAILED) {\n            s3.push(s4);\n            if (peg$c35.test(input.charAt(peg$currPos))) {\n              s4 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s4 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c36); }\n            }\n          }\n          if (s3 !== peg$FAILED) {\n            s2 = [s2, s3];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c42(s1);\n      }\n      s0 = s1;\n\n      return s0;\n    }\n\n    function peg$parsespace() {\n      var s0, s1;\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 32) {\n        s1 = peg$c43;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c44); }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c45();\n      }\n      s0 = s1;\n\n      return s0;\n    }\n\n    function peg$parsecircumflex() {\n      var s0, s1;\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 94) {\n        s1 = peg$c46;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c47); }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c48();\n      }\n      s0 = s1;\n\n      return s0;\n    }\n\n    function peg$parsedoubleQuote() {\n      var s0, s1;\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 34) {\n        s1 = peg$c49;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c50); }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c51();\n      }\n      s0 = s1;\n\n      return s0;\n    }\n\n    function peg$parsesquareBracket() {\n      var s0, s1;\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 91) {\n        s1 = peg$c12;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c13); }\n      }\n      if (s1 === peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 93) {\n          s1 = peg$c14;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c15); }\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c52(s1);\n      }\n      s0 = s1;\n\n      return s0;\n    }\n\n    function peg$parseparentheses() {\n      var s0, s1;\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 40) {\n        s1 = peg$c53;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c54); }\n      }\n      if (s1 === peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 41) {\n          s1 = peg$c2;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c3); }\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c55(s1);\n      }\n      s0 = s1;\n\n      return s0;\n    }\n\n    function peg$parsecomma() {\n      var s0, s1;\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 44) {\n        s1 = peg$c5;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c6); }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c56();\n      }\n      s0 = s1;\n\n      return s0;\n    }\n\n    function peg$parsesemicolon() {\n      var s0, s1;\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 59) {\n        s1 = peg$c25;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c26); }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c57();\n      }\n      s0 = s1;\n\n      return s0;\n    }\n\n    function peg$parseequal() {\n      var s0, s1;\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 61) {\n        s1 = peg$c27;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c28); }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c58();\n      }\n      s0 = s1;\n\n      return s0;\n    }\n\n    function peg$parsecharacter() {\n      var s0, s1;\n\n      s0 = peg$currPos;\n      if (peg$c59.test(input.charAt(peg$currPos))) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c60); }\n      }\n      if (s1 === peg$FAILED) {\n        if (peg$c61.test(input.charAt(peg$currPos))) {\n          s1 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c62); }\n        }\n        if (s1 === peg$FAILED) {\n          if (peg$c35.test(input.charAt(peg$currPos))) {\n            s1 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c36); }\n          }\n          if (s1 === peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 45) {\n              s1 = peg$c63;\n              peg$currPos++;\n            } else {\n              s1 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c64); }\n            }\n            if (s1 === peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 95) {\n                s1 = peg$c65;\n                peg$currPos++;\n              } else {\n                s1 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c66); }\n              }\n              if (s1 === peg$FAILED) {\n                if (input.charCodeAt(peg$currPos) === 46) {\n                  s1 = peg$c37;\n                  peg$currPos++;\n                } else {\n                  s1 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c38); }\n                }\n                if (s1 === peg$FAILED) {\n                  if (input.charCodeAt(peg$currPos) === 37) {\n                    s1 = peg$c67;\n                    peg$currPos++;\n                  } else {\n                    s1 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$c68); }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c69(s1);\n      }\n      s0 = s1;\n\n      return s0;\n    }\n\n    peg$result = peg$startRuleFunction();\n\n    if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n      return peg$result;\n    } else {\n      if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n        peg$fail(peg$endExpectation());\n      }\n\n      throw peg$buildStructuredError(\n        peg$maxFailExpected,\n        peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,\n        peg$maxFailPos < input.length\n          ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)\n          : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)\n      );\n    }\n  }\n\n  root.window.EPUBcfiParser = {\n    SyntaxError: peg$SyntaxError,\n    parse:       peg$parse\n  };\n})(this);\n\ndefine(\"readium_cfi_js/cfi_parser\", (function (global) {\n    return function () {\n        var ret, fn;\n        return ret || global.EPUBcfiParser;\n    };\n}(this)));\n\n",
    "//  Copyright (c) 2014 Readium Foundation and/or its licensees. All rights reserved.\r\n//  \r\n//  Redistribution and use in source and binary forms, with or without modification, \r\n//  are permitted provided that the following conditions are met:\r\n//  1. Redistributions of source code must retain the above copyright notice, this \r\n//  list of conditions and the following disclaimer.\r\n//  2. Redistributions in binary form must reproduce the above copyright notice, \r\n//  this list of conditions and the following disclaimer in the documentation and/or \r\n//  other materials provided with the distribution.\r\n//  3. Neither the name of the organization nor the names of its contributors may be \r\n//  used to endorse or promote products derived from this software without specific \r\n//  prior written permission.\r\n\r\n(function(global) {\r\n\r\n\r\n// Description: This is a set of runtime errors that the CFI interpreter can throw. \r\n// Rationale: These error types extend the basic javascript error object so error things like the stack trace are \r\n//   included with the runtime errors. \r\n\r\n// REFACTORING CANDIDATE: This type of error may not be required in the long run. The parser should catch any syntax errors, \r\n//   provided it is error-free, and as such, the AST should never really have any node type errors, which are essentially errors\r\n//   in the structure of the AST. This error should probably be refactored out when the grammar and interpreter are more stable.\r\n\r\nvar obj = {\r\n\r\nNodeTypeError: function (node, message) {\r\n\r\n    function NodeTypeError () {\r\n\r\n        this.node = node;\r\n    }\r\n\r\n    NodeTypeError.prototype = new Error(message);\r\n    NodeTypeError.constructor = NodeTypeError;\r\n\r\n    return new NodeTypeError();\r\n},\r\n\r\n// REFACTORING CANDIDATE: Might make sense to include some more specifics about the out-of-rangeyness.\r\nOutOfRangeError: function (targetIndex, maxIndex, message) {\r\n\r\n    function OutOfRangeError () {\r\n\r\n        this.targetIndex = targetIndex;\r\n        this.maxIndex = maxIndex;\r\n    }\r\n\r\n    OutOfRangeError.prototype = new Error(message);\r\n    OutOfRangeError.constructor = OutOfRangeError()\r\n\r\n    return new OutOfRangeError();\r\n},\r\n\r\n// REFACTORING CANDIDATE: This is a bit too general to be useful. When I have a better understanding of the type of errors\r\n//   that can occur with the various terminus conditions, it'll make more sense to revisit this. \r\nTerminusError: function (terminusType, terminusCondition, message) {\r\n\r\n    function TerminusError () {\r\n\r\n        this.terminusType = terminusType;\r\n        this.terminusCondition = terminusCondition;\r\n    }\r\n\r\n    TerminusError.prototype = new Error(message);\r\n    TerminusError.constructor = TerminusError();\r\n\r\n    return new TerminusError();\r\n},\r\n\r\nCFIAssertionError: function (expectedAssertion, targetElementAssertion, message) {\r\n\r\n    function CFIAssertionError () {\r\n\r\n        this.expectedAssertion = expectedAssertion;\r\n        this.targetElementAssertion = targetElementAssertion;\r\n    }\r\n\r\n    CFIAssertionError.prototype = new Error(message);\r\n    CFIAssertionError.constructor = CFIAssertionError();\r\n\r\n    return new CFIAssertionError();\r\n}\r\n\r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nif (typeof define == 'function' && typeof define.amd == 'object') {\r\n    console.log(\"RequireJS ... cfi_errors\");\r\n    \r\n    define('readium_cfi_js/cfi_runtime_errors',[],\r\n    function () {\r\n        return obj;\r\n    });\r\n} else {\r\n    console.log(\"!RequireJS ... cfi_errors\");\r\n    \r\n    if (!global[\"EPUBcfi\"]) {\r\n        throw new Error(\"EPUBcfi not initialised on global object?! (window or this context)\");\r\n    }\r\n    \r\n    global.EPUBcfi.NodeTypeError = obj.NodeTypeError;\r\n    global.EPUBcfi.OutOfRangeError = obj.OutOfRangeError;\r\n    global.EPUBcfi.TerminusError = obj.TerminusError;\r\n    global.EPUBcfi.CFIAssertionError = obj.CFIAssertionError;\r\n}\r\n\r\n})(typeof window !== \"undefined\" ? window : this);\r\n\n",
    "//  Copyright (c) 2014 Readium Foundation and/or its licensees. All rights reserved.\r\n//  \r\n//  Redistribution and use in source and binary forms, with or without modification, \r\n//  are permitted provided that the following conditions are met:\r\n//  1. Redistributions of source code must retain the above copyright notice, this \r\n//  list of conditions and the following disclaimer.\r\n//  2. Redistributions in binary form must reproduce the above copyright notice, \r\n//  this list of conditions and the following disclaimer in the documentation and/or \r\n//  other materials provided with the distribution.\r\n//  3. Neither the name of the organization nor the names of its contributors may be \r\n//  used to endorse or promote products derived from this software without specific \r\n//  prior written permission.\r\n\r\n(function(global) {\r\n\r\nvar init = function($, cfiRuntimeErrors) {\r\n    \r\nvar obj = {\r\n\r\n// Description: This model contains the implementation for \"instructions\" included in the EPUB CFI domain specific language (DSL). \r\n//   Lexing and parsing a CFI produces a set of executable instructions for processing a CFI (represented in the AST). \r\n//   This object contains a set of functions that implement each of the executable instructions in the AST. \r\n\r\n    // ------------------------------------------------------------------------------------ //\r\n    //  \"PUBLIC\" METHODS (THE API)                                                          //\r\n    // ------------------------------------------------------------------------------------ //\r\n\r\n    // Description: Follows a step\r\n    // Rationale: The use of children() is important here, as this jQuery method returns a tree of xml nodes, EXCLUDING\r\n    //   CDATA and text nodes. When we index into the set of child elements, we are assuming that text nodes have been \r\n    //   excluded.\r\n    // REFACTORING CANDIDATE: This should be called \"followIndexStep\"\r\n    getNextNode : function (CFIStepValue, $currNode, classBlacklist, elementBlacklist, idBlacklist) {\r\n\r\n        // Find the jquery index for the current node\r\n        var $targetNode;\r\n        if (CFIStepValue % 2 == 0) {\r\n\r\n            $targetNode = this.elementNodeStep(CFIStepValue, $currNode, classBlacklist, elementBlacklist, idBlacklist);\r\n        }\r\n        else {\r\n\r\n            $targetNode = this.inferTargetTextNode(CFIStepValue, $currNode, classBlacklist, elementBlacklist, idBlacklist);\r\n        }\r\n\r\n        return $targetNode;\r\n    },\r\n\r\n    // Description: This instruction executes an indirection step, where a resource is retrieved using a \r\n    //   link contained on a attribute of the target element. The attribute that contains the link differs\r\n    //   depending on the target. \r\n    // Note: Iframe indirection will (should) fail if the iframe is not from the same domain as its containing script due to \r\n    //   the cross origin security policy\r\n    followIndirectionStep : function (CFIStepValue, $currNode, classBlacklist, elementBlacklist, idBlacklist) {\r\n\r\n        var that = this;\r\n        var $contentDocument; \r\n        var $blacklistExcluded;\r\n        var $startElement;\r\n        var $targetNode;\r\n\r\n        // TODO: This check must be expanded to all the different types of indirection step\r\n        // Only expects iframes, at the moment\r\n        if ($currNode === undefined || !$currNode.is(\"iframe\")) {\r\n\r\n            throw cfiRuntimeErrors.NodeTypeError($currNode, \"expected an iframe element\");\r\n        }\r\n\r\n        // Check node type; only iframe indirection is handled, at the moment\r\n        if ($currNode.is(\"iframe\")) {\r\n\r\n            // Get content\r\n            $contentDocument = $currNode.contents();\r\n\r\n            // Go to the first XHTML element, which will be the first child of the top-level document object\r\n            $blacklistExcluded = this.applyBlacklist($contentDocument.children(), classBlacklist, elementBlacklist, idBlacklist);\r\n            $startElement = $($blacklistExcluded[0]);\r\n\r\n            // Follow an index step\r\n            $targetNode = this.getNextNode(CFIStepValue, $startElement, classBlacklist, elementBlacklist, idBlacklist);\r\n\r\n            // Return that shit!\r\n            return $targetNode; \r\n        }\r\n\r\n        // TODO: Other types of indirection\r\n        // TODO: $targetNode.is(\"embed\")) : src\r\n        // TODO: ($targetNode.is(\"object\")) : data\r\n        // TODO: ($targetNode.is(\"image\") || $targetNode.is(\"xlink:href\")) : xlink:href\r\n    },\r\n\r\n    // Description: Injects an element at the specified text node\r\n    // Arguments: a cfi text termination string, a jquery object to the current node\r\n    // REFACTORING CANDIDATE: Rename this to indicate that it injects into a text terminus\r\n    textTermination : function ($currNode, textOffset, elementToInject) {\r\n\r\n        var $injectedElement;\r\n        // Get the first node, this should be a text node\r\n        if ($currNode === undefined) {\r\n\r\n            throw cfiRuntimeErrors.NodeTypeError($currNode, \"expected a terminating node, or node list\");\r\n        } \r\n        else if ($currNode.length === 0) {\r\n\r\n            throw cfiRuntimeErrors.TerminusError(\"Text\", \"Text offset:\" + textOffset, \"no nodes found for termination condition\");\r\n        }\r\n\r\n        $injectedElement = this.injectCFIMarkerIntoText($currNode, textOffset, elementToInject);\r\n        return $injectedElement;\r\n    },\r\n\r\n    // Description: Checks that the id assertion for the node target matches that on \r\n    //   the found node. \r\n    targetIdMatchesIdAssertion : function ($foundNode, idAssertion) {\r\n\r\n        if ($foundNode.attr(\"id\") === idAssertion) {\r\n\r\n            return true;\r\n        }\r\n        else {\r\n\r\n            return false;\r\n        }\r\n    },\r\n\r\n    // ------------------------------------------------------------------------------------ //\r\n    //  \"PRIVATE\" HELPERS                                                                   //\r\n    // ------------------------------------------------------------------------------------ //\r\n\r\n    // Description: Step reference for xml element node. Expected that CFIStepValue is an even integer\r\n    elementNodeStep : function (CFIStepValue, $currNode, classBlacklist, elementBlacklist, idBlacklist) {\r\n\r\n        var $targetNode;\r\n        var $blacklistExcluded;\r\n        var numElements;\r\n        var jqueryTargetNodeIndex = (CFIStepValue / 2) - 1;\r\n\r\n        $blacklistExcluded = this.applyBlacklist($currNode.children(), classBlacklist, elementBlacklist, idBlacklist);\r\n        numElements = $blacklistExcluded.length;\r\n\r\n        if (this.indexOutOfRange(jqueryTargetNodeIndex, numElements)) {\r\n\r\n            throw cfiRuntimeErrors.OutOfRangeError(jqueryTargetNodeIndex, numElements - 1, \"\");\r\n        }\r\n\r\n        $targetNode = $($blacklistExcluded[jqueryTargetNodeIndex]);\r\n        return $targetNode;\r\n    },\r\n\r\n    retrieveItemRefHref : function ($itemRefElement, $packageDocument) {\r\n\r\n        return $(\"#\" + $itemRefElement.attr(\"idref\"), $packageDocument).attr(\"href\");\r\n    },\r\n\r\n    indexOutOfRange : function (targetIndex, numChildElements) {\r\n\r\n        return (targetIndex > numChildElements - 1) ? true : false;\r\n    },\r\n\r\n    // Rationale: In order to inject an element into a specific position, access to the parent object \r\n    //   is required. This is obtained with the jquery parent() method. An alternative would be to \r\n    //   pass in the parent with a filtered list containing only children that are part of the target text node.\r\n    injectCFIMarkerIntoText : function ($textNodeList, textOffset, elementToInject) {\r\n        var document = $textNodeList[0].ownerDocument;\r\n\r\n        var nodeNum;\r\n        var currNodeLength;\r\n        var currTextPosition = 0;\r\n        var nodeOffset;\r\n        var originalText;\r\n        var $injectedNode;\r\n        var $newTextNode;\r\n        // The iteration counter may be incorrect here (should be $textNodeList.length - 1 ??)\r\n        for (nodeNum = 0; nodeNum <= $textNodeList.length; nodeNum++) {\r\n\r\n            if ($textNodeList[nodeNum].nodeType === Node.TEXT_NODE) {\r\n\r\n                currNodeMaxIndex = $textNodeList[nodeNum].nodeValue.length  + currTextPosition;\r\n                nodeOffset = textOffset - currTextPosition;\r\n\r\n                if (currNodeMaxIndex > textOffset) {\r\n\r\n                    // This node is going to be split and the components re-inserted\r\n                    originalText = $textNodeList[nodeNum].nodeValue;    \r\n\r\n                    // Before part\r\n                    $textNodeList[nodeNum].nodeValue = originalText.slice(0, nodeOffset);\r\n\r\n                    // Injected element\r\n                    $injectedNode = $(elementToInject).insertAfter($textNodeList.eq(nodeNum));\r\n\r\n                    // After part\r\n                    $newTextNode = $(document.createTextNode(originalText.slice(nodeOffset, originalText.length)));\r\n                    $($newTextNode).insertAfter($injectedNode);\r\n\r\n                    return $injectedNode;\r\n                } else if (currNodeMaxIndex == textOffset){\r\n                    $injectedNode = $(elementToInject).insertAfter($textNodeList.eq(nodeNum));\r\n                    return $injectedNode;\r\n                }\r\n                else {\r\n                    currTextPosition = currNodeMaxIndex;\r\n                }\r\n            } else if($textNodeList[nodeNum].nodeType === Node.COMMENT_NODE){\r\n                currNodeMaxIndex = $textNodeList[nodeNum].nodeValue.length + 7 + currTextPosition;\r\n                currTextPosition = currNodeMaxIndex;\r\n            } else if($textNodeList[nodeNum].nodeType === Node.PROCESSING_INSTRUCTION_NODE){\r\n                currNodeMaxIndex = $textNodeList[nodeNum].nodeValue.length + $textNodeList[nodeNum].target.length + 5\r\n                currTextPosition = currNodeMaxIndex;\r\n            }\r\n        }\r\n\r\n        throw cfiRuntimeErrors.TerminusError(\"Text\", \"Text offset:\" + textOffset, \"The offset exceeded the length of the text\");\r\n    },\r\n\r\n    // Rationale: In order to inject an element into a specific position, access to the parent object \r\n    //   is required. This is obtained with the jquery parent() method. An alternative would be to \r\n    //   pass in the parent with a filtered list containing only children that are part of the target text node.\r\n\r\n    // Description: This method finds a target text node and then injects an element into the appropriate node\r\n    // Rationale: The possibility that cfi marker elements have been injected into a text node at some point previous to \r\n    //   this method being called (and thus splitting the original text node into two separate text nodes) necessitates that\r\n    //   the set of nodes that compromised the original target text node are inferred and returned.\r\n    // Notes: Passed a current node. This node should have a set of elements under it. This will include at least one text node, \r\n    //   element nodes (maybe), or possibly a mix. \r\n    // REFACTORING CANDIDATE: This method is pretty long (and confusing). Worth investigating to see if it can be refactored into something clearer.\r\n    inferTargetTextNode : function (CFIStepValue, $currNode, classBlacklist, elementBlacklist, idBlacklist) {\r\n        \r\n        var $elementsWithoutMarkers;\r\n        var currLogicalTextNodeIndex;\r\n        var targetLogicalTextNodeIndex;\r\n        var nodeNum;\r\n        var $targetTextNodeList;\r\n        var prevNodeWasTextNode;\r\n\r\n        // Remove any cfi marker elements from the set of elements. \r\n        // Rationale: A filtering function is used, as simply using a class selector with jquery appears to \r\n        //   result in behaviour where text nodes are also filtered out, along with the class element being filtered.\r\n        $elementsWithoutMarkers = this.applyBlacklist($currNode.contents(), classBlacklist, elementBlacklist, idBlacklist);\r\n\r\n        // Convert CFIStepValue to logical index; assumes odd integer for the step value\r\n        targetLogicalTextNodeIndex = ((parseInt(CFIStepValue) + 1) / 2) - 1;\r\n\r\n        // Set text node position counter\r\n        currLogicalTextNodeIndex = 0;\r\n        prevNodeWasTextNode = false;\r\n        $targetTextNodeList = $elementsWithoutMarkers.filter(\r\n            function () {\r\n\r\n                if (currLogicalTextNodeIndex === targetLogicalTextNodeIndex) {\r\n\r\n                    // If it's a text node\r\n                    if (this.nodeType === Node.TEXT_NODE || this.nodeType === Node.COMMENT_NODE || this.nodeType === Node.PROCESSING_INSTRUCTION_NODE) {\r\n                        prevNodeWasTextNode = true;\r\n                        return true;\r\n                    }\r\n                    // Rationale: The logical text node position is only incremented once a group of text nodes (a single logical\r\n                    //   text node) has been passed by the loop. \r\n                    else if (prevNodeWasTextNode && (this.nodeType !== Node.TEXT_NODE)) {\r\n                        currLogicalTextNodeIndex++;\r\n                        prevNodeWasTextNode = false;\r\n                        return false;\r\n                    }\r\n                }\r\n                // Don't return any elements\r\n                else {\r\n\r\n                    if (this.nodeType === Node.TEXT_NODE || this.nodeType === Node.COMMENT_NODE || this.nodeType === Node.PROCESSING_INSTRUCTION_NODE) {\r\n                        prevNodeWasTextNode = true;\r\n                    }else if (!prevNodeWasTextNode && this.nodeType === Node.ELEMENT_NODE){\r\n                        currLogicalTextNodeIndex++;\r\n                        prevNodeWasTextNode = true;\r\n                    }\r\n                    else if (prevNodeWasTextNode && (this.nodeType !== Node.TEXT_NODE) && (this !== $elementsWithoutMarkers.lastChild)) {\r\n                        currLogicalTextNodeIndex++;\r\n                        prevNodeWasTextNode = false;\r\n                    }\r\n\r\n                    return false;\r\n                }\r\n            }\r\n        );\r\n\r\n        // The filtering above should have counted the number of \"logical\" text nodes; this can be used to \r\n        // detect out of range errors\r\n        if ($targetTextNodeList.length === 0) {\r\n            throw cfiRuntimeErrors.OutOfRangeError(targetLogicalTextNodeIndex, currLogicalTextNodeIndex, \"Index out of range\");\r\n        }\r\n\r\n        // return the text node list\r\n        return $targetTextNodeList;\r\n    },\r\n\r\n    applyBlacklist : function ($elements, classBlacklist, elementBlacklist, idBlacklist) {\r\n\r\n        var $filteredElements;\r\n\r\n        $filteredElements = $elements.filter(\r\n            function () {\r\n\r\n                var $currElement = $(this);\r\n                var includeInList = true;\r\n\r\n                if (classBlacklist) {\r\n\r\n                    // Filter each element with the class type\r\n                    $.each(classBlacklist, function (index, value) {\r\n\r\n                        if ($currElement.hasClass(value)) {\r\n                            includeInList = false;\r\n\r\n                            // Break this loop\r\n                            return false;\r\n                        }\r\n                    });\r\n                }\r\n\r\n                if (elementBlacklist) {\r\n                    \r\n                    // For each type of element\r\n                    $.each(elementBlacklist, function (index, value) {\r\n\r\n                        if ($currElement.is(value)) {\r\n                            includeInList = false;\r\n\r\n                            // Break this loop\r\n                            return false;\r\n                        }\r\n                    });\r\n                }\r\n\r\n                if (idBlacklist) {\r\n                    \r\n                    // For each type of element\r\n                    $.each(idBlacklist, function (index, value) {\r\n\r\n                        if ($currElement.attr(\"id\") === value) {\r\n                            includeInList = false;\r\n\r\n                            // Break this loop\r\n                            return false;\r\n                        }\r\n                    });\r\n                }\r\n\r\n                return includeInList;\r\n            }\r\n        );\r\n\r\n        return $filteredElements;\r\n    }\r\n};\r\n\r\nreturn obj;\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nif (typeof define == 'function' && typeof define.amd == 'object') {\r\n    console.log(\"RequireJS ... cfi_instructions\");\r\n    \r\n    define('readium_cfi_js/cfi_instructions',['jquery', './cfi_runtime_errors'],\r\n    function ($, cfiRuntimeErrors) {\r\n        return init($, cfiRuntimeErrors);\r\n    });\r\n} else {\r\n    console.log(\"!RequireJS ... cfi_instructions\");\r\n    \r\n    if (!global[\"EPUBcfi\"]) {\r\n        throw new Error(\"EPUBcfi not initialised on global object?! (window or this context)\");\r\n    }\r\n    global.EPUBcfi.CFIInstructions = \r\n    init($,\r\n        {\r\n            NodeTypeError: global.EPUBcfi.NodeTypeError,\r\n            OutOfRangeError: global.EPUBcfi.OutOfRangeError,\r\n            TerminusError: global.EPUBcfi.TerminusError,\r\n            CFIAssertionError: global.EPUBcfi.CFIAssertionError\r\n        });\r\n}\r\n\r\n})(typeof window !== \"undefined\" ? window : this);\r\n\n",
    "//  Copyright (c) 2014 Readium Foundation and/or its licensees. All rights reserved.\r\n//\r\n//  Redistribution and use in source and binary forms, with or without modification,\r\n//  are permitted provided that the following conditions are met:\r\n//  1. Redistributions of source code must retain the above copyright notice, this\r\n//  list of conditions and the following disclaimer.\r\n//  2. Redistributions in binary form must reproduce the above copyright notice,\r\n//  this list of conditions and the following disclaimer in the documentation and/or\r\n//  other materials provided with the distribution.\r\n//  3. Neither the name of the organization nor the names of its contributors may be\r\n//  used to endorse or promote products derived from this software without specific\r\n//  prior written permission.\r\n\r\n(function(global) {\r\n\r\nvar init = function($, cfiParser, cfiInstructions, cfiRuntimeErrors) {\r\n\r\n    if (typeof cfiParser === \"undefined\") {\r\n        throw new Error(\"UNDEFINED?! cfiParser\");\r\n    }\r\n\r\n    if (typeof cfiInstructions === \"undefined\") {\r\n        throw new Error(\"UNDEFINED?! cfiInstructions\");\r\n    }\r\n\r\n    if (typeof cfiRuntimeErrors === \"undefined\") {\r\n        throw new Error(\"UNDEFINED?! cfiRuntimeErrors\");\r\n    }\r\n\r\nvar obj = {\r\n\r\n// Description: This is an interpreter that inteprets an Abstract Syntax Tree (AST) for a CFI. The result of executing the interpreter\r\n//   is to inject an element, or set of elements, into an EPUB content document (which is just an XHTML document). These element(s) will\r\n//   represent the position or area in the EPUB referenced by a CFI.\r\n// Rationale: The AST is a clean and readable expression of the step-terminus structure of a CFI. Although building an interpreter adds to the\r\n//   CFI infrastructure, it provides a number of benefits. First, it emphasizes a clear separation of concerns between lexing/parsing a\r\n//   CFI, which involves some complexity related to escaped and special characters, and the execution of the underlying set of steps\r\n//   represented by the CFI. Second, it will be easier to extend the interpreter to account for new/altered CFI steps (say for references\r\n//   to vector objects or multiple CFIs) than if lexing, parsing and interpretation were all handled in a single step. Finally, Readium's objective is\r\n//   to demonstrate implementation of the EPUB 3.0 spec. An implementation with a strong separation of concerns that conforms to\r\n//   well-understood patterns for DSL processing should be easier to communicate, analyze and understand.\r\n// REFACTORING CANDIDATE: node type errors shouldn't really be possible if the CFI syntax is correct and the parser is error free.\r\n//   Might want to make the script die in those instances, once the grammar and interpreter are more stable.\r\n// REFACTORING CANDIDATE: The use of the 'nodeType' property is confusing as this is a DOM node property and the two are unrelated.\r\n//   Whoops. There shouldn't be any interference, however, I think this should be changed.\r\n\r\n    // ------------------------------------------------------------------------------------ //\r\n    //  \"PUBLIC\" METHODS (THE API)                                                          //\r\n    // ------------------------------------------------------------------------------------ //\r\n\r\n    // Description: Find the content document referenced by the spine item. This should be the spine item\r\n    //   referenced by the first indirection step in the CFI.\r\n    // Rationale: This method is a part of the API so that the reading system can \"interact\" the content document\r\n    //   pointed to by a CFI. If this is not a separate step, the processing of the CFI must be tightly coupled with\r\n    //   the reading system, as it stands now.\r\n    getContentDocHref : function (CFI, packageDocument, classBlacklist, elementBlacklist, idBlacklist) {\r\n\r\n        var $packageDocument = $(packageDocument);\r\n        var decodedCFI = decodeURI(CFI);\r\n        var CFIAST = cfiParser.parse(decodedCFI);\r\n\r\n        if (!CFIAST || CFIAST.type !== \"CFIAST\") {\r\n            throw cfiRuntimeErrors.NodeTypeError(CFIAST, \"expected CFI AST root node\");\r\n        }\r\n\r\n        // Interpet the path node (the package document step)\r\n        var $packageElement = $($(\"package\", $packageDocument)[0]);\r\n        var $currElement = this.interpretIndexStepNode(CFIAST.cfiString.path, $packageElement, classBlacklist, elementBlacklist, idBlacklist);\r\n        foundHref = this.searchLocalPathForHref($currElement, $packageDocument, CFIAST.cfiString.localPath, classBlacklist, elementBlacklist, idBlacklist);\r\n\r\n        if (foundHref) {\r\n            return foundHref;\r\n        }\r\n        else {\r\n            return undefined;\r\n        }\r\n    },\r\n\r\n    // Description: Inject an arbitrary html element into a position in a content document referenced by a CFI\r\n    injectElement : function (CFI, contentDocument, elementToInject, classBlacklist, elementBlacklist, idBlacklist) {\r\n\r\n        var decodedCFI = decodeURI(CFI);\r\n        var CFIAST = cfiParser.parse(decodedCFI);\r\n        var indirectionNode;\r\n        var indirectionStepNum;\r\n        var $currElement;\r\n\r\n        // Rationale: Since the correct content document for this CFI is already being passed, we can skip to the beginning\r\n        //   of the indirection step that referenced the content document.\r\n        // Note: This assumes that indirection steps and index steps conform to an interface: an object with stepLength, idAssertion\r\n        indirectionStepNum = this.getFirstIndirectionStepNum(CFIAST);\r\n        indirectionNode = CFIAST.cfiString.localPath.steps[indirectionStepNum];\r\n        indirectionNode.type = \"indexStep\";\r\n\r\n        // Interpret the rest of the steps\r\n        $currElement = this.interpretLocalPath(CFIAST.cfiString.localPath, indirectionStepNum, $(contentDocument.documentElement, contentDocument), classBlacklist, elementBlacklist, idBlacklist);\r\n\r\n        // TODO: detect what kind of terminus; for now, text node termini are the only kind implemented\r\n        $currElement = this.interpretTextTerminusNode(CFIAST.cfiString.localPath.termStep, $currElement, elementToInject);\r\n\r\n        // Return the element that was injected into\r\n        return $currElement;\r\n    },\r\n\r\n    // Description: Inject an arbitrary html element into a position in a content document referenced by a CFI\r\n    injectRangeElements : function (rangeCFI, contentDocument, startElementToInject, endElementToInject, classBlacklist, elementBlacklist, idBlacklist) {\r\n\r\n        var decodedCFI = decodeURI(rangeCFI);\r\n        var CFIAST = cfiParser.parse(decodedCFI);\r\n        var indirectionNode;\r\n        var indirectionStepNum;\r\n        var $currElement;\r\n        var $range1TargetElement;\r\n        var $range2TargetElement;\r\n\r\n        // Rationale: Since the correct content document for this CFI is already being passed, we can skip to the beginning\r\n        //   of the indirection step that referenced the content document.\r\n        // Note: This assumes that indirection steps and index steps conform to an interface: an object with stepLength, idAssertion\r\n        indirectionStepNum = this.getFirstIndirectionStepNum(CFIAST);\r\n        indirectionNode = CFIAST.cfiString.localPath.steps[indirectionStepNum];\r\n        indirectionNode.type = \"indexStep\";\r\n\r\n        // Interpret the rest of the steps in the first local path\r\n        $currElement = this.interpretLocalPath(CFIAST.cfiString.localPath, indirectionStepNum, $(contentDocument.documentElement, contentDocument), classBlacklist, elementBlacklist, idBlacklist);\r\n\r\n        // Interpret the first range local_path\r\n        $range1TargetElement = this.interpretLocalPath(CFIAST.cfiString.range1, 0, $currElement, classBlacklist, elementBlacklist, idBlacklist);\r\n        $range1TargetElement = this.interpretTextTerminusNode(CFIAST.cfiString.range1.termStep, $range1TargetElement, startElementToInject);\r\n\r\n        // Interpret the second range local_path\r\n        $range2TargetElement = this.interpretLocalPath(CFIAST.cfiString.range2, 0, $currElement, classBlacklist, elementBlacklist, idBlacklist);\r\n        $range2TargetElement = this.interpretTextTerminusNode(CFIAST.cfiString.range2.termStep, $range2TargetElement, endElementToInject);\r\n\r\n        // Return the element that was injected into\r\n        return {\r\n            startElement : $range1TargetElement[0],\r\n            endElement : $range2TargetElement[0]\r\n        };\r\n    },\r\n\r\n    // Description: This method will return the element or node (say, a text node) that is the final target of the\r\n    //   the CFI.\r\n    getTargetElement : function (CFI, contentDocument, classBlacklist, elementBlacklist, idBlacklist) {\r\n\r\n        var decodedCFI = decodeURI(CFI);\r\n        var CFIAST = cfiParser.parse(decodedCFI);\r\n        var indirectionNode;\r\n        var indirectionStepNum;\r\n        var $currElement;\r\n\r\n        // Rationale: Since the correct content document for this CFI is already being passed, we can skip to the beginning\r\n        //   of the indirection step that referenced the content document.\r\n        // Note: This assumes that indirection steps and index steps conform to an interface: an object with stepLength, idAssertion\r\n        indirectionStepNum = this.getFirstIndirectionStepNum(CFIAST);\r\n        indirectionNode = CFIAST.cfiString.localPath.steps[indirectionStepNum];\r\n        indirectionNode.type = \"indexStep\";\r\n\r\n        // Interpret the rest of the steps\r\n        $currElement = this.interpretLocalPath(CFIAST.cfiString.localPath, indirectionStepNum, $(contentDocument.documentElement, contentDocument), classBlacklist, elementBlacklist, idBlacklist);\r\n\r\n        // Return the element at the end of the CFI\r\n        return $currElement;\r\n    },\r\n\r\n    // Description: This method will return the start and end elements (along with their char offsets) that are the final targets of the range CFI.\r\n    getRangeTargetElements : function (rangeCFI, contentDocument, classBlacklist, elementBlacklist, idBlacklist) {\r\n\r\n        var decodedCFI = decodeURI(rangeCFI);\r\n        var CFIAST = cfiParser.parse(decodedCFI);\r\n        var indirectionNode;\r\n        var indirectionStepNum;\r\n        var $currElement;\r\n        var $range1TargetElement;\r\n        var $range2TargetElement;\r\n\r\n        // Rationale: Since the correct content document for this CFI is already being passed, we can skip to the beginning\r\n        //   of the indirection step that referenced the content document.\r\n        // Note: This assumes that indirection steps and index steps conform to an interface: an object with stepLength, idAssertion\r\n        indirectionStepNum = this.getFirstIndirectionStepNum(CFIAST);\r\n        indirectionNode = CFIAST.cfiString.localPath.steps[indirectionStepNum];\r\n        indirectionNode.type = \"indexStep\";\r\n\r\n        // Interpret the rest of the steps\r\n        $currElement = this.interpretLocalPath(CFIAST.cfiString.localPath, indirectionStepNum, $(contentDocument.documentElement, contentDocument), classBlacklist, elementBlacklist, idBlacklist);\r\n\r\n        // Interpret first range local_path\r\n        $range1TargetElement = this.interpretLocalPath(CFIAST.cfiString.range1, 0, $currElement, classBlacklist, elementBlacklist, idBlacklist);\r\n\r\n        // Interpret second range local_path\r\n        $range2TargetElement = this.interpretLocalPath(CFIAST.cfiString.range2, 0, $currElement, classBlacklist, elementBlacklist, idBlacklist);\r\n\r\n        // Get the start and end character offsets\r\n        var startOffset = parseInt(CFIAST.cfiString.range1.termStep.offsetValue) || undefined;\r\n        var endOffset = parseInt(CFIAST.cfiString.range2.termStep.offsetValue) || undefined;\r\n\r\n        // Return the element (and char offsets) at the end of the CFI\r\n        return {\r\n            startElement: $range1TargetElement[0],\r\n            startOffset: startOffset,\r\n            endElement: $range2TargetElement[0],\r\n            endOffset: endOffset\r\n        };\r\n    },\r\n\r\n    // Description: This method allows a \"partial\" CFI to be used to reference a target in a content document, without a\r\n    //   package document CFI component.\r\n    // Arguments: {\r\n    //     contentDocumentCFI : This is a partial CFI that represents a path in a content document only. This partial must be\r\n    //        syntactically valid, even though it references a path starting at the top of a content document (which is a CFI that\r\n    //        that has no defined meaning in the spec.)\r\n    //     contentDocument : A DOM representation of the content document to which the partial CFI refers.\r\n    // }\r\n    // Rationale: This method exists to meet the requirements of the Readium-SDK and should be used with care\r\n    getTargetElementWithPartialCFI : function (contentDocumentCFI, contentDocument, classBlacklist, elementBlacklist, idBlacklist) {\r\n\r\n        var decodedCFI = decodeURI(contentDocumentCFI);\r\n        var CFIAST = cfiParser.parse(decodedCFI);\r\n        var indirectionNode;\r\n\r\n        // Interpret the path node\r\n        var $currElement = this.interpretIndexStepNode(CFIAST.cfiString.path, $(contentDocument.documentElement, contentDocument), classBlacklist, elementBlacklist, idBlacklist);\r\n\r\n        // Interpret the rest of the steps\r\n        $currElement = this.interpretLocalPath(CFIAST.cfiString.localPath, 0, $currElement, classBlacklist, elementBlacklist, idBlacklist);\r\n\r\n        // Return the element at the end of the CFI\r\n        return $currElement;\r\n    },\r\n\r\n    // Description: This method allows a \"partial\" CFI to be used, with a content document, to return the text node and offset\r\n    //    referenced by the partial CFI.\r\n    // Arguments: {\r\n    //     contentDocumentCFI : This is a partial CFI that represents a path in a content document only. This partial must be\r\n    //        syntactically valid, even though it references a path starting at the top of a content document (which is a CFI that\r\n    //        that has no defined meaning in the spec.)\r\n    //     contentDocument : A DOM representation of the content document to which the partial CFI refers.\r\n    // }\r\n    getTextTerminusInfoWithPartialCFI : function (contentDocumentCFI, contentDocument, classBlacklist, elementBlacklist, idBlacklist) {\r\n\r\n        var decodedCFI = decodeURI(contentDocumentCFI);\r\n        var CFIAST = cfiParser.parse(decodedCFI);\r\n        var indirectionNode;\r\n        var textOffset;\r\n\r\n        // Interpret the path node\r\n        var $currElement = this.interpretIndexStepNode(CFIAST.cfiString.path, $(contentDocument.documentElement, contentDocument), classBlacklist, elementBlacklist, idBlacklist);\r\n\r\n        // Interpret the rest of the steps\r\n        $currElement = this.interpretLocalPath(CFIAST.cfiString.localPath, 0, $currElement, classBlacklist, elementBlacklist, idBlacklist);\r\n\r\n        // Return the element at the end of the CFI\r\n        textOffset = parseInt(CFIAST.cfiString.localPath.termStep.offsetValue);\r\n        return {\r\n            textNode: $currElement[0],\r\n            textOffset: textOffset\r\n        };\r\n    },\r\n\r\n    // Description: This method will return the element or node (say, a text node) that is the final target of the\r\n    //   the CFI, along with the text terminus offset.\r\n    getTextTerminusInfo : function (CFI, contentDocument, classBlacklist, elementBlacklist, idBlacklist) {\r\n\r\n        var decodedCFI = decodeURI(CFI);\r\n        var CFIAST = cfiParser.parse(decodedCFI);\r\n        var indirectionNode;\r\n        var indirectionStepNum;\r\n        var $currElement;\r\n        var textOffset;\r\n\r\n        // Rationale: Since the correct content document for this CFI is already being passed, we can skip to the beginning\r\n        //   of the indirection step that referenced the content document.\r\n        // Note: This assumes that indirection steps and index steps conform to an interface: an object with stepLength, idAssertion\r\n        indirectionStepNum = this.getFirstIndirectionStepNum(CFIAST);\r\n        indirectionNode = CFIAST.cfiString.localPath.steps[indirectionStepNum];\r\n        indirectionNode.type = \"indexStep\";\r\n\r\n        // Interpret the rest of the steps\r\n        $currElement = this.interpretLocalPath(CFIAST.cfiString.localPath, indirectionStepNum, $(contentDocument.documentElement, contentDocument), classBlacklist, elementBlacklist, idBlacklist);\r\n\r\n        // Return the element at the end of the CFI\r\n        textOffset = parseInt(CFIAST.cfiString.localPath.termStep.offsetValue);\r\n        return {\r\n            textNode: $currElement[0],\r\n            textOffset: textOffset\r\n        };\r\n    },\r\n\r\n    // Description: This function will determine if the input \"partial\" CFI is expressed as a range\r\n    isRangeCfi: function (cfi) {\r\n        var CFIAST = cfiParser.parse(cfi);\r\n        return CFIAST.cfiString.range1 ? true : false;\r\n    },\r\n\r\n    // Description: This function will determine if the input \"partial\" CFI has a text terminus step\r\n    hasTextTerminus: function (cfi) {\r\n        var CFIAST = cfiParser.parse(cfi);\r\n        return CFIAST.cfiString.localPath.termStep ? true : false;\r\n    },\r\n\r\n    // ------------------------------------------------------------------------------------ //\r\n    //  \"PRIVATE\" HELPERS                                                                   //\r\n    // ------------------------------------------------------------------------------------ //\r\n\r\n    getFirstIndirectionStepNum : function (CFIAST) {\r\n\r\n        // Find the first indirection step in the local path; follow it like a regular step, as the step in the content document it\r\n        //   references is already loaded and has been passed to this method\r\n        var stepNum = 0;\r\n        for (stepNum; stepNum <= CFIAST.cfiString.localPath.steps.length - 1 ; stepNum++) {\r\n\r\n            nextStepNode = CFIAST.cfiString.localPath.steps[stepNum];\r\n            if (nextStepNode.type === \"indirectionStep\") {\r\n                return stepNum;\r\n            }\r\n        }\r\n    },\r\n\r\n    // REFACTORING CANDIDATE: cfiString node and start step num could be merged into one argument, by simply passing the\r\n    //   starting step... probably a good idea, this would make the meaning of this method clearer.\r\n    interpretLocalPath : function (localPathNode, startStepNum, $currElement, classBlacklist, elementBlacklist, idBlacklist) {\r\n\r\n        var stepNum = startStepNum;\r\n        var nextStepNode;\r\n        for (stepNum; stepNum <= localPathNode.steps.length - 1 ; stepNum++) {\r\n\r\n            nextStepNode = localPathNode.steps[stepNum];\r\n            if (nextStepNode.type === \"indexStep\") {\r\n\r\n                $currElement = this.interpretIndexStepNode(nextStepNode, $currElement, classBlacklist, elementBlacklist, idBlacklist);\r\n            }\r\n            else if (nextStepNode.type === \"indirectionStep\") {\r\n\r\n                $currElement = this.interpretIndirectionStepNode(nextStepNode, $currElement, classBlacklist, elementBlacklist, idBlacklist);\r\n            }\r\n        }\r\n\r\n        return $currElement;\r\n    },\r\n\r\n    interpretIndexStepNode : function (indexStepNode, $currElement, classBlacklist, elementBlacklist, idBlacklist) {\r\n\r\n        // Check node type; throw error if wrong type\r\n        if (indexStepNode === undefined || indexStepNode.type !== \"indexStep\") {\r\n\r\n            throw cfiRuntimeErrors.NodeTypeError(indexStepNode, \"expected index step node\");\r\n        }\r\n\r\n        // Index step\r\n        var $stepTarget = cfiInstructions.getNextNode(indexStepNode.stepLength, $currElement, classBlacklist, elementBlacklist, idBlacklist);\r\n\r\n        // Check the id assertion, if it exists\r\n        if (indexStepNode.idAssertion) {\r\n\r\n            if (!cfiInstructions.targetIdMatchesIdAssertion($stepTarget, indexStepNode.idAssertion)) {\r\n\r\n                throw cfiRuntimeErrors.CFIAssertionError(indexStepNode.idAssertion, $stepTarget.attr('id'), \"Id assertion failed\");\r\n            }\r\n        }\r\n\r\n        return $stepTarget;\r\n    },\r\n\r\n    interpretIndirectionStepNode : function (indirectionStepNode, $currElement, classBlacklist, elementBlacklist, idBlacklist) {\r\n\r\n        // Check node type; throw error if wrong type\r\n        if (indirectionStepNode === undefined || indirectionStepNode.type !== \"indirectionStep\") {\r\n\r\n            throw cfiRuntimeErrors.NodeTypeError(indirectionStepNode, \"expected indirection step node\");\r\n        }\r\n\r\n        // Indirection step\r\n        var $stepTarget = cfiInstructions.followIndirectionStep(\r\n            indirectionStepNode.stepLength,\r\n            $currElement,\r\n            classBlacklist,\r\n            elementBlacklist);\r\n\r\n        // Check the id assertion, if it exists\r\n        if (indirectionStepNode.idAssertion) {\r\n\r\n            if (!cfiInstructions.targetIdMatchesIdAssertion($stepTarget, indirectionStepNode.idAssertion)) {\r\n\r\n                throw cfiRuntimeErrors.CFIAssertionError(indirectionStepNode.idAssertion, $stepTarget.attr('id'), \"Id assertion failed\");\r\n            }\r\n        }\r\n\r\n        return $stepTarget;\r\n    },\r\n\r\n    // REFACTORING CANDIDATE: The logic here assumes that a user will always want to use this terminus\r\n    //   to inject content into the found node. This will not always be the case, and different types of interpretation\r\n    //   are probably desired.\r\n    interpretTextTerminusNode : function (terminusNode, $currElement, elementToInject) {\r\n\r\n        if (terminusNode === undefined || terminusNode.type !== \"textTerminus\") {\r\n\r\n            throw cfiRuntimeErrors.NodeTypeError(terminusNode, \"expected text terminus node\");\r\n        }\r\n\r\n        var $injectedElement = cfiInstructions.textTermination(\r\n            $currElement,\r\n            terminusNode.offsetValue,\r\n            elementToInject\r\n            );\r\n\r\n        return $injectedElement;\r\n    },\r\n\r\n    searchLocalPathForHref : function ($currElement, $packageDocument, localPathNode, classBlacklist, elementBlacklist, idBlacklist) {\r\n\r\n        // Interpret the first local_path node, which is a set of steps and and a terminus condition\r\n        var stepNum = 0;\r\n        var nextStepNode;\r\n        for (stepNum = 0 ; stepNum <= localPathNode.steps.length - 1 ; stepNum++) {\r\n\r\n            nextStepNode = localPathNode.steps[stepNum];\r\n            if (nextStepNode.type === \"indexStep\") {\r\n\r\n                $currElement = this.interpretIndexStepNode(nextStepNode, $currElement, classBlacklist, elementBlacklist, idBlacklist);\r\n            }\r\n            else if (nextStepNode.type === \"indirectionStep\") {\r\n\r\n                $currElement = this.interpretIndirectionStepNode(nextStepNode, $currElement, classBlacklist, elementBlacklist, idBlacklist);\r\n            }\r\n\r\n            // Found the content document href referenced by the spine item\r\n            if ($currElement.is(\"itemref\")) {\r\n\r\n                return cfiInstructions.retrieveItemRefHref($currElement, $packageDocument);\r\n            }\r\n        }\r\n\r\n        return undefined;\r\n    }\r\n};\r\n\r\nreturn obj;\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nif (typeof define == 'function' && typeof define.amd == 'object') {\r\n    console.log(\"RequireJS ... cfi_interpreter\");\r\n\r\n    define('readium_cfi_js/cfi_interpreter',['jquery', 'readium_cfi_js/cfi_parser', './cfi_instructions', './cfi_runtime_errors'],\r\n    function ($, cfiParser, cfiInstructions, cfiRuntimeErrors) {\r\n        return init($, cfiParser, cfiInstructions, cfiRuntimeErrors);\r\n    });\r\n} else {\r\n    console.log(\"!RequireJS ... cfi_interpreter\");\r\n\r\n    if (!global[\"EPUBcfi\"]) {\r\n        throw new Error(\"EPUBcfi not initialised on global object?! (window or this context)\");\r\n    }\r\n    global.EPUBcfi.Interpreter =\r\n    init($,\r\n        global.EPUBcfi.Parser,\r\n        global.EPUBcfi.CFIInstructions,\r\n        {\r\n            NodeTypeError: global.EPUBcfi.NodeTypeError,\r\n            OutOfRangeError: global.EPUBcfi.OutOfRangeError,\r\n            TerminusError: global.EPUBcfi.TerminusError,\r\n            CFIAssertionError: global.EPUBcfi.CFIAssertionError\r\n        });\r\n}\r\n\r\n})(typeof window !== \"undefined\" ? window : this);\r\n\n",
    "//  Copyright (c) 2014 Readium Foundation and/or its licensees. All rights reserved.\r\n//  \r\n//  Redistribution and use in source and binary forms, with or without modification, \r\n//  are permitted provided that the following conditions are met:\r\n//  1. Redistributions of source code must retain the above copyright notice, this \r\n//  list of conditions and the following disclaimer.\r\n//  2. Redistributions in binary form must reproduce the above copyright notice, \r\n//  this list of conditions and the following disclaimer in the documentation and/or \r\n//  other materials provided with the distribution.\r\n//  3. Neither the name of the organization nor the names of its contributors may be \r\n//  used to endorse or promote products derived from this software without specific \r\n//  prior written permission.\r\n\r\n(function(global) {\r\n\r\nvar init = function($, cfiInstructions, cfiRuntimeErrors) {\r\n    \r\n    if (typeof cfiInstructions === \"undefined\") {\r\n        throw new Error(\"UNDEFINED?! cfiInstructions\");\r\n    }\r\n    \r\n    if (typeof cfiRuntimeErrors === \"undefined\") {\r\n        throw new Error(\"UNDEFINED?! cfiRuntimeErrors\");\r\n    }\r\n    \r\nvar obj = {\r\n\r\n    // ------------------------------------------------------------------------------------ //\r\n    //  \"PUBLIC\" METHODS (THE API)                                                          //\r\n    // ------------------------------------------------------------------------------------ //\r\n\r\n    generateCharOffsetRangeComponent : function (rangeStartElement, startOffset, rangeEndElement, endOffset, classBlacklist, elementBlacklist, idBlacklist) {\r\n        var document = rangeStartElement.ownerDocument;\r\n\r\n        var docRange;\r\n        var commonAncestor;\r\n        var $rangeStartParent;\r\n        var $rangeEndParent;\r\n        var range1OffsetStep;\r\n        var range1CFI;\r\n        var range2OffsetStep;\r\n        var range2CFI;\r\n        var commonCFIComponent;\r\n\r\n        this.validateStartTextNode(rangeStartElement);\r\n        this.validateStartTextNode(rangeEndElement);\r\n\r\n        // Parent element is the same\r\n        if ($(rangeStartElement).parent()[0] === $(rangeEndElement).parent()[0]) {\r\n            range1OffsetStep = this.createCFITextNodeStep($(rangeStartElement), startOffset, classBlacklist, elementBlacklist, idBlacklist);\r\n            range2OffsetStep = this.createCFITextNodeStep($(rangeEndElement), endOffset, classBlacklist, elementBlacklist, idBlacklist);          \r\n            commonCFIComponent = this.createCFIElementSteps($(rangeStartElement).parent(), \"html\", classBlacklist, elementBlacklist, idBlacklist);\r\n            return commonCFIComponent.substring(1, commonCFIComponent.length) + \",\" + range1OffsetStep + \",\" + range2OffsetStep;\r\n        }\r\n        else {\r\n\r\n            // Create a document range to find the common ancestor\r\n            docRange = document.createRange();\r\n            docRange.setStart(rangeStartElement, startOffset);\r\n            docRange.setEnd(rangeEndElement, endOffset);\r\n            commonAncestor = docRange.commonAncestorContainer;\r\n\r\n            // Generate terminating offset and range 1\r\n            range1OffsetStep = this.createCFITextNodeStep($(rangeStartElement), startOffset, classBlacklist, elementBlacklist, idBlacklist);\r\n            $rangeStartParent = $(rangeStartElement).parent();\r\n            if ($rangeStartParent[0] === commonAncestor) {\r\n              // rangeStartElement is a text child node of the commonAncestor, so it's CFI sub-path is only the text node step:\r\n              range1CFI = range1OffsetStep;\r\n            } else {\r\n              range1CFI = this.createCFIElementSteps($rangeStartParent, commonAncestor, classBlacklist, elementBlacklist, idBlacklist) + range1OffsetStep;\r\n            }\r\n\r\n            // Generate terminating offset and range 2\r\n            range2OffsetStep = this.createCFITextNodeStep($(rangeEndElement), endOffset, classBlacklist, elementBlacklist, idBlacklist);\r\n            $rangeEndParent = $(rangeEndElement).parent();\r\n            if ($rangeEndParent[0] === commonAncestor) {\r\n              // rangeEndElement is a text child node of the commonAncestor, so it's CFI sub-path is only the text node step:\r\n              range2CFI = range2OffsetStep;\r\n            } else {\r\n              range2CFI = this.createCFIElementSteps($rangeEndParent, commonAncestor, classBlacklist, elementBlacklist, idBlacklist) + range2OffsetStep;\r\n            }\r\n\r\n            // Generate shared component\r\n            commonCFIComponent = this.createCFIElementSteps($(commonAncestor), \"html\", classBlacklist, elementBlacklist, idBlacklist);\r\n\r\n            // Return the result\r\n            return commonCFIComponent.substring(1, commonCFIComponent.length) + \",\" + range1CFI + \",\" + range2CFI;\r\n        }\r\n    },\r\n\r\n    generateElementRangeComponent : function (rangeStartElement, rangeEndElement, classBlacklist, elementBlacklist, idBlacklist) {\r\n        var document = rangeStartElement.ownerDocument;\r\n\r\n        var docRange;\r\n        var commonAncestor;\r\n        var range1CFI;\r\n        var range2CFI;\r\n        var commonCFIComponent;\r\n\r\n        this.validateStartElement(rangeStartElement);\r\n        this.validateStartElement(rangeEndElement);\r\n\r\n        if (rangeStartElement === rangeEndElement) {\r\n            throw new Error(\"Start and end element cannot be the same for a CFI range\");\r\n        }\r\n\r\n        // Create a document range to find the common ancestor\r\n        docRange = document.createRange();\r\n        docRange.setStart(rangeStartElement, 0);\r\n        docRange.setEnd(rangeEndElement, rangeEndElement.childNodes.length);\r\n        commonAncestor = docRange.commonAncestorContainer;\r\n\r\n        // Generate range 1\r\n        range1CFI = this.createCFIElementSteps($(rangeStartElement), commonAncestor, classBlacklist, elementBlacklist, idBlacklist);\r\n\r\n        // Generate range 2\r\n        range2CFI = this.createCFIElementSteps($(rangeEndElement), commonAncestor, classBlacklist, elementBlacklist, idBlacklist);\r\n\r\n        // Generate shared component\r\n        commonCFIComponent = this.createCFIElementSteps($(commonAncestor), \"html\", classBlacklist, elementBlacklist, idBlacklist);\r\n\r\n        // Return the result\r\n        return commonCFIComponent.substring(1, commonCFIComponent.length) + \",\" + range1CFI + \",\" + range2CFI;\r\n    },\r\n\r\n    generateRangeComponent : function (rangeStartElement, startOffset, rangeEndElement, endOffset, classBlacklist, elementBlacklist, idBlacklist) {\r\n        var document = rangeStartElement.ownerDocument;\r\n\r\n        if(rangeStartElement.nodeType === Node.ELEMENT_NODE && rangeEndElement.nodeType === Node.ELEMENT_NODE){\r\n            return this.generateElementRangeComponent(rangeStartElement, rangeEndElement, classBlacklist, elementBlacklist, idBlacklist);\r\n        } else if(rangeStartElement.nodeType === Node.TEXT_NODE && rangeEndElement.nodeType === Node.TEXT_NODE){\r\n            return this.generateCharOffsetRangeComponent(rangeStartElement, startOffset, rangeEndElement, endOffset, classBlacklist, elementBlacklist, idBlacklist);\r\n        } else {\r\n            var docRange;\r\n            var range1CFI;\r\n            var range1OffsetStep;\r\n            var range2CFI;\r\n            var range2OffsetStep;\r\n            var commonAncestor;\r\n            var commonCFIComponent;\r\n\r\n            // Create a document range to find the common ancestor\r\n            docRange = document.createRange();\r\n            docRange.setStart(rangeStartElement, startOffset);\r\n            docRange.setEnd(rangeEndElement, endOffset);\r\n            commonAncestor = docRange.commonAncestorContainer;\r\n\r\n            if(rangeStartElement.nodeType === Node.ELEMENT_NODE){\r\n                this.validateStartElement(rangeStartElement);\r\n                range1CFI = this.createCFIElementSteps($(rangeStartElement), commonAncestor, classBlacklist, elementBlacklist, idBlacklist);\r\n            } else {\r\n                this.validateStartTextNode(rangeStartElement);\r\n                // Generate terminating offset and range 1\r\n                range1OffsetStep = this.createCFITextNodeStep($(rangeStartElement), startOffset, classBlacklist, elementBlacklist, idBlacklist);\r\n                if($(rangeStartElement).parent().is(commonAncestor)){\r\n                    range1CFI = range1OffsetStep;\r\n                } else {\r\n                    range1CFI = this.createCFIElementSteps($(rangeStartElement).parent(), commonAncestor, classBlacklist, elementBlacklist, idBlacklist) + range1OffsetStep;    \r\n                }\r\n            }\r\n\r\n            if(rangeEndElement.nodeType === Node.ELEMENT_NODE){\r\n                this.validateStartElement(rangeEndElement);\r\n                range2CFI = this.createCFIElementSteps($(rangeEndElement), commonAncestor, classBlacklist, elementBlacklist, idBlacklist);\r\n            } else {\r\n                this.validateStartTextNode(rangeEndElement);\r\n                // Generate terminating offset and range 2\r\n                range2OffsetStep = this.createCFITextNodeStep($(rangeEndElement), endOffset, classBlacklist, elementBlacklist, idBlacklist);\r\n                if($(rangeEndElement).parent().is(commonAncestor)){\r\n                    range2CFI = range2OffsetStep;\r\n                } else {\r\n                    range2CFI = this.createCFIElementSteps($(rangeEndElement).parent(), commonAncestor, classBlacklist, elementBlacklist, idBlacklist) + range2OffsetStep;    \r\n                }                \r\n            }\r\n\r\n            // Generate shared component\r\n            commonCFIComponent = this.createCFIElementSteps($(commonAncestor), \"html\", classBlacklist, elementBlacklist, idBlacklist);\r\n\r\n            // Return the result\r\n            return commonCFIComponent.substring(1, commonCFIComponent.length) + \",\" + range1CFI + \",\" + range2CFI;\r\n        }\r\n    },\r\n\r\n    // Description: Generates a character offset CFI \r\n    // Arguments: The text node that contains the offset referenced by the cfi, the offset value, the name of the \r\n    //   content document that contains the text node, the package document for this EPUB.\r\n    generateCharacterOffsetCFIComponent : function (startTextNode, characterOffset, classBlacklist, elementBlacklist, idBlacklist) {\r\n\r\n        var textNodeStep;\r\n        var contentDocCFI;\r\n        var $itemRefStartNode;\r\n        var packageDocCFI;\r\n\r\n        this.validateStartTextNode(startTextNode, characterOffset);\r\n\r\n        // Create the text node step\r\n        textNodeStep = this.createCFITextNodeStep($(startTextNode), characterOffset, classBlacklist, elementBlacklist, idBlacklist);\r\n\r\n        // Call the recursive method to create all the steps up to the head element of the content document (the \"html\" element)\r\n        contentDocCFI = this.createCFIElementSteps($(startTextNode).parent(), \"html\", classBlacklist, elementBlacklist, idBlacklist) + textNodeStep;\r\n        return contentDocCFI.substring(1, contentDocCFI.length);\r\n    },\r\n\r\n    generateElementCFIComponent : function (startElement, classBlacklist, elementBlacklist, idBlacklist) {\r\n\r\n        var contentDocCFI;\r\n        var $itemRefStartNode;\r\n        var packageDocCFI;\r\n\r\n        this.validateStartElement(startElement);\r\n\r\n        // Call the recursive method to create all the steps up to the head element of the content document (the \"html\" element)\r\n        contentDocCFI = this.createCFIElementSteps($(startElement), \"html\", classBlacklist, elementBlacklist, idBlacklist);\r\n\r\n        // Remove the ! \r\n        return contentDocCFI.substring(1, contentDocCFI.length);\r\n    },\r\n\r\n    generatePackageDocumentCFIComponent : function (contentDocumentName, packageDocument, classBlacklist, elementBlacklist, idBlacklist) {\r\n\r\n        this.validateContentDocumentName(contentDocumentName);\r\n        this.validatePackageDocument(packageDocument, contentDocumentName);\r\n\r\n        // Get the start node (itemref element) that references the content document\r\n        $itemRefStartNode = $(\"itemref[idref='\" + contentDocumentName + \"']\", $(packageDocument));\r\n\r\n        // Create the steps up to the top element of the package document (the \"package\" element)\r\n        packageDocCFIComponent = this.createCFIElementSteps($itemRefStartNode, \"package\", classBlacklist, elementBlacklist, idBlacklist);\r\n\r\n        // Append an !; this assumes that a CFI content document CFI component will be appended at some point\r\n        return packageDocCFIComponent + \"!\";\r\n    },\r\n\r\n    generatePackageDocumentCFIComponentWithSpineIndex : function (spineIndex, packageDocument, classBlacklist, elementBlacklist, idBlacklist) {\r\n\r\n        // Get the start node (itemref element) that references the content document\r\n        $itemRefStartNode = $($(\"spine\", packageDocument).children()[spineIndex]);\r\n\r\n        // Create the steps up to the top element of the package document (the \"package\" element)\r\n        packageDocCFIComponent = this.createCFIElementSteps($itemRefStartNode, \"package\", classBlacklist, elementBlacklist, idBlacklist);\r\n\r\n        // Append an !; this assumes that a CFI content document CFI component will be appended at some point\r\n        return packageDocCFIComponent + \"!\";\r\n    },\r\n\r\n    generateCompleteCFI : function (packageDocumentCFIComponent, contentDocumentCFIComponent) {\r\n\r\n        return \"epubcfi(\" + packageDocumentCFIComponent + contentDocumentCFIComponent + \")\";  \r\n    },\r\n\r\n    // ------------------------------------------------------------------------------------ //\r\n    //  \"PRIVATE\" HELPERS                                                                   //\r\n    // ------------------------------------------------------------------------------------ //\r\n\r\n    validateStartTextNode : function (startTextNode, characterOffset) {\r\n        \r\n        // Check that the text node to start from IS a text node\r\n        if (!startTextNode) {\r\n            throw new cfiRuntimeErrors.NodeTypeError(startTextNode, \"Cannot generate a character offset from a starting point that is not a text node\");\r\n        } else if (startTextNode.nodeType != 3) {\r\n            throw new cfiRuntimeErrors.NodeTypeError(startTextNode, \"Cannot generate a character offset from a starting point that is not a text node\");\r\n        }\r\n\r\n        // Check that the character offset is within a valid range for the text node supplied\r\n        if (characterOffset < 0) {\r\n            throw new cfiRuntimeErrors.OutOfRangeError(characterOffset, 0, \"Character offset cannot be less than 0\");\r\n        }\r\n        else if (characterOffset > startTextNode.nodeValue.length) {\r\n            throw new cfiRuntimeErrors.OutOfRangeError(characterOffset, startTextNode.nodeValue.length - 1, \"character offset cannot be greater than the length of the text node\");\r\n        }\r\n    },\r\n\r\n    validateStartElement : function (startElement) {\r\n\r\n        if (!startElement) {\r\n            throw new cfiRuntimeErrors.NodeTypeError(startElement, \"CFI target element is undefined\");\r\n        }\r\n\r\n        if (!(startElement.nodeType && startElement.nodeType === 1)) {\r\n            throw new cfiRuntimeErrors.NodeTypeError(startElement, \"CFI target element is not an HTML element\");\r\n        }\r\n    },\r\n\r\n    validateContentDocumentName : function (contentDocumentName) {\r\n\r\n        // Check that the idref for the content document has been provided\r\n        if (!contentDocumentName) {\r\n            throw new Error(\"The idref for the content document, as found in the spine, must be supplied\");\r\n        }\r\n    },\r\n\r\n    validatePackageDocument : function (packageDocument, contentDocumentName) {\r\n        \r\n        // Check that the package document is non-empty and contains an itemref element for the supplied idref\r\n        if (!packageDocument) {\r\n            throw new Error(\"A package document must be supplied to generate a CFI\");\r\n        }\r\n        else if ($($(\"itemref[idref='\" + contentDocumentName + \"']\", packageDocument)[0]).length === 0) {\r\n            throw new Error(\"The idref of the content document could not be found in the spine\");\r\n        }\r\n    },\r\n\r\n    // Description: Creates a CFI terminating step to a text node, with a character offset\r\n    // REFACTORING CANDIDATE: Some of the parts of this method could be refactored into their own methods\r\n    createCFITextNodeStep : function ($startTextNode, characterOffset, classBlacklist, elementBlacklist, idBlacklist) {\r\n\r\n        var $parentNode;\r\n        var $contentsExcludingMarkers;\r\n        var CFIIndex;\r\n        var indexOfTextNode;\r\n        var preAssertion;\r\n        var preAssertionStartIndex;\r\n        var textLength;\r\n        var postAssertion;\r\n        var postAssertionEndIndex;\r\n\r\n        // Find text node position in the set of child elements, ignoring any blacklisted elements \r\n        $parentNode = $startTextNode.parent();\r\n        $contentsExcludingMarkers = cfiInstructions.applyBlacklist($parentNode.contents(), classBlacklist, elementBlacklist, idBlacklist);\r\n\r\n        // Find the text node index in the parent list, inferring nodes that were originally a single text node\r\n        var prevNodeWasTextNode;\r\n        var indexOfFirstInSequence;\r\n        var textNodeOnlyIndex = 0;\r\n        var characterOffsetSinceUnsplit = 0;\r\n        var finalCharacterOffsetInSequence = 0;\r\n        $.each($contentsExcludingMarkers, \r\n            function (index) {\r\n\r\n            // If this is a text node, check if it matches and return the current index\r\n            if (this.nodeType === Node.TEXT_NODE || !prevNodeWasTextNode) {\r\n\r\n                if (this.nodeType === Node.TEXT_NODE) {\r\n                    if (this === $startTextNode[0]) {\r\n\r\n                        // Set index as the first in the adjacent sequence of text nodes, or as the index of the current node if this \r\n                        //   node is a standard one sandwiched between two element nodes. \r\n                        if (prevNodeWasTextNode) {\r\n                            indexOfTextNode = indexOfFirstInSequence;\r\n                            finalCharacterOffsetInSequence = characterOffsetSinceUnsplit;\r\n                        } else {\r\n                            indexOfTextNode = textNodeOnlyIndex;\r\n                        }\r\n                        \r\n                        // Break out of .each loop\r\n                        return false; \r\n                    }\r\n\r\n                    // Save this index as the first in sequence of adjacent text nodes, if it is not already set by this point\r\n                    prevNodeWasTextNode = true;\r\n                    characterOffsetSinceUnsplit = characterOffsetSinceUnsplit + this.length;\r\n                    if (indexOfFirstInSequence === undefined) {\r\n                        indexOfFirstInSequence = textNodeOnlyIndex;\r\n                        textNodeOnlyIndex = textNodeOnlyIndex + 1;\r\n                    }\r\n                } else if (this.nodeType === Node.ELEMENT_NODE) {\r\n                    textNodeOnlyIndex = textNodeOnlyIndex + 1;\r\n                } else if (this.nodeType === Node.COMMENT_NODE) {\r\n                    prevNodeWasTextNode = true;\r\n                    characterOffsetSinceUnsplit = characterOffsetSinceUnsplit + this.length + 7; // 7 is the size of the html comment tag <!--[comment]-->\r\n                    if (indexOfFirstInSequence === undefined) {\r\n                        indexOfFirstInSequence = textNodeOnlyIndex;\r\n                    }\r\n                } else if (this.nodeType === Node.PROCESSING_INSTRUCTION_NODE) {\r\n                    prevNodeWasTextNode = true;\r\n                    characterOffsetSinceUnsplit = characterOffsetSinceUnsplit + this.data.length + this.target.length + 5; // 5 is the size of the instruction processing tag including the required space between the target and the data <?[target] [data]?>\r\n                    if (indexOfFirstInSequence === undefined) {\r\n                        indexOfFirstInSequence = textNodeOnlyIndex;\r\n                    }\r\n                }\r\n            }\r\n            // This node is not a text node\r\n            else if (this.nodeType === Node.ELEMENT_NODE) {\r\n                prevNodeWasTextNode = false;\r\n                indexOfFirstInSequence = undefined;\r\n                characterOffsetSinceUnsplit  = 0;\r\n            } else if (this.nodeType === Node.COMMENT_NODE) {\r\n                characterOffsetSinceUnsplit = characterOffsetSinceUnsplit + this.length + 7; // <!--[comment]-->\r\n            } else if (this.nodeType === Node.PROCESSING_INSTRUCTION_NODE) {\r\n                characterOffsetSinceUnsplit = characterOffsetSinceUnsplit + this.data.length + this.target.length + 5; // <?[target] [data]?>\r\n            }\r\n        });\r\n\r\n        // Convert the text node index to a CFI odd-integer representation\r\n        CFIIndex = (indexOfTextNode * 2) + 1;\r\n\r\n        // TODO: text assertions are not in the grammar yet, I think, or they're just causing problems. This has\r\n        //   been temporarily removed. \r\n\r\n        // Add pre- and post- text assertions\r\n        // preAssertionStartIndex = (characterOffset - 3 >= 0) ? characterOffset - 3 : 0;\r\n        // preAssertion = $startTextNode[0].nodeValue.substring(preAssertionStartIndex, characterOffset);\r\n\r\n        // textLength = $startTextNode[0].nodeValue.length;\r\n        // postAssertionEndIndex = (characterOffset + 3 <= textLength) ? characterOffset + 3 : textLength;\r\n        // postAssertion = $startTextNode[0].nodeValue.substring(characterOffset, postAssertionEndIndex);\r\n\r\n        // Gotta infer the correct character offset, as well\r\n\r\n        // Return the constructed CFI text node step\r\n        return \"/\" + CFIIndex + \":\" + (finalCharacterOffsetInSequence + characterOffset);\r\n         // + \"[\" + preAssertion + \",\" + postAssertion + \"]\";\r\n    },\r\n\r\n    createCFIElementSteps : function ($currNode, topLevelElement, classBlacklist, elementBlacklist, idBlacklist) {\r\n\r\n        var $blacklistExcluded;\r\n        var $parentNode;\r\n        var currNodePosition;\r\n        var CFIPosition;\r\n        var idAssertion;\r\n        var elementStep; \r\n\r\n\r\n\r\n        // per https://github.com/readium/readium-cfi-js/issues/28\r\n        // if the currentNode is the same as top level element, we're looking at a text node \r\n        // that's a direct child of \"topLevelElement\" so we don't need to include it in the element step.\r\n        if ($currNode[0] === topLevelElement) {\r\n            return \"\";\r\n        }\r\n\r\n        // Find position of current node in parent list\r\n        $blacklistExcluded = cfiInstructions.applyBlacklist($currNode.parent().children(), classBlacklist, elementBlacklist, idBlacklist);\r\n        $.each($blacklistExcluded, \r\n            function (index, value) {\r\n\r\n                if (this === $currNode[0]) {\r\n\r\n                    currNodePosition = index;\r\n\r\n                    // Break loop\r\n                    return false;\r\n                }\r\n        });\r\n\r\n        // Convert position to the CFI even-integer representation\r\n        CFIPosition = (currNodePosition + 1) * 2;\r\n\r\n        // Create CFI step with id assertion, if the element has an id\r\n        if ($currNode.attr(\"id\")) {\r\n            elementStep = \"/\" + CFIPosition + \"[\" + $currNode.attr(\"id\") + \"]\";\r\n        }\r\n        else {\r\n            elementStep = \"/\" + CFIPosition;\r\n        }\r\n\r\n        // If a parent is an html element return the (last) step for this content document, otherwise, continue.\r\n        //   Also need to check if the current node is the top-level element. This can occur if the start node is also the\r\n        //   top level element.\r\n        $parentNode = $currNode.parent();\r\n        if ($parentNode.is(topLevelElement) || $currNode.is(topLevelElement)) {\r\n            \r\n            // If the top level node is a type from which an indirection step, add an indirection step character (!)\r\n            // REFACTORING CANDIDATE: It is possible that this should be changed to: if (topLevelElement = 'package') do\r\n            //   not return an indirection character. Every other type of top-level element may require an indirection\r\n            //   step to navigate to, thus requiring that ! is always prepended. \r\n            if (topLevelElement === 'html') {\r\n                return \"!\" + elementStep;\r\n            }\r\n            else {\r\n                return elementStep;\r\n            }\r\n        }\r\n        else {\r\n            return this.createCFIElementSteps($parentNode, topLevelElement, classBlacklist, elementBlacklist, idBlacklist) + elementStep;\r\n        }\r\n    }\r\n};\r\n\r\nreturn obj;\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nif (typeof define == 'function' && typeof define.amd == 'object') {\r\n    console.log(\"RequireJS ... cfi_generator\");\r\n    \r\n    define('readium_cfi_js/cfi_generator',['jquery', './cfi_instructions', './cfi_runtime_errors'],\r\n    function ($, cfiInstructions, cfiRuntimeErrors) {\r\n        return init($, cfiInstructions, cfiRuntimeErrors);\r\n    });\r\n} else {\r\n    console.log(\"!RequireJS ... cfi_generator\");\r\n    \r\n    if (!global[\"EPUBcfi\"]) {\r\n        throw new Error(\"EPUBcfi not initialised on global object?! (window or this context)\");\r\n    }\r\n    global.EPUBcfi.Generator = \r\n    init($,\r\n        global.EPUBcfi.CFIInstructions,\r\n        {\r\n            NodeTypeError: global.EPUBcfi.NodeTypeError,\r\n            OutOfRangeError: global.EPUBcfi.OutOfRangeError,\r\n            TerminusError: global.EPUBcfi.TerminusError,\r\n            CFIAssertionError: global.EPUBcfi.CFIAssertionError\r\n        });\r\n}\r\n\r\n})(typeof window !== \"undefined\" ? window : this);\r\n\n",
    "//  Copyright (c) 2014 Readium Foundation and/or its licensees. All rights reserved.\r\n//\r\n//  Redistribution and use in source and binary forms, with or without modification,\r\n//  are permitted provided that the following conditions are met:\r\n//  1. Redistributions of source code must retain the above copyright notice, this\r\n//  list of conditions and the following disclaimer.\r\n//  2. Redistributions in binary form must reproduce the above copyright notice,\r\n//  this list of conditions and the following disclaimer in the documentation and/or\r\n//  other materials provided with the distribution.\r\n//  3. Neither the name of the organization nor the names of its contributors may be\r\n//  used to endorse or promote products derived from this software without specific\r\n//  prior written permission.\r\n\r\n(function(global) {\r\n\r\nvar init = function(cfiParser, cfiInterpreter, cfiInstructions, cfiRuntimeErrors, cfiGenerator) {\r\n\r\n    if (typeof cfiParser === \"undefined\") {\r\n        throw new Error(\"UNDEFINED?! cfiParser\");\r\n    }\r\n\r\n    if (typeof cfiInterpreter === \"undefined\") {\r\n        throw new Error(\"UNDEFINED?! cfiInterpreter\");\r\n    }\r\n\r\n    if (typeof cfiInstructions === \"undefined\") {\r\n        throw new Error(\"UNDEFINED?! cfiInstructions\");\r\n    }\r\n\r\n    if (typeof cfiRuntimeErrors === \"undefined\") {\r\n        throw new Error(\"UNDEFINED?! cfiRuntimeErrors\");\r\n    }\r\n\r\n    if (typeof cfiGenerator === \"undefined\") {\r\n        throw new Error(\"UNDEFINED?! cfiGenerator\");\r\n    }\r\n\r\n    var obj = {\r\n\r\n        getContentDocHref : function (CFI, packageDocument) {\r\n            return cfiInterpreter.getContentDocHref(CFI, packageDocument);\r\n        },\r\n        injectElement : function (CFI, contentDocument, elementToInject, classBlacklist, elementBlacklist, idBlacklist) {\r\n            return cfiInterpreter.injectElement(CFI, contentDocument, elementToInject, classBlacklist, elementBlacklist, idBlacklist);\r\n        },\r\n        getTargetElement : function (CFI, contentDocument, classBlacklist, elementBlacklist, idBlacklist) {\r\n            return cfiInterpreter.getTargetElement(CFI, contentDocument, classBlacklist, elementBlacklist, idBlacklist);\r\n        },\r\n        getTargetElementWithPartialCFI : function (contentDocumentCFI, contentDocument, classBlacklist, elementBlacklist, idBlacklist) {\r\n            return cfiInterpreter.getTargetElementWithPartialCFI(contentDocumentCFI, contentDocument, classBlacklist, elementBlacklist, idBlacklist);\r\n        },\r\n        injectRangeElements : function (rangeCFI, contentDocument, startElementToInject, endElementToInject, classBlacklist, elementBlacklist, idBlacklist) {\r\n            return cfiInterpreter.injectRangeElements(rangeCFI, contentDocument, startElementToInject, endElementToInject, classBlacklist, elementBlacklist, idBlacklist);\r\n        },\r\n        getRangeTargetElements : function (rangeCFI, contentDocument, classBlacklist, elementBlacklist, idBlacklist) {\r\n            return cfiInterpreter.getRangeTargetElements(rangeCFI, contentDocument, classBlacklist, elementBlacklist, idBlacklist);\r\n        },\r\n        isRangeCfi : function (cfi) {\r\n            return cfiInterpreter.isRangeCfi(cfi);\r\n        },\r\n        hasTextTerminus: function(cfi) {\r\n            return cfiInterpreter.hasTextTerminus(cfi);\r\n        },\r\n        getTextTerminusInfo : function (CFI, contentDocument, classBlacklist, elementBlacklist, idBlacklist) {\r\n            return cfiInterpreter.getTextTerminusInfo(CFI, contentDocument, classBlacklist, elementBlacklist, idBlacklist);\r\n        },\r\n        getTextTerminusInfoWithPartialCFI : function (contentDocumentCFI, contentDocument, classBlacklist, elementBlacklist, idBlacklist) {\r\n            return cfiInterpreter.getTextTerminusInfoWithPartialCFI(contentDocumentCFI, contentDocument, classBlacklist, elementBlacklist, idBlacklist);\r\n        },\r\n        generateCharacterOffsetCFIComponent : function (startTextNode, characterOffset, classBlacklist, elementBlacklist, idBlacklist) {\r\n            return cfiGenerator.generateCharacterOffsetCFIComponent(startTextNode, characterOffset, classBlacklist, elementBlacklist, idBlacklist);\r\n        },\r\n        generateElementCFIComponent : function (startElement, classBlacklist, elementBlacklist, idBlacklist) {\r\n            return cfiGenerator.generateElementCFIComponent(startElement, classBlacklist, elementBlacklist, idBlacklist);\r\n        },\r\n        generatePackageDocumentCFIComponent : function (contentDocumentName, packageDocument, classBlacklist, elementBlacklist, idBlacklist) {\r\n            return cfiGenerator.generatePackageDocumentCFIComponent(contentDocumentName, packageDocument, classBlacklist, elementBlacklist, idBlacklist);\r\n        },\r\n        generatePackageDocumentCFIComponentWithSpineIndex : function (spineIndex, packageDocument, classBlacklist, elementBlacklist, idBlacklist) {\r\n            return cfiGenerator.generatePackageDocumentCFIComponentWithSpineIndex(spineIndex, packageDocument, classBlacklist, elementBlacklist, idBlacklist);\r\n        },\r\n        generateCompleteCFI : function (packageDocumentCFIComponent, contentDocumentCFIComponent) {\r\n            return cfiGenerator.generateCompleteCFI(packageDocumentCFIComponent, contentDocumentCFIComponent);\r\n        },\r\n        generateCharOffsetRangeComponent : function (rangeStartElement, startOffset, rangeEndElement, endOffset, classBlacklist, elementBlacklist, idBlacklist) {\r\n            return cfiGenerator.generateCharOffsetRangeComponent(rangeStartElement, startOffset, rangeEndElement, endOffset, classBlacklist, elementBlacklist, idBlacklist);\r\n        },\r\n        generateElementRangeComponent : function (rangeStartElement, rangeEndElement, classBlacklist, elementBlacklist, idBlacklist) {\r\n            return cfiGenerator.generateElementRangeComponent(rangeStartElement, rangeEndElement, classBlacklist, elementBlacklist, idBlacklist);\r\n        },\r\n        generateRangeComponent : function (rangeStartElement, startOffset, rangeEndElement, endOffset, classBlacklist, elementBlacklist, idBlacklist) {\r\n            return cfiGenerator.generateRangeComponent(rangeStartElement, startOffset, rangeEndElement, endOffset, classBlacklist, elementBlacklist, idBlacklist);\r\n        },\r\n        injectElementAtOffset : function ($textNodeList, textOffset, elementToInject) {\r\n            return cfiInstructions.injectCFIMarkerIntoText($textNodeList, textOffset, elementToInject);\r\n        }\r\n    };\r\n\r\n\r\n    // TODO: remove global (should not be necessary in properly-configured RequireJS build!)\r\n    // ...but we leave it here as a \"legacy\" mechanism to access the CFI lib functionality\r\n    // -----\r\n    obj.CFIInstructions = cfiInstructions;\r\n    obj.Parser = cfiParser;\r\n    obj.Interpreter = cfiInterpreter;\r\n    obj.Generator = cfiGenerator;\r\n\r\n    obj.NodeTypeError= cfiRuntimeErrors.NodeTypeError;\r\n    obj.OutOfRangeError = cfiRuntimeErrors.OutOfRangeError;\r\n    obj.TerminusError = cfiRuntimeErrors.TerminusError;\r\n    obj.CFIAssertionError = cfiRuntimeErrors.CFIAssertionError;\r\n\r\n    global.EPUBcfi = obj;\r\n    // -----\r\n\r\n    console.log(\"#######################################\");\r\n    // console.log(global.EPUBcfi);\r\n    // console.log(\"#######################################\");\r\n\r\n    return obj;\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\nif (typeof define == 'function' && typeof define.amd == 'object') {\r\n    console.log(\"RequireJS ... cfi_API\");\r\n\r\n    define('readium_cfi_js/cfi_API',['readium_cfi_js/cfi_parser', './cfi_interpreter', './cfi_instructions', './cfi_runtime_errors', './cfi_generator'],\r\n    function (cfiParser, cfiInterpreter, cfiInstructions, cfiRuntimeErrors, cfiGenerator) {\r\n\r\n        return init(cfiParser, cfiInterpreter, cfiInstructions, cfiRuntimeErrors, cfiGenerator);\r\n    });\r\n} else {\r\n    console.log(\"!RequireJS ... cfi_API\");\r\n\r\n    if (!global[\"EPUBcfi\"]) {\r\n        throw new Error(\"EPUBcfi not initialised on global object?! (window or this context)\");\r\n    }\r\n\r\n    init(global.EPUBcfi.Parser,\r\n        global.EPUBcfi.Interpreter,\r\n        global.EPUBcfi.CFIInstructions,\r\n        {\r\n            NodeTypeError: global.EPUBcfi.NodeTypeError,\r\n            OutOfRangeError: global.EPUBcfi.OutOfRangeError,\r\n            TerminusError: global.EPUBcfi.TerminusError,\r\n            CFIAssertionError: global.EPUBcfi.CFIAssertionError\r\n        },\r\n        global.EPUBcfi.Generator);\r\n}\r\n\r\n})(typeof window !== \"undefined\" ? window : this);\r\n\ndefine('readium_cfi_js', ['readium_cfi_js/cfi_API'], function (main) { return main; });\n\n",
    "\ndefine(\"readium-cfi-js\", function(){});\n",
    "\nrequire([\"readium_cfi_js/cfi_API\"]);\n"
  ]
}